// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
	"go.opentelemetry.io/otel/trace"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AddStickerToSet invokes addStickerToSet operation.
	//
	// Use this method to add a new sticker to a set created by the bot. Emoji sticker sets can have up
	// to 200 stickers. Other sticker sets can have up to 120 stickers. Returns _True_ on success.
	//
	// POST /addStickerToSet
	AddStickerToSet(ctx context.Context, request *AddStickerToSet) (*Result, error)
	// AnswerCallbackQuery invokes answerCallbackQuery operation.
	//
	// Use this method to send answers to callback queries sent from [inline keyboards](https://core.
	// telegram.org/bots/features#inline-keyboards). The answer will be displayed to the user as a
	// notification at the top of the chat screen or as an alert. On success, _True_ is returned.
	//
	// POST /answerCallbackQuery
	AnswerCallbackQuery(ctx context.Context, request *AnswerCallbackQuery) (*Result, error)
	// AnswerInlineQuery invokes answerInlineQuery operation.
	//
	// Use this method to send answers to an inline query. On success, _True_ is returned.No more than
	// **50** results per query are allowed.
	//
	// POST /answerInlineQuery
	AnswerInlineQuery(ctx context.Context, request *AnswerInlineQuery) (*Result, error)
	// AnswerPreCheckoutQuery invokes answerPreCheckoutQuery operation.
	//
	// Once the user has confirmed their payment and shipping details, the Bot API sends the final
	// confirmation in the form of an [Update](https://core.telegram.org/bots/api#update) with the field
	// _pre_checkout_query_. Use this method to respond to such pre-checkout queries. On success, _True_
	// is returned. **Note:** The Bot API must receive an answer within 10 seconds after the pre-checkout
	// query was sent.
	//
	// POST /answerPreCheckoutQuery
	AnswerPreCheckoutQuery(ctx context.Context, request *AnswerPreCheckoutQuery) (*Result, error)
	// AnswerShippingQuery invokes answerShippingQuery operation.
	//
	// If you sent an invoice requesting a shipping address and the parameter _is_flexible_ was specified,
	//  the Bot API will send an [Update](https://core.telegram.org/bots/api#update) with a
	// _shipping_query_ field to the bot. Use this method to reply to shipping queries. On success,
	// _True_ is returned.
	//
	// POST /answerShippingQuery
	AnswerShippingQuery(ctx context.Context, request *AnswerShippingQuery) (*Result, error)
	// AnswerWebAppQuery invokes answerWebAppQuery operation.
	//
	// Use this method to set the result of an interaction with a [Web App](https://core.telegram.
	// org/bots/webapps) and send a corresponding message on behalf of the user to the chat from which
	// the query originated. On success, a [SentWebAppMessage](https://core.telegram.
	// org/bots/api#sentwebappmessage) object is returned.
	//
	// POST /answerWebAppQuery
	AnswerWebAppQuery(ctx context.Context, request *AnswerWebAppQuery) (*Result, error)
	// ApproveChatJoinRequest invokes approveChatJoinRequest operation.
	//
	// Use this method to approve a chat join request. The bot must be an administrator in the chat for
	// this to work and must have the _can_invite_users_ administrator right. Returns _True_ on success.
	//
	// POST /approveChatJoinRequest
	ApproveChatJoinRequest(ctx context.Context, request *ApproveChatJoinRequest) (*Result, error)
	// BanChatMember invokes banChatMember operation.
	//
	// Use this method to ban a user in a group, a supergroup or a channel. In the case of supergroups
	// and channels, the user will not be able to return to the chat on their own using invite links, etc.
	// , unless [unbanned](https://core.telegram.org/bots/api#unbanchatmember) first. The bot must be an
	// administrator in the chat for this to work and must have the appropriate administrator rights.
	// Returns _True_ on success.
	//
	// POST /banChatMember
	BanChatMember(ctx context.Context, request *BanChatMember) (*Result, error)
	// BanChatSenderChat invokes banChatSenderChat operation.
	//
	// Use this method to ban a channel chat in a supergroup or a channel. Until the chat is
	// [unbanned](https://core.telegram.org/bots/api#unbanchatsenderchat), the owner of the banned chat
	// won't be able to send messages on behalf of **any of their channels**. The bot must be an
	// administrator in the supergroup or channel for this to work and must have the appropriate
	// administrator rights. Returns _True_ on success.
	//
	// POST /banChatSenderChat
	BanChatSenderChat(ctx context.Context, request *BanChatSenderChat) (*Result, error)
	// Close invokes close operation.
	//
	// Use this method to close the bot instance before moving it from one local server to another. You
	// need to delete the webhook before calling this method to ensure that the bot isn't launched again
	// after server restart. The method will return error 429 in the first 10 minutes after the bot is
	// launched. Returns _True_ on success. Requires no parameters.
	//
	// POST /close
	Close(ctx context.Context) (*Result, error)
	// CloseForumTopic invokes closeForumTopic operation.
	//
	// Use this method to close an open topic in a forum supergroup chat. The bot must be an
	// administrator in the chat for this to work and must have the _can_manage_topics_ administrator
	// rights, unless it is the creator of the topic. Returns _True_ on success.
	//
	// POST /closeForumTopic
	CloseForumTopic(ctx context.Context, request *CloseForumTopic) (*Result, error)
	// CloseGeneralForumTopic invokes closeGeneralForumTopic operation.
	//
	// Use this method to close an open 'General' topic in a forum supergroup chat. The bot must be an
	// administrator in the chat for this to work and must have the _can_manage_topics_ administrator
	// rights. Returns _True_ on success.
	//
	// POST /closeGeneralForumTopic
	CloseGeneralForumTopic(ctx context.Context, request *CloseGeneralForumTopic) (*Result, error)
	// CopyMessage invokes copyMessage operation.
	//
	// Use this method to copy messages of any kind. Service messages, paid media messages, giveaway
	// messages, giveaway winners messages, and invoice messages can't be copied. A quiz
	// [poll](https://core.telegram.org/bots/api#poll) can be copied only if the value of the field
	// _correct_option_id_ is known to the bot. The method is analogous to the method
	// [forwardMessage](https://core.telegram.org/bots/api#forwardmessage), but the copied message
	// doesn't have a link to the original message. Returns the [MessageId](https://core.telegram.
	// org/bots/api#messageid) of the sent message on success.
	//
	// POST /copyMessage
	CopyMessage(ctx context.Context, request *CopyMessage) (*ResultMessageId, error)
	// CopyMessages invokes copyMessages operation.
	//
	// Use this method to copy messages of any kind. If some of the specified messages can't be found or
	// copied, they are skipped. Service messages, paid media messages, giveaway messages, giveaway
	// winners messages, and invoice messages can't be copied. A quiz [poll](https://core.telegram.
	// org/bots/api#poll) can be copied only if the value of the field _correct_option_id_ is known to
	// the bot. The method is analogous to the method [forwardMessages](https://core.telegram.
	// org/bots/api#forwardmessages), but the copied messages don't have a link to the original message.
	// Album grouping is kept for copied messages. On success, an array of [MessageId](https://core.
	// telegram.org/bots/api#messageid) of the sent messages is returned.
	//
	// POST /copyMessages
	CopyMessages(ctx context.Context, request *CopyMessages) (*ResultArrayOfMessageId, error)
	// CreateChatInviteLink invokes createChatInviteLink operation.
	//
	// Use this method to create an additional invite link for a chat. The bot must be an administrator
	// in the chat for this to work and must have the appropriate administrator rights. The link can be
	// revoked using the method [revokeChatInviteLink](https://core.telegram.
	// org/bots/api#revokechatinvitelink). Returns the new invite link as [ChatInviteLink](https://core.
	// telegram.org/bots/api#chatinvitelink) object.
	//
	// POST /createChatInviteLink
	CreateChatInviteLink(ctx context.Context, request *CreateChatInviteLink) (*ResultChatInviteLink, error)
	// CreateChatSubscriptionInviteLink invokes createChatSubscriptionInviteLink operation.
	//
	// Use this method to create a [subscription invite link](https://telegram.
	// org/blog/superchannels-star-reactions-subscriptions#star-subscriptions) for a channel chat. The
	// bot must have the _can_invite_users_ administrator rights. The link can be edited using the method
	// [editChatSubscriptionInviteLink](https://core.telegram.
	// org/bots/api#editchatsubscriptioninvitelink) or revoked using the method
	// [revokeChatInviteLink](https://core.telegram.org/bots/api#revokechatinvitelink). Returns the new
	// invite link as a [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object.
	//
	// POST /createChatSubscriptionInviteLink
	CreateChatSubscriptionInviteLink(ctx context.Context, request *CreateChatSubscriptionInviteLink) (*ResultChatInviteLink, error)
	// CreateForumTopic invokes createForumTopic operation.
	//
	// Use this method to create a topic in a forum supergroup chat. The bot must be an administrator in
	// the chat for this to work and must have the _can_manage_topics_ administrator rights. Returns
	// information about the created topic as a [ForumTopic](https://core.telegram.
	// org/bots/api#forumtopic) object.
	//
	// POST /createForumTopic
	CreateForumTopic(ctx context.Context, request *CreateForumTopic) (*Result, error)
	// CreateInvoiceLink invokes createInvoiceLink operation.
	//
	// Use this method to create a link for an invoice. Returns the created invoice link as _String_ on
	// success.
	//
	// POST /createInvoiceLink
	CreateInvoiceLink(ctx context.Context, request *CreateInvoiceLink) (*ResultString, error)
	// CreateNewStickerSet invokes createNewStickerSet operation.
	//
	// Use this method to create a new sticker set owned by a user. The bot will be able to edit the
	// sticker set thus created. Returns _True_ on success.
	//
	// POST /createNewStickerSet
	CreateNewStickerSet(ctx context.Context, request *CreateNewStickerSet) (*Result, error)
	// DeclineChatJoinRequest invokes declineChatJoinRequest operation.
	//
	// Use this method to decline a chat join request. The bot must be an administrator in the chat for
	// this to work and must have the _can_invite_users_ administrator right. Returns _True_ on success.
	//
	// POST /declineChatJoinRequest
	DeclineChatJoinRequest(ctx context.Context, request *DeclineChatJoinRequest) (*Result, error)
	// DeleteChatPhoto invokes deleteChatPhoto operation.
	//
	// Use this method to delete a chat photo. Photos can't be changed for private chats. The bot must be
	// an administrator in the chat for this to work and must have the appropriate administrator rights.
	// Returns _True_ on success.
	//
	// POST /deleteChatPhoto
	DeleteChatPhoto(ctx context.Context, request *DeleteChatPhoto) (*Result, error)
	// DeleteChatStickerSet invokes deleteChatStickerSet operation.
	//
	// Use this method to delete a group sticker set from a supergroup. The bot must be an administrator
	// in the chat for this to work and must have the appropriate administrator rights. Use the field
	// _can_set_sticker_set_ optionally returned in [getChat](https://core.telegram.org/bots/api#getchat)
	// requests to check if the bot can use this method. Returns _True_ on success.
	//
	// POST /deleteChatStickerSet
	DeleteChatStickerSet(ctx context.Context, request *DeleteChatStickerSet) (*Result, error)
	// DeleteForumTopic invokes deleteForumTopic operation.
	//
	// Use this method to delete a forum topic along with all its messages in a forum supergroup chat.
	// The bot must be an administrator in the chat for this to work and must have the
	// _can_delete_messages_ administrator rights. Returns _True_ on success.
	//
	// POST /deleteForumTopic
	DeleteForumTopic(ctx context.Context, request *DeleteForumTopic) (*Result, error)
	// DeleteMessage invokes deleteMessage operation.
	//
	// Use this method to delete a message, including service messages, with the following limitations:-
	// A message can only be deleted if it was sent less than 48 hours ago.- Service messages about a
	// supergroup, channel, or forum topic creation can't be deleted.- A dice message in a private chat
	// can only be deleted if it was sent more than 24 hours ago.- Bots can delete outgoing messages in
	// private chats, groups, and supergroups.- Bots can delete incoming messages in private chats.- Bots
	// granted _can_post_messages_ permissions can delete outgoing messages in channels.- If the bot is
	// an administrator of a group, it can delete any message there.- If the bot has
	// _can_delete_messages_ permission in a supergroup or a channel, it can delete any message there.
	// Returns _True_ on success.
	//
	// POST /deleteMessage
	DeleteMessage(ctx context.Context, request *DeleteMessage) (*Result, error)
	// DeleteMessages invokes deleteMessages operation.
	//
	// Use this method to delete multiple messages simultaneously. If some of the specified messages
	// can't be found, they are skipped. Returns _True_ on success.
	//
	// POST /deleteMessages
	DeleteMessages(ctx context.Context, request *DeleteMessages) (*Result, error)
	// DeleteMyCommands invokes deleteMyCommands operation.
	//
	// Use this method to delete the list of the bot's commands for the given scope and user language.
	// After deletion, [higher level commands](https://core.telegram.
	// org/bots/api#determining-list-of-commands) will be shown to affected users. Returns _True_ on
	// success.
	//
	// POST /deleteMyCommands
	DeleteMyCommands(ctx context.Context, request OptDeleteMyCommands) (*Result, error)
	// DeleteStickerFromSet invokes deleteStickerFromSet operation.
	//
	// Use this method to delete a sticker from a set created by the bot. Returns _True_ on success.
	//
	// POST /deleteStickerFromSet
	DeleteStickerFromSet(ctx context.Context, request *DeleteStickerFromSet) (*Result, error)
	// DeleteStickerSet invokes deleteStickerSet operation.
	//
	// Use this method to delete a sticker set that was created by the bot. Returns _True_ on success.
	//
	// POST /deleteStickerSet
	DeleteStickerSet(ctx context.Context, request *DeleteStickerSet) (*Result, error)
	// DeleteWebhook invokes deleteWebhook operation.
	//
	// Use this method to remove webhook integration if you decide to switch back to
	// [getUpdates](https://core.telegram.org/bots/api#getupdates). Returns _True_ on success.
	//
	// POST /deleteWebhook
	DeleteWebhook(ctx context.Context, request OptDeleteWebhook) (*Result, error)
	// EditChatInviteLink invokes editChatInviteLink operation.
	//
	// Use this method to edit a non-primary invite link created by the bot. The bot must be an
	// administrator in the chat for this to work and must have the appropriate administrator rights.
	// Returns the edited invite link as a [ChatInviteLink](https://core.telegram.
	// org/bots/api#chatinvitelink) object.
	//
	// POST /editChatInviteLink
	EditChatInviteLink(ctx context.Context, request *EditChatInviteLink) (*ResultChatInviteLink, error)
	// EditChatSubscriptionInviteLink invokes editChatSubscriptionInviteLink operation.
	//
	// Use this method to edit a subscription invite link created by the bot. The bot must have the
	// _can_invite_users_ administrator rights. Returns the edited invite link as a
	// [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object.
	//
	// POST /editChatSubscriptionInviteLink
	EditChatSubscriptionInviteLink(ctx context.Context, request *EditChatSubscriptionInviteLink) (*ResultChatInviteLink, error)
	// EditForumTopic invokes editForumTopic operation.
	//
	// Use this method to edit name and icon of a topic in a forum supergroup chat. The bot must be an
	// administrator in the chat for this to work and must have the _can_manage_topics_ administrator
	// rights, unless it is the creator of the topic. Returns _True_ on success.
	//
	// POST /editForumTopic
	EditForumTopic(ctx context.Context, request *EditForumTopic) (*Result, error)
	// EditGeneralForumTopic invokes editGeneralForumTopic operation.
	//
	// Use this method to edit the name of the 'General' topic in a forum supergroup chat. The bot must
	// be an administrator in the chat for this to work and must have the _can_manage_topics_
	// administrator rights. Returns _True_ on success.
	//
	// POST /editGeneralForumTopic
	EditGeneralForumTopic(ctx context.Context, request *EditGeneralForumTopic) (*Result, error)
	// EditMessageCaption invokes editMessageCaption operation.
	//
	// Use this method to edit captions of messages. On success, if the edited message is not an inline
	// message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise
	// _True_ is returned. Note that business messages that were not sent by the bot and do not contain
	// an inline keyboard can only be edited within **48 hours** from the time they were sent.
	//
	// POST /editMessageCaption
	EditMessageCaption(ctx context.Context, request *EditMessageCaption) (*ResultMessageOrBoolean, error)
	// EditMessageLiveLocation invokes editMessageLiveLocation operation.
	//
	// Use this method to edit live location messages. A location can be edited until its _live_period_
	// expires or editing is explicitly disabled by a call to [stopMessageLiveLocation](https://core.
	// telegram.org/bots/api#stopmessagelivelocation). On success, if the edited message is not an inline
	// message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise
	// _True_ is returned.
	//
	// POST /editMessageLiveLocation
	EditMessageLiveLocation(ctx context.Context, request *EditMessageLiveLocation) (*ResultMessageOrBoolean, error)
	// EditMessageMedia invokes editMessageMedia operation.
	//
	// Use this method to edit animation, audio, document, photo, or video messages, or to add media to
	// text messages. If a message is part of a message album, then it can be edited only to an audio for
	// audio albums, only to a document for document albums and to a photo or a video otherwise. When an
	// inline message is edited, a new file can't be uploaded; use a previously uploaded file via its
	// file_id or specify a URL. On success, if the edited message is not an inline message, the edited
	// [Message](https://core.telegram.org/bots/api#message) is returned, otherwise _True_ is returned.
	// Note that business messages that were not sent by the bot and do not contain an inline keyboard
	// can only be edited within **48 hours** from the time they were sent.
	//
	// POST /editMessageMedia
	EditMessageMedia(ctx context.Context, request *EditMessageMedia) (*ResultMessageOrBoolean, error)
	// EditMessageReplyMarkup invokes editMessageReplyMarkup operation.
	//
	// Use this method to edit only the reply markup of messages. On success, if the edited message is
	// not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is
	// returned, otherwise _True_ is returned. Note that business messages that were not sent by the bot
	// and do not contain an inline keyboard can only be edited within **48 hours** from the time they
	// were sent.
	//
	// POST /editMessageReplyMarkup
	EditMessageReplyMarkup(ctx context.Context, request *EditMessageReplyMarkup) (*ResultMessageOrBoolean, error)
	// EditMessageText invokes editMessageText operation.
	//
	// Use this method to edit text and [game](https://core.telegram.org/bots/api#games) messages. On
	// success, if the edited message is not an inline message, the edited [Message](https://core.
	// telegram.org/bots/api#message) is returned, otherwise _True_ is returned. Note that business
	// messages that were not sent by the bot and do not contain an inline keyboard can only be edited
	// within **48 hours** from the time they were sent.
	//
	// POST /editMessageText
	EditMessageText(ctx context.Context, request *EditMessageText) (*ResultMessageOrBoolean, error)
	// EditUserStarSubscription invokes editUserStarSubscription operation.
	//
	// Allows the bot to cancel or re-enable extension of a subscription paid in Telegram Stars. Returns
	// _True_ on success.
	//
	// POST /editUserStarSubscription
	EditUserStarSubscription(ctx context.Context, request *EditUserStarSubscription) (*Result, error)
	// ExportChatInviteLink invokes exportChatInviteLink operation.
	//
	// Use this method to generate a new primary invite link for a chat; any previously generated primary
	// link is revoked. The bot must be an administrator in the chat for this to work and must have the
	// appropriate administrator rights. Returns the new invite link as _String_ on success.
	//
	// POST /exportChatInviteLink
	ExportChatInviteLink(ctx context.Context, request *ExportChatInviteLink) (*ResultString, error)
	// ForwardMessage invokes forwardMessage operation.
	//
	// Use this method to forward messages of any kind. Service messages and messages with protected
	// content can't be forwarded. On success, the sent [Message](https://core.telegram.
	// org/bots/api#message) is returned.
	//
	// POST /forwardMessage
	ForwardMessage(ctx context.Context, request *ForwardMessage) (*ResultMessage, error)
	// ForwardMessages invokes forwardMessages operation.
	//
	// Use this method to forward multiple messages of any kind. If some of the specified messages can't
	// be found or forwarded, they are skipped. Service messages and messages with protected content
	// can't be forwarded. Album grouping is kept for forwarded messages. On success, an array of
	// [MessageId](https://core.telegram.org/bots/api#messageid) of the sent messages is returned.
	//
	// POST /forwardMessages
	ForwardMessages(ctx context.Context, request *ForwardMessages) (*ResultArrayOfMessageId, error)
	// GetAvailableGifts invokes getAvailableGifts operation.
	//
	// Returns the list of gifts that can be sent by the bot to users. Requires no parameters. Returns a
	// [Gifts](https://core.telegram.org/bots/api#gifts) object.
	//
	// POST /getAvailableGifts
	GetAvailableGifts(ctx context.Context) (*Result, error)
	// GetBusinessConnection invokes getBusinessConnection operation.
	//
	// Use this method to get information about the connection of the bot with a business account.
	// Returns a [BusinessConnection](https://core.telegram.org/bots/api#businessconnection) object on
	// success.
	//
	// POST /getBusinessConnection
	GetBusinessConnection(ctx context.Context, request *GetBusinessConnection) (*Result, error)
	// GetChat invokes getChat operation.
	//
	// Use this method to get up-to-date information about the chat. Returns a
	// [ChatFullInfo](https://core.telegram.org/bots/api#chatfullinfo) object on success.
	//
	// POST /getChat
	GetChat(ctx context.Context, request *GetChat) (*Result, error)
	// GetChatAdministrators invokes getChatAdministrators operation.
	//
	// Use this method to get a list of administrators in a chat, which aren't bots. Returns an Array of
	// [ChatMember](https://core.telegram.org/bots/api#chatmember) objects.
	//
	// POST /getChatAdministrators
	GetChatAdministrators(ctx context.Context, request *GetChatAdministrators) (*ResultArrayOfChatMember, error)
	// GetChatMember invokes getChatMember operation.
	//
	// Use this method to get information about a member of a chat. The method is only guaranteed to work
	// for other users if the bot is an administrator in the chat. Returns a [ChatMember](https://core.
	// telegram.org/bots/api#chatmember) object on success.
	//
	// POST /getChatMember
	GetChatMember(ctx context.Context, request *GetChatMember) (*ResultChatMember, error)
	// GetChatMemberCount invokes getChatMemberCount operation.
	//
	// Use this method to get the number of members in a chat. Returns _Int_ on success.
	//
	// POST /getChatMemberCount
	GetChatMemberCount(ctx context.Context, request *GetChatMemberCount) (*ResultInt, error)
	// GetChatMenuButton invokes getChatMenuButton operation.
	//
	// Use this method to get the current value of the bot's menu button in a private chat, or the
	// default menu button. Returns [MenuButton](https://core.telegram.org/bots/api#menubutton) on
	// success.
	//
	// POST /getChatMenuButton
	GetChatMenuButton(ctx context.Context, request OptGetChatMenuButton) (*Result, error)
	// GetCustomEmojiStickers invokes getCustomEmojiStickers operation.
	//
	// Use this method to get information about custom emoji stickers by their identifiers. Returns an
	// Array of [Sticker](https://core.telegram.org/bots/api#sticker) objects.
	//
	// POST /getCustomEmojiStickers
	GetCustomEmojiStickers(ctx context.Context, request *GetCustomEmojiStickers) (*ResultArrayOfSticker, error)
	// GetFile invokes getFile operation.
	//
	// Use this method to get basic information about a file and prepare it for downloading. For the
	// moment, bots can download files of up to 20MB in size. On success, a [File](https://core.telegram.
	// org/bots/api#file) object is returned. The file can then be downloaded via the link `https://api.
	// telegram.org/file/bot<token>/<file_path>`, where `<file_path>` is taken from the response. It is
	// guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can
	// be requested by calling [getFile](https://core.telegram.org/bots/api#getfile) again.
	//
	// POST /getFile
	GetFile(ctx context.Context, request *GetFile) (*ResultFile, error)
	// GetForumTopicIconStickers invokes getForumTopicIconStickers operation.
	//
	// Use this method to get custom emoji stickers, which can be used as a forum topic icon by any user.
	// Requires no parameters. Returns an Array of [Sticker](https://core.telegram.org/bots/api#sticker)
	// objects.
	//
	// POST /getForumTopicIconStickers
	GetForumTopicIconStickers(ctx context.Context) (*ResultArrayOfSticker, error)
	// GetGameHighScores invokes getGameHighScores operation.
	//
	// Use this method to get data for high score tables. Will return the score of the specified user and
	// several of their neighbors in a game. Returns an Array of [GameHighScore](https://core.telegram.
	// org/bots/api#gamehighscore) objects.
	//
	// POST /getGameHighScores
	GetGameHighScores(ctx context.Context, request *GetGameHighScores) (*ResultArrayOfGameHighScore, error)
	// GetMe invokes getMe operation.
	//
	// A simple method for testing your bot's authentication token. Requires no parameters. Returns basic
	// information about the bot in form of a [User](https://core.telegram.org/bots/api#user) object.
	//
	// POST /getMe
	GetMe(ctx context.Context) (*ResultUser, error)
	// GetMyCommands invokes getMyCommands operation.
	//
	// Use this method to get the current list of the bot's commands for the given scope and user
	// language. Returns an Array of [BotCommand](https://core.telegram.org/bots/api#botcommand) objects.
	// If commands aren't set, an empty list is returned.
	//
	// POST /getMyCommands
	GetMyCommands(ctx context.Context, request OptGetMyCommands) (*ResultArrayOfBotCommand, error)
	// GetMyDefaultAdministratorRights invokes getMyDefaultAdministratorRights operation.
	//
	// Use this method to get the current default administrator rights of the bot. Returns
	// [ChatAdministratorRights](https://core.telegram.org/bots/api#chatadministratorrights) on success.
	//
	// POST /getMyDefaultAdministratorRights
	GetMyDefaultAdministratorRights(ctx context.Context, request OptGetMyDefaultAdministratorRights) (*Result, error)
	// GetMyDescription invokes getMyDescription operation.
	//
	// Use this method to get the current bot description for the given user language. Returns
	// [BotDescription](https://core.telegram.org/bots/api#botdescription) on success.
	//
	// POST /getMyDescription
	GetMyDescription(ctx context.Context, request OptGetMyDescription) (*Result, error)
	// GetMyName invokes getMyName operation.
	//
	// Use this method to get the current bot name for the given user language. Returns
	// [BotName](https://core.telegram.org/bots/api#botname) on success.
	//
	// POST /getMyName
	GetMyName(ctx context.Context, request OptGetMyName) (*Result, error)
	// GetMyShortDescription invokes getMyShortDescription operation.
	//
	// Use this method to get the current bot short description for the given user language. Returns
	// [BotShortDescription](https://core.telegram.org/bots/api#botshortdescription) on success.
	//
	// POST /getMyShortDescription
	GetMyShortDescription(ctx context.Context, request OptGetMyShortDescription) (*Result, error)
	// GetStarTransactions invokes getStarTransactions operation.
	//
	// Returns the bot's Telegram Star transactions in chronological order. On success, returns a
	// [StarTransactions](https://core.telegram.org/bots/api#startransactions) object.
	//
	// POST /getStarTransactions
	GetStarTransactions(ctx context.Context, request OptGetStarTransactions) (*Result, error)
	// GetStickerSet invokes getStickerSet operation.
	//
	// Use this method to get a sticker set. On success, a [StickerSet](https://core.telegram.
	// org/bots/api#stickerset) object is returned.
	//
	// POST /getStickerSet
	GetStickerSet(ctx context.Context, request *GetStickerSet) (*ResultStickerSet, error)
	// GetUpdates invokes getUpdates operation.
	//
	// Use this method to receive incoming updates using long polling ([wiki](https://en.wikipedia.
	// org/wiki/Push_technology#Long_polling)). Returns an Array of [Update](https://core.telegram.
	// org/bots/api#update) objects.
	//
	// POST /getUpdates
	GetUpdates(ctx context.Context, request OptGetUpdates) (*ResultArrayOfUpdate, error)
	// GetUserChatBoosts invokes getUserChatBoosts operation.
	//
	// Use this method to get the list of boosts added to a chat by a user. Requires administrator rights
	// in the chat. Returns a [UserChatBoosts](https://core.telegram.org/bots/api#userchatboosts) object.
	//
	// POST /getUserChatBoosts
	GetUserChatBoosts(ctx context.Context, request *GetUserChatBoosts) (*Result, error)
	// GetUserProfilePhotos invokes getUserProfilePhotos operation.
	//
	// Use this method to get a list of profile pictures for a user. Returns a
	// [UserProfilePhotos](https://core.telegram.org/bots/api#userprofilephotos) object.
	//
	// POST /getUserProfilePhotos
	GetUserProfilePhotos(ctx context.Context, request *GetUserProfilePhotos) (*ResultUserProfilePhotos, error)
	// GetWebhookInfo invokes getWebhookInfo operation.
	//
	// Use this method to get current webhook status. Requires no parameters. On success, returns a
	// [WebhookInfo](https://core.telegram.org/bots/api#webhookinfo) object. If the bot is using
	// [getUpdates](https://core.telegram.org/bots/api#getupdates), will return an object with the _url_
	// field empty.
	//
	// POST /getWebhookInfo
	GetWebhookInfo(ctx context.Context) (*ResultWebhookInfo, error)
	// HideGeneralForumTopic invokes hideGeneralForumTopic operation.
	//
	// Use this method to hide the 'General' topic in a forum supergroup chat. The bot must be an
	// administrator in the chat for this to work and must have the _can_manage_topics_ administrator
	// rights. The topic will be automatically closed if it was open. Returns _True_ on success.
	//
	// POST /hideGeneralForumTopic
	HideGeneralForumTopic(ctx context.Context, request *HideGeneralForumTopic) (*Result, error)
	// LeaveChat invokes leaveChat operation.
	//
	// Use this method for your bot to leave a group, supergroup or channel. Returns _True_ on success.
	//
	// POST /leaveChat
	LeaveChat(ctx context.Context, request *LeaveChat) (*Result, error)
	// LogOut invokes logOut operation.
	//
	// Use this method to log out from the cloud Bot API server before launching the bot locally. You
	// **must** log out the bot before running it locally, otherwise there is no guarantee that the bot
	// will receive updates. After a successful call, you can immediately log in on a local server, but
	// will not be able to log in back to the cloud Bot API server for 10 minutes. Returns _True_ on
	// success. Requires no parameters.
	//
	// POST /logOut
	LogOut(ctx context.Context) (*Result, error)
	// PinChatMessage invokes pinChatMessage operation.
	//
	// Use this method to add a message to the list of pinned messages in a chat. If the chat is not a
	// private chat, the bot must be an administrator in the chat for this to work and must have the
	// 'can_pin_messages' administrator right in a supergroup or 'can_edit_messages' administrator right
	// in a channel. Returns _True_ on success.
	//
	// POST /pinChatMessage
	PinChatMessage(ctx context.Context, request *PinChatMessage) (*Result, error)
	// PromoteChatMember invokes promoteChatMember operation.
	//
	// Use this method to promote or demote a user in a supergroup or a channel. The bot must be an
	// administrator in the chat for this to work and must have the appropriate administrator rights.
	// Pass _False_ for all boolean parameters to demote a user. Returns _True_ on success.
	//
	// POST /promoteChatMember
	PromoteChatMember(ctx context.Context, request *PromoteChatMember) (*Result, error)
	// RefundStarPayment invokes refundStarPayment operation.
	//
	// Refunds a successful payment in [Telegram Stars](https://t.me/BotNews/90). Returns _True_ on
	// success.
	//
	// POST /refundStarPayment
	RefundStarPayment(ctx context.Context, request *RefundStarPayment) (*Result, error)
	// RemoveChatVerification invokes removeChatVerification operation.
	//
	// Removes verification from a chat that is currently verified [on behalf of the
	// organization](https://telegram.org/verify#third-party-verification) represented by the bot.
	// Returns _True_ on success.
	//
	// POST /removeChatVerification
	RemoveChatVerification(ctx context.Context, request *RemoveChatVerification) (*Result, error)
	// RemoveUserVerification invokes removeUserVerification operation.
	//
	// Removes verification from a user who is currently verified [on behalf of the
	// organization](https://telegram.org/verify#third-party-verification) represented by the bot.
	// Returns _True_ on success.
	//
	// POST /removeUserVerification
	RemoveUserVerification(ctx context.Context, request *RemoveUserVerification) (*Result, error)
	// ReopenForumTopic invokes reopenForumTopic operation.
	//
	// Use this method to reopen a closed topic in a forum supergroup chat. The bot must be an
	// administrator in the chat for this to work and must have the _can_manage_topics_ administrator
	// rights, unless it is the creator of the topic. Returns _True_ on success.
	//
	// POST /reopenForumTopic
	ReopenForumTopic(ctx context.Context, request *ReopenForumTopic) (*Result, error)
	// ReopenGeneralForumTopic invokes reopenGeneralForumTopic operation.
	//
	// Use this method to reopen a closed 'General' topic in a forum supergroup chat. The bot must be an
	// administrator in the chat for this to work and must have the _can_manage_topics_ administrator
	// rights. The topic will be automatically unhidden if it was hidden. Returns _True_ on success.
	//
	// POST /reopenGeneralForumTopic
	ReopenGeneralForumTopic(ctx context.Context, request *ReopenGeneralForumTopic) (*Result, error)
	// ReplaceStickerInSet invokes replaceStickerInSet operation.
	//
	// Use this method to replace an existing sticker in a sticker set with a new one. The method is
	// equivalent to calling [deleteStickerFromSet](https://core.telegram.
	// org/bots/api#deletestickerfromset), then [addStickerToSet](https://core.telegram.
	// org/bots/api#addstickertoset), then [setStickerPositionInSet](https://core.telegram.
	// org/bots/api#setstickerpositioninset). Returns _True_ on success.
	//
	// POST /replaceStickerInSet
	ReplaceStickerInSet(ctx context.Context, request *ReplaceStickerInSet) (*Result, error)
	// RestrictChatMember invokes restrictChatMember operation.
	//
	// Use this method to restrict a user in a supergroup. The bot must be an administrator in the
	// supergroup for this to work and must have the appropriate administrator rights. Pass _True_ for
	// all permissions to lift restrictions from a user. Returns _True_ on success.
	//
	// POST /restrictChatMember
	RestrictChatMember(ctx context.Context, request *RestrictChatMember) (*Result, error)
	// RevokeChatInviteLink invokes revokeChatInviteLink operation.
	//
	// Use this method to revoke an invite link created by the bot. If the primary link is revoked, a new
	// link is automatically generated. The bot must be an administrator in the chat for this to work and
	// must have the appropriate administrator rights. Returns the revoked invite link as
	// [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object.
	//
	// POST /revokeChatInviteLink
	RevokeChatInviteLink(ctx context.Context, request *RevokeChatInviteLink) (*ResultChatInviteLink, error)
	// SavePreparedInlineMessage invokes savePreparedInlineMessage operation.
	//
	// Stores a message that can be sent by a user of a Mini App. Returns a
	// [PreparedInlineMessage](https://core.telegram.org/bots/api#preparedinlinemessage) object.
	//
	// POST /savePreparedInlineMessage
	SavePreparedInlineMessage(ctx context.Context, request *SavePreparedInlineMessage) (*Result, error)
	// SendAnimation invokes sendAnimation operation.
	//
	// Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On success,
	// the sent [Message](https://core.telegram.org/bots/api#message) is returned. Bots can currently
	// send animation files of up to 50 MB in size, this limit may be changed in the future.
	//
	// POST /sendAnimation
	SendAnimation(ctx context.Context, request *SendAnimation) (*ResultMessage, error)
	// SendAudio invokes sendAudio operation.
	//
	// For sending voice messages, use the [sendVoice](https://core.telegram.org/bots/api#sendvoice)
	// method instead.
	//
	// POST /sendAudio
	SendAudio(ctx context.Context, request *SendAudio) (*ResultMessage, error)
	// SendChatAction invokes sendChatAction operation.
	//
	// We only recommend using this method when a response from the bot will take a **noticeable** amount
	// of time to arrive.
	//
	// POST /sendChatAction
	SendChatAction(ctx context.Context, request *SendChatAction) (*Result, error)
	// SendContact invokes sendContact operation.
	//
	// Use this method to send phone contacts. On success, the sent [Message](https://core.telegram.
	// org/bots/api#message) is returned.
	//
	// POST /sendContact
	SendContact(ctx context.Context, request *SendContact) (*ResultMessage, error)
	// SendDice invokes sendDice operation.
	//
	// Use this method to send an animated emoji that will display a random value. On success, the sent
	// [Message](https://core.telegram.org/bots/api#message) is returned.
	//
	// POST /sendDice
	SendDice(ctx context.Context, request *SendDice) (*ResultMessage, error)
	// SendDocument invokes sendDocument operation.
	//
	// Use this method to send general files. On success, the sent [Message](https://core.telegram.
	// org/bots/api#message) is returned. Bots can currently send files of any type of up to 50 MB in
	// size, this limit may be changed in the future.
	//
	// POST /sendDocument
	SendDocument(ctx context.Context, request *SendDocument) (*ResultMessage, error)
	// SendGame invokes sendGame operation.
	//
	// Use this method to send a game. On success, the sent [Message](https://core.telegram.
	// org/bots/api#message) is returned.
	//
	// POST /sendGame
	SendGame(ctx context.Context, request *SendGame) (*ResultMessage, error)
	// SendGift invokes sendGift operation.
	//
	// Sends a gift to the given user. The gift can't be converted to Telegram Stars by the user. Returns
	// _True_ on success.
	//
	// POST /sendGift
	SendGift(ctx context.Context, request *SendGift) (*Result, error)
	// SendInvoice invokes sendInvoice operation.
	//
	// Use this method to send invoices. On success, the sent [Message](https://core.telegram.
	// org/bots/api#message) is returned.
	//
	// POST /sendInvoice
	SendInvoice(ctx context.Context, request *SendInvoice) (*ResultMessage, error)
	// SendLocation invokes sendLocation operation.
	//
	// Use this method to send point on the map. On success, the sent [Message](https://core.telegram.
	// org/bots/api#message) is returned.
	//
	// POST /sendLocation
	SendLocation(ctx context.Context, request *SendLocation) (*ResultMessage, error)
	// SendMediaGroup invokes sendMediaGroup operation.
	//
	// Use this method to send a group of photos, videos, documents or audios as an album. Documents and
	// audio files can be only grouped in an album with messages of the same type. On success, an array
	// of [Messages](https://core.telegram.org/bots/api#message) that were sent is returned.
	//
	// POST /sendMediaGroup
	SendMediaGroup(ctx context.Context, request *SendMediaGroup) (*ResultArrayOfMessage, error)
	// SendMessage invokes sendMessage operation.
	//
	// Use this method to send text messages. On success, the sent [Message](https://core.telegram.
	// org/bots/api#message) is returned.
	//
	// POST /sendMessage
	SendMessage(ctx context.Context, request *SendMessage) (*ResultMessage, error)
	// SendPaidMedia invokes sendPaidMedia operation.
	//
	// Use this method to send paid media. On success, the sent [Message](https://core.telegram.
	// org/bots/api#message) is returned.
	//
	// POST /sendPaidMedia
	SendPaidMedia(ctx context.Context, request *SendPaidMedia) (*ResultMessage, error)
	// SendPhoto invokes sendPhoto operation.
	//
	// Use this method to send photos. On success, the sent [Message](https://core.telegram.
	// org/bots/api#message) is returned.
	//
	// POST /sendPhoto
	SendPhoto(ctx context.Context, request *SendPhoto) (*ResultMessage, error)
	// SendPoll invokes sendPoll operation.
	//
	// Use this method to send a native poll. On success, the sent [Message](https://core.telegram.
	// org/bots/api#message) is returned.
	//
	// POST /sendPoll
	SendPoll(ctx context.Context, request *SendPoll) (*ResultMessage, error)
	// SendSticker invokes sendSticker operation.
	//
	// Use this method to send static .WEBP, [animated](https://telegram.org/blog/animated-stickers) .TGS,
	//  or [video](https://telegram.org/blog/video-stickers-better-reactions) .WEBM stickers. On success,
	// the sent [Message](https://core.telegram.org/bots/api#message) is returned.
	//
	// POST /sendSticker
	SendSticker(ctx context.Context, request *SendSticker) (*ResultMessage, error)
	// SendVenue invokes sendVenue operation.
	//
	// Use this method to send information about a venue. On success, the sent [Message](https://core.
	// telegram.org/bots/api#message) is returned.
	//
	// POST /sendVenue
	SendVenue(ctx context.Context, request *SendVenue) (*ResultMessage, error)
	// SendVideo invokes sendVideo operation.
	//
	// Use this method to send video files, Telegram clients support MPEG4 videos (other formats may be
	// sent as [Document](https://core.telegram.org/bots/api#document)). On success, the sent
	// [Message](https://core.telegram.org/bots/api#message) is returned. Bots can currently send video
	// files of up to 50 MB in size, this limit may be changed in the future.
	//
	// POST /sendVideo
	SendVideo(ctx context.Context, request *SendVideo) (*ResultMessage, error)
	// SendVideoNote invokes sendVideoNote operation.
	//
	// As of [v.4.0](https://telegram.org/blog/video-messages-and-telescope), Telegram clients support
	// rounded square MPEG4 videos of up to 1 minute long. Use this method to send video messages. On
	// success, the sent [Message](https://core.telegram.org/bots/api#message) is returned.
	//
	// POST /sendVideoNote
	SendVideoNote(ctx context.Context, request *SendVideoNote) (*ResultMessage, error)
	// SendVoice invokes sendVoice operation.
	//
	// Use this method to send audio files, if you want Telegram clients to display the file as a
	// playable voice message. For this to work, your audio must be in an .OGG file encoded with OPUS, or
	// in .MP3 format, or in .M4A format (other formats may be sent as [Audio](https://core.telegram.
	// org/bots/api#audio) or [Document](https://core.telegram.org/bots/api#document)). On success, the
	// sent [Message](https://core.telegram.org/bots/api#message) is returned. Bots can currently send
	// voice messages of up to 50 MB in size, this limit may be changed in the future.
	//
	// POST /sendVoice
	SendVoice(ctx context.Context, request *SendVoice) (*ResultMessage, error)
	// SetChatAdministratorCustomTitle invokes setChatAdministratorCustomTitle operation.
	//
	// Use this method to set a custom title for an administrator in a supergroup promoted by the bot.
	// Returns _True_ on success.
	//
	// POST /setChatAdministratorCustomTitle
	SetChatAdministratorCustomTitle(ctx context.Context, request *SetChatAdministratorCustomTitle) (*Result, error)
	// SetChatDescription invokes setChatDescription operation.
	//
	// Use this method to change the description of a group, a supergroup or a channel. The bot must be
	// an administrator in the chat for this to work and must have the appropriate administrator rights.
	// Returns _True_ on success.
	//
	// POST /setChatDescription
	SetChatDescription(ctx context.Context, request *SetChatDescription) (*Result, error)
	// SetChatMenuButton invokes setChatMenuButton operation.
	//
	// Use this method to change the bot's menu button in a private chat, or the default menu button.
	// Returns _True_ on success.
	//
	// POST /setChatMenuButton
	SetChatMenuButton(ctx context.Context, request OptSetChatMenuButton) (*Result, error)
	// SetChatPermissions invokes setChatPermissions operation.
	//
	// Use this method to set default chat permissions for all members. The bot must be an administrator
	// in the group or a supergroup for this to work and must have the _can_restrict_members_
	// administrator rights. Returns _True_ on success.
	//
	// POST /setChatPermissions
	SetChatPermissions(ctx context.Context, request *SetChatPermissions) (*Result, error)
	// SetChatPhoto invokes setChatPhoto operation.
	//
	// Use this method to set a new profile photo for the chat. Photos can't be changed for private chats.
	//  The bot must be an administrator in the chat for this to work and must have the appropriate
	// administrator rights. Returns _True_ on success.
	//
	// POST /setChatPhoto
	SetChatPhoto(ctx context.Context, request *SetChatPhoto) (*Result, error)
	// SetChatStickerSet invokes setChatStickerSet operation.
	//
	// Use this method to set a new group sticker set for a supergroup. The bot must be an administrator
	// in the chat for this to work and must have the appropriate administrator rights. Use the field
	// _can_set_sticker_set_ optionally returned in [getChat](https://core.telegram.org/bots/api#getchat)
	// requests to check if the bot can use this method. Returns _True_ on success.
	//
	// POST /setChatStickerSet
	SetChatStickerSet(ctx context.Context, request *SetChatStickerSet) (*Result, error)
	// SetChatTitle invokes setChatTitle operation.
	//
	// Use this method to change the title of a chat. Titles can't be changed for private chats. The bot
	// must be an administrator in the chat for this to work and must have the appropriate administrator
	// rights. Returns _True_ on success.
	//
	// POST /setChatTitle
	SetChatTitle(ctx context.Context, request *SetChatTitle) (*Result, error)
	// SetCustomEmojiStickerSetThumbnail invokes setCustomEmojiStickerSetThumbnail operation.
	//
	// Use this method to set the thumbnail of a custom emoji sticker set. Returns _True_ on success.
	//
	// POST /setCustomEmojiStickerSetThumbnail
	SetCustomEmojiStickerSetThumbnail(ctx context.Context, request *SetCustomEmojiStickerSetThumbnail) (*Result, error)
	// SetGameScore invokes setGameScore operation.
	//
	// Use this method to set the score of the specified user in a game message. On success, if the
	// message is not an inline message, the [Message](https://core.telegram.org/bots/api#message) is
	// returned, otherwise _True_ is returned. Returns an error, if the new score is not greater than the
	// user's current score in the chat and _force_ is _False_.
	//
	// POST /setGameScore
	SetGameScore(ctx context.Context, request *SetGameScore) (*Result, error)
	// SetMessageReaction invokes setMessageReaction operation.
	//
	// Use this method to change the chosen reactions on a message. Service messages can't be reacted to.
	// Automatically forwarded messages from a channel to its discussion group have the same available
	// reactions as messages in the channel. Bots can't use paid reactions. Returns _True_ on success.
	//
	// POST /setMessageReaction
	SetMessageReaction(ctx context.Context, request *SetMessageReaction) (*Result, error)
	// SetMyCommands invokes setMyCommands operation.
	//
	// Use this method to change the list of the bot's commands. See [this manual](https://core.telegram.
	// org/bots/features#commands) for more details about bot commands. Returns _True_ on success.
	//
	// POST /setMyCommands
	SetMyCommands(ctx context.Context, request *SetMyCommands) (*Result, error)
	// SetMyDefaultAdministratorRights invokes setMyDefaultAdministratorRights operation.
	//
	// Use this method to change the default administrator rights requested by the bot when it's added as
	// an administrator to groups or channels. These rights will be suggested to users, but they are free
	// to modify the list before adding the bot. Returns _True_ on success.
	//
	// POST /setMyDefaultAdministratorRights
	SetMyDefaultAdministratorRights(ctx context.Context, request OptSetMyDefaultAdministratorRights) (*Result, error)
	// SetMyDescription invokes setMyDescription operation.
	//
	// Use this method to change the bot's description, which is shown in the chat with the bot if the
	// chat is empty. Returns _True_ on success.
	//
	// POST /setMyDescription
	SetMyDescription(ctx context.Context, request OptSetMyDescription) (*Result, error)
	// SetMyName invokes setMyName operation.
	//
	// Use this method to change the bot's name. Returns _True_ on success.
	//
	// POST /setMyName
	SetMyName(ctx context.Context, request OptSetMyName) (*Result, error)
	// SetMyShortDescription invokes setMyShortDescription operation.
	//
	// Use this method to change the bot's short description, which is shown on the bot's profile page
	// and is sent together with the link when users share the bot. Returns _True_ on success.
	//
	// POST /setMyShortDescription
	SetMyShortDescription(ctx context.Context, request OptSetMyShortDescription) (*Result, error)
	// SetPassportDataErrors invokes setPassportDataErrors operation.
	//
	// Use this if the data submitted by the user doesn't satisfy the standards your service requires for
	// any reason. For example, if a birthday date seems invalid, a submitted document is blurry, a scan
	// shows evidence of tampering, etc. Supply some details in the error message to make sure the user
	// knows how to correct the issues.
	//
	// POST /setPassportDataErrors
	SetPassportDataErrors(ctx context.Context, request *SetPassportDataErrors) (*Result, error)
	// SetStickerEmojiList invokes setStickerEmojiList operation.
	//
	// Use this method to change the list of emoji assigned to a regular or custom emoji sticker. The
	// sticker must belong to a sticker set created by the bot. Returns _True_ on success.
	//
	// POST /setStickerEmojiList
	SetStickerEmojiList(ctx context.Context, request *SetStickerEmojiList) (*Result, error)
	// SetStickerKeywords invokes setStickerKeywords operation.
	//
	// Use this method to change search keywords assigned to a regular or custom emoji sticker. The
	// sticker must belong to a sticker set created by the bot. Returns _True_ on success.
	//
	// POST /setStickerKeywords
	SetStickerKeywords(ctx context.Context, request *SetStickerKeywords) (*Result, error)
	// SetStickerMaskPosition invokes setStickerMaskPosition operation.
	//
	// Use this method to change the [mask position](https://core.telegram.org/bots/api#maskposition) of
	// a mask sticker. The sticker must belong to a sticker set that was created by the bot. Returns
	// _True_ on success.
	//
	// POST /setStickerMaskPosition
	SetStickerMaskPosition(ctx context.Context, request *SetStickerMaskPosition) (*Result, error)
	// SetStickerPositionInSet invokes setStickerPositionInSet operation.
	//
	// Use this method to move a sticker in a set created by the bot to a specific position. Returns
	// _True_ on success.
	//
	// POST /setStickerPositionInSet
	SetStickerPositionInSet(ctx context.Context, request *SetStickerPositionInSet) (*Result, error)
	// SetStickerSetThumbnail invokes setStickerSetThumbnail operation.
	//
	// Use this method to set the thumbnail of a regular or mask sticker set. The format of the thumbnail
	// file must match the format of the stickers in the set. Returns _True_ on success.
	//
	// POST /setStickerSetThumbnail
	SetStickerSetThumbnail(ctx context.Context, request *SetStickerSetThumbnail) (*Result, error)
	// SetStickerSetTitle invokes setStickerSetTitle operation.
	//
	// Use this method to set the title of a created sticker set. Returns _True_ on success.
	//
	// POST /setStickerSetTitle
	SetStickerSetTitle(ctx context.Context, request *SetStickerSetTitle) (*Result, error)
	// SetUserEmojiStatus invokes setUserEmojiStatus operation.
	//
	// Changes the emoji status for a given user that previously allowed the bot to manage their emoji
	// status via the Mini App method [requestEmojiStatusAccess](https://core.telegram.
	// org/bots/webapps#initializing-mini-apps). Returns _True_ on success.
	//
	// POST /setUserEmojiStatus
	SetUserEmojiStatus(ctx context.Context, request *SetUserEmojiStatus) (*Result, error)
	// SetWebhook invokes setWebhook operation.
	//
	// If you'd like to make sure that the webhook was set by you, you can specify secret data in the
	// parameter _secret_token_. If specified, the request will contain a header
	// `X-Telegram-Bot-Api-Secret-Token` with the secret token as content.
	//
	// POST /setWebhook
	SetWebhook(ctx context.Context, request *SetWebhook) (*Result, error)
	// StopMessageLiveLocation invokes stopMessageLiveLocation operation.
	//
	// Use this method to stop updating a live location message before _live_period_ expires. On success,
	// if the message is not an inline message, the edited [Message](https://core.telegram.
	// org/bots/api#message) is returned, otherwise _True_ is returned.
	//
	// POST /stopMessageLiveLocation
	StopMessageLiveLocation(ctx context.Context, request *StopMessageLiveLocation) (*ResultMessageOrBoolean, error)
	// StopPoll invokes stopPoll operation.
	//
	// Use this method to stop a poll which was sent by the bot. On success, the stopped
	// [Poll](https://core.telegram.org/bots/api#poll) is returned.
	//
	// POST /stopPoll
	StopPoll(ctx context.Context, request *StopPoll) (*ResultPoll, error)
	// UnbanChatMember invokes unbanChatMember operation.
	//
	// Use this method to unban a previously banned user in a supergroup or channel. The user will
	// **not** return to the group or channel automatically, but will be able to join via link, etc. The
	// bot must be an administrator for this to work. By default, this method guarantees that after the
	// call the user is not a member of the chat, but will be able to join it. So if the user is a member
	// of the chat they will also be **removed** from the chat. If you don't want this, use the parameter
	// _only_if_banned_. Returns _True_ on success.
	//
	// POST /unbanChatMember
	UnbanChatMember(ctx context.Context, request *UnbanChatMember) (*Result, error)
	// UnbanChatSenderChat invokes unbanChatSenderChat operation.
	//
	// Use this method to unban a previously banned channel chat in a supergroup or channel. The bot must
	// be an administrator for this to work and must have the appropriate administrator rights. Returns
	// _True_ on success.
	//
	// POST /unbanChatSenderChat
	UnbanChatSenderChat(ctx context.Context, request *UnbanChatSenderChat) (*Result, error)
	// UnhideGeneralForumTopic invokes unhideGeneralForumTopic operation.
	//
	// Use this method to unhide the 'General' topic in a forum supergroup chat. The bot must be an
	// administrator in the chat for this to work and must have the _can_manage_topics_ administrator
	// rights. Returns _True_ on success.
	//
	// POST /unhideGeneralForumTopic
	UnhideGeneralForumTopic(ctx context.Context, request *UnhideGeneralForumTopic) (*Result, error)
	// UnpinAllChatMessages invokes unpinAllChatMessages operation.
	//
	// Use this method to clear the list of pinned messages in a chat. If the chat is not a private chat,
	// the bot must be an administrator in the chat for this to work and must have the 'can_pin_messages'
	// administrator right in a supergroup or 'can_edit_messages' administrator right in a channel.
	// Returns _True_ on success.
	//
	// POST /unpinAllChatMessages
	UnpinAllChatMessages(ctx context.Context, request *UnpinAllChatMessages) (*Result, error)
	// UnpinAllForumTopicMessages invokes unpinAllForumTopicMessages operation.
	//
	// Use this method to clear the list of pinned messages in a forum topic. The bot must be an
	// administrator in the chat for this to work and must have the _can_pin_messages_ administrator
	// right in the supergroup. Returns _True_ on success.
	//
	// POST /unpinAllForumTopicMessages
	UnpinAllForumTopicMessages(ctx context.Context, request *UnpinAllForumTopicMessages) (*Result, error)
	// UnpinAllGeneralForumTopicMessages invokes unpinAllGeneralForumTopicMessages operation.
	//
	// Use this method to clear the list of pinned messages in a General forum topic. The bot must be an
	// administrator in the chat for this to work and must have the _can_pin_messages_ administrator
	// right in the supergroup. Returns _True_ on success.
	//
	// POST /unpinAllGeneralForumTopicMessages
	UnpinAllGeneralForumTopicMessages(ctx context.Context, request *UnpinAllGeneralForumTopicMessages) (*Result, error)
	// UnpinChatMessage invokes unpinChatMessage operation.
	//
	// Use this method to remove a message from the list of pinned messages in a chat. If the chat is not
	// a private chat, the bot must be an administrator in the chat for this to work and must have the
	// 'can_pin_messages' administrator right in a supergroup or 'can_edit_messages' administrator right
	// in a channel. Returns _True_ on success.
	//
	// POST /unpinChatMessage
	UnpinChatMessage(ctx context.Context, request *UnpinChatMessage) (*Result, error)
	// UploadStickerFile invokes uploadStickerFile operation.
	//
	// Use this method to upload a file with a sticker for later use in the
	// [createNewStickerSet](https://core.telegram.org/bots/api#createnewstickerset),
	// [addStickerToSet](https://core.telegram.org/bots/api#addstickertoset), or
	// [replaceStickerInSet](https://core.telegram.org/bots/api#replacestickerinset) methods (the file
	// can be used multiple times). Returns the uploaded [File](https://core.telegram.org/bots/api#file)
	// on success.
	//
	// POST /uploadStickerFile
	UploadStickerFile(ctx context.Context, request *UploadStickerFile) (*ResultFile, error)
	// VerifyChat invokes verifyChat operation.
	//
	// Verifies a chat [on behalf of the organization](https://telegram.
	// org/verify#third-party-verification) which is represented by the bot. Returns _True_ on success.
	//
	// POST /verifyChat
	VerifyChat(ctx context.Context, request *VerifyChat) (*Result, error)
	// VerifyUser invokes verifyUser operation.
	//
	// Verifies a user [on behalf of the organization](https://telegram.
	// org/verify#third-party-verification) which is represented by the bot. Returns _True_ on success.
	//
	// POST /verifyUser
	VerifyUser(ctx context.Context, request *VerifyUser) (*Result, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}
type errorHandler interface {
	NewError(ctx context.Context, err error) *ErrorStatusCode
}

var _ Handler = struct {
	errorHandler
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AddStickerToSet invokes addStickerToSet operation.
//
// Use this method to add a new sticker to a set created by the bot. Emoji sticker sets can have up
// to 200 stickers. Other sticker sets can have up to 120 stickers. Returns _True_ on success.
//
// POST /addStickerToSet
func (c *Client) AddStickerToSet(ctx context.Context, request *AddStickerToSet) (*Result, error) {
	res, err := c.sendAddStickerToSet(ctx, request)
	return res, err
}

func (c *Client) sendAddStickerToSet(ctx context.Context, request *AddStickerToSet) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addStickerToSet"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/addStickerToSet"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddStickerToSetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/addStickerToSet"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddStickerToSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddStickerToSetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AnswerCallbackQuery invokes answerCallbackQuery operation.
//
// Use this method to send answers to callback queries sent from [inline keyboards](https://core.
// telegram.org/bots/features#inline-keyboards). The answer will be displayed to the user as a
// notification at the top of the chat screen or as an alert. On success, _True_ is returned.
//
// POST /answerCallbackQuery
func (c *Client) AnswerCallbackQuery(ctx context.Context, request *AnswerCallbackQuery) (*Result, error) {
	res, err := c.sendAnswerCallbackQuery(ctx, request)
	return res, err
}

func (c *Client) sendAnswerCallbackQuery(ctx context.Context, request *AnswerCallbackQuery) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("answerCallbackQuery"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/answerCallbackQuery"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AnswerCallbackQueryOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/answerCallbackQuery"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAnswerCallbackQueryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAnswerCallbackQueryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AnswerInlineQuery invokes answerInlineQuery operation.
//
// Use this method to send answers to an inline query. On success, _True_ is returned.No more than
// **50** results per query are allowed.
//
// POST /answerInlineQuery
func (c *Client) AnswerInlineQuery(ctx context.Context, request *AnswerInlineQuery) (*Result, error) {
	res, err := c.sendAnswerInlineQuery(ctx, request)
	return res, err
}

func (c *Client) sendAnswerInlineQuery(ctx context.Context, request *AnswerInlineQuery) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("answerInlineQuery"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/answerInlineQuery"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AnswerInlineQueryOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/answerInlineQuery"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAnswerInlineQueryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAnswerInlineQueryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AnswerPreCheckoutQuery invokes answerPreCheckoutQuery operation.
//
// Once the user has confirmed their payment and shipping details, the Bot API sends the final
// confirmation in the form of an [Update](https://core.telegram.org/bots/api#update) with the field
// _pre_checkout_query_. Use this method to respond to such pre-checkout queries. On success, _True_
// is returned. **Note:** The Bot API must receive an answer within 10 seconds after the pre-checkout
// query was sent.
//
// POST /answerPreCheckoutQuery
func (c *Client) AnswerPreCheckoutQuery(ctx context.Context, request *AnswerPreCheckoutQuery) (*Result, error) {
	res, err := c.sendAnswerPreCheckoutQuery(ctx, request)
	return res, err
}

func (c *Client) sendAnswerPreCheckoutQuery(ctx context.Context, request *AnswerPreCheckoutQuery) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("answerPreCheckoutQuery"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/answerPreCheckoutQuery"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AnswerPreCheckoutQueryOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/answerPreCheckoutQuery"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAnswerPreCheckoutQueryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAnswerPreCheckoutQueryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AnswerShippingQuery invokes answerShippingQuery operation.
//
// If you sent an invoice requesting a shipping address and the parameter _is_flexible_ was specified,
//
//	the Bot API will send an [Update](https://core.telegram.org/bots/api#update) with a
//
// _shipping_query_ field to the bot. Use this method to reply to shipping queries. On success,
// _True_ is returned.
//
// POST /answerShippingQuery
func (c *Client) AnswerShippingQuery(ctx context.Context, request *AnswerShippingQuery) (*Result, error) {
	res, err := c.sendAnswerShippingQuery(ctx, request)
	return res, err
}

func (c *Client) sendAnswerShippingQuery(ctx context.Context, request *AnswerShippingQuery) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("answerShippingQuery"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/answerShippingQuery"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AnswerShippingQueryOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/answerShippingQuery"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAnswerShippingQueryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAnswerShippingQueryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AnswerWebAppQuery invokes answerWebAppQuery operation.
//
// Use this method to set the result of an interaction with a [Web App](https://core.telegram.
// org/bots/webapps) and send a corresponding message on behalf of the user to the chat from which
// the query originated. On success, a [SentWebAppMessage](https://core.telegram.
// org/bots/api#sentwebappmessage) object is returned.
//
// POST /answerWebAppQuery
func (c *Client) AnswerWebAppQuery(ctx context.Context, request *AnswerWebAppQuery) (*Result, error) {
	res, err := c.sendAnswerWebAppQuery(ctx, request)
	return res, err
}

func (c *Client) sendAnswerWebAppQuery(ctx context.Context, request *AnswerWebAppQuery) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("answerWebAppQuery"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/answerWebAppQuery"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AnswerWebAppQueryOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/answerWebAppQuery"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAnswerWebAppQueryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAnswerWebAppQueryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ApproveChatJoinRequest invokes approveChatJoinRequest operation.
//
// Use this method to approve a chat join request. The bot must be an administrator in the chat for
// this to work and must have the _can_invite_users_ administrator right. Returns _True_ on success.
//
// POST /approveChatJoinRequest
func (c *Client) ApproveChatJoinRequest(ctx context.Context, request *ApproveChatJoinRequest) (*Result, error) {
	res, err := c.sendApproveChatJoinRequest(ctx, request)
	return res, err
}

func (c *Client) sendApproveChatJoinRequest(ctx context.Context, request *ApproveChatJoinRequest) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("approveChatJoinRequest"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/approveChatJoinRequest"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ApproveChatJoinRequestOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/approveChatJoinRequest"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeApproveChatJoinRequestRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeApproveChatJoinRequestResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BanChatMember invokes banChatMember operation.
//
// Use this method to ban a user in a group, a supergroup or a channel. In the case of supergroups
// and channels, the user will not be able to return to the chat on their own using invite links, etc.
// , unless [unbanned](https://core.telegram.org/bots/api#unbanchatmember) first. The bot must be an
// administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns _True_ on success.
//
// POST /banChatMember
func (c *Client) BanChatMember(ctx context.Context, request *BanChatMember) (*Result, error) {
	res, err := c.sendBanChatMember(ctx, request)
	return res, err
}

func (c *Client) sendBanChatMember(ctx context.Context, request *BanChatMember) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("banChatMember"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/banChatMember"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, BanChatMemberOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/banChatMember"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeBanChatMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBanChatMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BanChatSenderChat invokes banChatSenderChat operation.
//
// Use this method to ban a channel chat in a supergroup or a channel. Until the chat is
// [unbanned](https://core.telegram.org/bots/api#unbanchatsenderchat), the owner of the banned chat
// won't be able to send messages on behalf of **any of their channels**. The bot must be an
// administrator in the supergroup or channel for this to work and must have the appropriate
// administrator rights. Returns _True_ on success.
//
// POST /banChatSenderChat
func (c *Client) BanChatSenderChat(ctx context.Context, request *BanChatSenderChat) (*Result, error) {
	res, err := c.sendBanChatSenderChat(ctx, request)
	return res, err
}

func (c *Client) sendBanChatSenderChat(ctx context.Context, request *BanChatSenderChat) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("banChatSenderChat"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/banChatSenderChat"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, BanChatSenderChatOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/banChatSenderChat"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeBanChatSenderChatRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBanChatSenderChatResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Close invokes close operation.
//
// Use this method to close the bot instance before moving it from one local server to another. You
// need to delete the webhook before calling this method to ensure that the bot isn't launched again
// after server restart. The method will return error 429 in the first 10 minutes after the bot is
// launched. Returns _True_ on success. Requires no parameters.
//
// POST /close
func (c *Client) Close(ctx context.Context) (*Result, error) {
	res, err := c.sendClose(ctx)
	return res, err
}

func (c *Client) sendClose(ctx context.Context) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("close"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/close"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CloseOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/close"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCloseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CloseForumTopic invokes closeForumTopic operation.
//
// Use this method to close an open topic in a forum supergroup chat. The bot must be an
// administrator in the chat for this to work and must have the _can_manage_topics_ administrator
// rights, unless it is the creator of the topic. Returns _True_ on success.
//
// POST /closeForumTopic
func (c *Client) CloseForumTopic(ctx context.Context, request *CloseForumTopic) (*Result, error) {
	res, err := c.sendCloseForumTopic(ctx, request)
	return res, err
}

func (c *Client) sendCloseForumTopic(ctx context.Context, request *CloseForumTopic) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("closeForumTopic"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/closeForumTopic"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CloseForumTopicOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/closeForumTopic"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCloseForumTopicRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCloseForumTopicResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CloseGeneralForumTopic invokes closeGeneralForumTopic operation.
//
// Use this method to close an open 'General' topic in a forum supergroup chat. The bot must be an
// administrator in the chat for this to work and must have the _can_manage_topics_ administrator
// rights. Returns _True_ on success.
//
// POST /closeGeneralForumTopic
func (c *Client) CloseGeneralForumTopic(ctx context.Context, request *CloseGeneralForumTopic) (*Result, error) {
	res, err := c.sendCloseGeneralForumTopic(ctx, request)
	return res, err
}

func (c *Client) sendCloseGeneralForumTopic(ctx context.Context, request *CloseGeneralForumTopic) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("closeGeneralForumTopic"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/closeGeneralForumTopic"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CloseGeneralForumTopicOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/closeGeneralForumTopic"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCloseGeneralForumTopicRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCloseGeneralForumTopicResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CopyMessage invokes copyMessage operation.
//
// Use this method to copy messages of any kind. Service messages, paid media messages, giveaway
// messages, giveaway winners messages, and invoice messages can't be copied. A quiz
// [poll](https://core.telegram.org/bots/api#poll) can be copied only if the value of the field
// _correct_option_id_ is known to the bot. The method is analogous to the method
// [forwardMessage](https://core.telegram.org/bots/api#forwardmessage), but the copied message
// doesn't have a link to the original message. Returns the [MessageId](https://core.telegram.
// org/bots/api#messageid) of the sent message on success.
//
// POST /copyMessage
func (c *Client) CopyMessage(ctx context.Context, request *CopyMessage) (*ResultMessageId, error) {
	res, err := c.sendCopyMessage(ctx, request)
	return res, err
}

func (c *Client) sendCopyMessage(ctx context.Context, request *CopyMessage) (res *ResultMessageId, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("copyMessage"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/copyMessage"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CopyMessageOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/copyMessage"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCopyMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCopyMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CopyMessages invokes copyMessages operation.
//
// Use this method to copy messages of any kind. If some of the specified messages can't be found or
// copied, they are skipped. Service messages, paid media messages, giveaway messages, giveaway
// winners messages, and invoice messages can't be copied. A quiz [poll](https://core.telegram.
// org/bots/api#poll) can be copied only if the value of the field _correct_option_id_ is known to
// the bot. The method is analogous to the method [forwardMessages](https://core.telegram.
// org/bots/api#forwardmessages), but the copied messages don't have a link to the original message.
// Album grouping is kept for copied messages. On success, an array of [MessageId](https://core.
// telegram.org/bots/api#messageid) of the sent messages is returned.
//
// POST /copyMessages
func (c *Client) CopyMessages(ctx context.Context, request *CopyMessages) (*ResultArrayOfMessageId, error) {
	res, err := c.sendCopyMessages(ctx, request)
	return res, err
}

func (c *Client) sendCopyMessages(ctx context.Context, request *CopyMessages) (res *ResultArrayOfMessageId, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("copyMessages"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/copyMessages"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CopyMessagesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/copyMessages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCopyMessagesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCopyMessagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateChatInviteLink invokes createChatInviteLink operation.
//
// Use this method to create an additional invite link for a chat. The bot must be an administrator
// in the chat for this to work and must have the appropriate administrator rights. The link can be
// revoked using the method [revokeChatInviteLink](https://core.telegram.
// org/bots/api#revokechatinvitelink). Returns the new invite link as [ChatInviteLink](https://core.
// telegram.org/bots/api#chatinvitelink) object.
//
// POST /createChatInviteLink
func (c *Client) CreateChatInviteLink(ctx context.Context, request *CreateChatInviteLink) (*ResultChatInviteLink, error) {
	res, err := c.sendCreateChatInviteLink(ctx, request)
	return res, err
}

func (c *Client) sendCreateChatInviteLink(ctx context.Context, request *CreateChatInviteLink) (res *ResultChatInviteLink, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createChatInviteLink"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/createChatInviteLink"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateChatInviteLinkOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/createChatInviteLink"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateChatInviteLinkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateChatInviteLinkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateChatSubscriptionInviteLink invokes createChatSubscriptionInviteLink operation.
//
// Use this method to create a [subscription invite link](https://telegram.
// org/blog/superchannels-star-reactions-subscriptions#star-subscriptions) for a channel chat. The
// bot must have the _can_invite_users_ administrator rights. The link can be edited using the method
// [editChatSubscriptionInviteLink](https://core.telegram.
// org/bots/api#editchatsubscriptioninvitelink) or revoked using the method
// [revokeChatInviteLink](https://core.telegram.org/bots/api#revokechatinvitelink). Returns the new
// invite link as a [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object.
//
// POST /createChatSubscriptionInviteLink
func (c *Client) CreateChatSubscriptionInviteLink(ctx context.Context, request *CreateChatSubscriptionInviteLink) (*ResultChatInviteLink, error) {
	res, err := c.sendCreateChatSubscriptionInviteLink(ctx, request)
	return res, err
}

func (c *Client) sendCreateChatSubscriptionInviteLink(ctx context.Context, request *CreateChatSubscriptionInviteLink) (res *ResultChatInviteLink, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createChatSubscriptionInviteLink"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/createChatSubscriptionInviteLink"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateChatSubscriptionInviteLinkOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/createChatSubscriptionInviteLink"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateChatSubscriptionInviteLinkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateChatSubscriptionInviteLinkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateForumTopic invokes createForumTopic operation.
//
// Use this method to create a topic in a forum supergroup chat. The bot must be an administrator in
// the chat for this to work and must have the _can_manage_topics_ administrator rights. Returns
// information about the created topic as a [ForumTopic](https://core.telegram.
// org/bots/api#forumtopic) object.
//
// POST /createForumTopic
func (c *Client) CreateForumTopic(ctx context.Context, request *CreateForumTopic) (*Result, error) {
	res, err := c.sendCreateForumTopic(ctx, request)
	return res, err
}

func (c *Client) sendCreateForumTopic(ctx context.Context, request *CreateForumTopic) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createForumTopic"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/createForumTopic"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateForumTopicOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/createForumTopic"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateForumTopicRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateForumTopicResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateInvoiceLink invokes createInvoiceLink operation.
//
// Use this method to create a link for an invoice. Returns the created invoice link as _String_ on
// success.
//
// POST /createInvoiceLink
func (c *Client) CreateInvoiceLink(ctx context.Context, request *CreateInvoiceLink) (*ResultString, error) {
	res, err := c.sendCreateInvoiceLink(ctx, request)
	return res, err
}

func (c *Client) sendCreateInvoiceLink(ctx context.Context, request *CreateInvoiceLink) (res *ResultString, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createInvoiceLink"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/createInvoiceLink"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateInvoiceLinkOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/createInvoiceLink"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateInvoiceLinkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateInvoiceLinkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateNewStickerSet invokes createNewStickerSet operation.
//
// Use this method to create a new sticker set owned by a user. The bot will be able to edit the
// sticker set thus created. Returns _True_ on success.
//
// POST /createNewStickerSet
func (c *Client) CreateNewStickerSet(ctx context.Context, request *CreateNewStickerSet) (*Result, error) {
	res, err := c.sendCreateNewStickerSet(ctx, request)
	return res, err
}

func (c *Client) sendCreateNewStickerSet(ctx context.Context, request *CreateNewStickerSet) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createNewStickerSet"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/createNewStickerSet"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateNewStickerSetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/createNewStickerSet"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateNewStickerSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateNewStickerSetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeclineChatJoinRequest invokes declineChatJoinRequest operation.
//
// Use this method to decline a chat join request. The bot must be an administrator in the chat for
// this to work and must have the _can_invite_users_ administrator right. Returns _True_ on success.
//
// POST /declineChatJoinRequest
func (c *Client) DeclineChatJoinRequest(ctx context.Context, request *DeclineChatJoinRequest) (*Result, error) {
	res, err := c.sendDeclineChatJoinRequest(ctx, request)
	return res, err
}

func (c *Client) sendDeclineChatJoinRequest(ctx context.Context, request *DeclineChatJoinRequest) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("declineChatJoinRequest"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/declineChatJoinRequest"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeclineChatJoinRequestOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/declineChatJoinRequest"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeclineChatJoinRequestRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeclineChatJoinRequestResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteChatPhoto invokes deleteChatPhoto operation.
//
// Use this method to delete a chat photo. Photos can't be changed for private chats. The bot must be
// an administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns _True_ on success.
//
// POST /deleteChatPhoto
func (c *Client) DeleteChatPhoto(ctx context.Context, request *DeleteChatPhoto) (*Result, error) {
	res, err := c.sendDeleteChatPhoto(ctx, request)
	return res, err
}

func (c *Client) sendDeleteChatPhoto(ctx context.Context, request *DeleteChatPhoto) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteChatPhoto"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/deleteChatPhoto"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteChatPhotoOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/deleteChatPhoto"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteChatPhotoRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteChatPhotoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteChatStickerSet invokes deleteChatStickerSet operation.
//
// Use this method to delete a group sticker set from a supergroup. The bot must be an administrator
// in the chat for this to work and must have the appropriate administrator rights. Use the field
// _can_set_sticker_set_ optionally returned in [getChat](https://core.telegram.org/bots/api#getchat)
// requests to check if the bot can use this method. Returns _True_ on success.
//
// POST /deleteChatStickerSet
func (c *Client) DeleteChatStickerSet(ctx context.Context, request *DeleteChatStickerSet) (*Result, error) {
	res, err := c.sendDeleteChatStickerSet(ctx, request)
	return res, err
}

func (c *Client) sendDeleteChatStickerSet(ctx context.Context, request *DeleteChatStickerSet) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteChatStickerSet"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/deleteChatStickerSet"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteChatStickerSetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/deleteChatStickerSet"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteChatStickerSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteChatStickerSetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteForumTopic invokes deleteForumTopic operation.
//
// Use this method to delete a forum topic along with all its messages in a forum supergroup chat.
// The bot must be an administrator in the chat for this to work and must have the
// _can_delete_messages_ administrator rights. Returns _True_ on success.
//
// POST /deleteForumTopic
func (c *Client) DeleteForumTopic(ctx context.Context, request *DeleteForumTopic) (*Result, error) {
	res, err := c.sendDeleteForumTopic(ctx, request)
	return res, err
}

func (c *Client) sendDeleteForumTopic(ctx context.Context, request *DeleteForumTopic) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteForumTopic"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/deleteForumTopic"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteForumTopicOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/deleteForumTopic"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteForumTopicRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteForumTopicResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteMessage invokes deleteMessage operation.
//
// Use this method to delete a message, including service messages, with the following limitations:-
// A message can only be deleted if it was sent less than 48 hours ago.- Service messages about a
// supergroup, channel, or forum topic creation can't be deleted.- A dice message in a private chat
// can only be deleted if it was sent more than 24 hours ago.- Bots can delete outgoing messages in
// private chats, groups, and supergroups.- Bots can delete incoming messages in private chats.- Bots
// granted _can_post_messages_ permissions can delete outgoing messages in channels.- If the bot is
// an administrator of a group, it can delete any message there.- If the bot has
// _can_delete_messages_ permission in a supergroup or a channel, it can delete any message there.
// Returns _True_ on success.
//
// POST /deleteMessage
func (c *Client) DeleteMessage(ctx context.Context, request *DeleteMessage) (*Result, error) {
	res, err := c.sendDeleteMessage(ctx, request)
	return res, err
}

func (c *Client) sendDeleteMessage(ctx context.Context, request *DeleteMessage) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteMessage"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/deleteMessage"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteMessageOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/deleteMessage"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteMessages invokes deleteMessages operation.
//
// Use this method to delete multiple messages simultaneously. If some of the specified messages
// can't be found, they are skipped. Returns _True_ on success.
//
// POST /deleteMessages
func (c *Client) DeleteMessages(ctx context.Context, request *DeleteMessages) (*Result, error) {
	res, err := c.sendDeleteMessages(ctx, request)
	return res, err
}

func (c *Client) sendDeleteMessages(ctx context.Context, request *DeleteMessages) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteMessages"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/deleteMessages"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteMessagesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/deleteMessages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteMessagesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteMessagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteMyCommands invokes deleteMyCommands operation.
//
// Use this method to delete the list of the bot's commands for the given scope and user language.
// After deletion, [higher level commands](https://core.telegram.
// org/bots/api#determining-list-of-commands) will be shown to affected users. Returns _True_ on
// success.
//
// POST /deleteMyCommands
func (c *Client) DeleteMyCommands(ctx context.Context, request OptDeleteMyCommands) (*Result, error) {
	res, err := c.sendDeleteMyCommands(ctx, request)
	return res, err
}

func (c *Client) sendDeleteMyCommands(ctx context.Context, request OptDeleteMyCommands) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteMyCommands"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/deleteMyCommands"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteMyCommandsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/deleteMyCommands"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteMyCommandsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteMyCommandsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteStickerFromSet invokes deleteStickerFromSet operation.
//
// Use this method to delete a sticker from a set created by the bot. Returns _True_ on success.
//
// POST /deleteStickerFromSet
func (c *Client) DeleteStickerFromSet(ctx context.Context, request *DeleteStickerFromSet) (*Result, error) {
	res, err := c.sendDeleteStickerFromSet(ctx, request)
	return res, err
}

func (c *Client) sendDeleteStickerFromSet(ctx context.Context, request *DeleteStickerFromSet) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteStickerFromSet"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/deleteStickerFromSet"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteStickerFromSetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/deleteStickerFromSet"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteStickerFromSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteStickerFromSetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteStickerSet invokes deleteStickerSet operation.
//
// Use this method to delete a sticker set that was created by the bot. Returns _True_ on success.
//
// POST /deleteStickerSet
func (c *Client) DeleteStickerSet(ctx context.Context, request *DeleteStickerSet) (*Result, error) {
	res, err := c.sendDeleteStickerSet(ctx, request)
	return res, err
}

func (c *Client) sendDeleteStickerSet(ctx context.Context, request *DeleteStickerSet) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteStickerSet"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/deleteStickerSet"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteStickerSetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/deleteStickerSet"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteStickerSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteStickerSetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteWebhook invokes deleteWebhook operation.
//
// Use this method to remove webhook integration if you decide to switch back to
// [getUpdates](https://core.telegram.org/bots/api#getupdates). Returns _True_ on success.
//
// POST /deleteWebhook
func (c *Client) DeleteWebhook(ctx context.Context, request OptDeleteWebhook) (*Result, error) {
	res, err := c.sendDeleteWebhook(ctx, request)
	return res, err
}

func (c *Client) sendDeleteWebhook(ctx context.Context, request OptDeleteWebhook) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteWebhook"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/deleteWebhook"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteWebhookOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/deleteWebhook"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteWebhookRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditChatInviteLink invokes editChatInviteLink operation.
//
// Use this method to edit a non-primary invite link created by the bot. The bot must be an
// administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns the edited invite link as a [ChatInviteLink](https://core.telegram.
// org/bots/api#chatinvitelink) object.
//
// POST /editChatInviteLink
func (c *Client) EditChatInviteLink(ctx context.Context, request *EditChatInviteLink) (*ResultChatInviteLink, error) {
	res, err := c.sendEditChatInviteLink(ctx, request)
	return res, err
}

func (c *Client) sendEditChatInviteLink(ctx context.Context, request *EditChatInviteLink) (res *ResultChatInviteLink, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("editChatInviteLink"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/editChatInviteLink"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditChatInviteLinkOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/editChatInviteLink"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditChatInviteLinkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditChatInviteLinkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditChatSubscriptionInviteLink invokes editChatSubscriptionInviteLink operation.
//
// Use this method to edit a subscription invite link created by the bot. The bot must have the
// _can_invite_users_ administrator rights. Returns the edited invite link as a
// [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object.
//
// POST /editChatSubscriptionInviteLink
func (c *Client) EditChatSubscriptionInviteLink(ctx context.Context, request *EditChatSubscriptionInviteLink) (*ResultChatInviteLink, error) {
	res, err := c.sendEditChatSubscriptionInviteLink(ctx, request)
	return res, err
}

func (c *Client) sendEditChatSubscriptionInviteLink(ctx context.Context, request *EditChatSubscriptionInviteLink) (res *ResultChatInviteLink, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("editChatSubscriptionInviteLink"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/editChatSubscriptionInviteLink"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditChatSubscriptionInviteLinkOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/editChatSubscriptionInviteLink"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditChatSubscriptionInviteLinkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditChatSubscriptionInviteLinkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditForumTopic invokes editForumTopic operation.
//
// Use this method to edit name and icon of a topic in a forum supergroup chat. The bot must be an
// administrator in the chat for this to work and must have the _can_manage_topics_ administrator
// rights, unless it is the creator of the topic. Returns _True_ on success.
//
// POST /editForumTopic
func (c *Client) EditForumTopic(ctx context.Context, request *EditForumTopic) (*Result, error) {
	res, err := c.sendEditForumTopic(ctx, request)
	return res, err
}

func (c *Client) sendEditForumTopic(ctx context.Context, request *EditForumTopic) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("editForumTopic"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/editForumTopic"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditForumTopicOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/editForumTopic"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditForumTopicRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditForumTopicResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditGeneralForumTopic invokes editGeneralForumTopic operation.
//
// Use this method to edit the name of the 'General' topic in a forum supergroup chat. The bot must
// be an administrator in the chat for this to work and must have the _can_manage_topics_
// administrator rights. Returns _True_ on success.
//
// POST /editGeneralForumTopic
func (c *Client) EditGeneralForumTopic(ctx context.Context, request *EditGeneralForumTopic) (*Result, error) {
	res, err := c.sendEditGeneralForumTopic(ctx, request)
	return res, err
}

func (c *Client) sendEditGeneralForumTopic(ctx context.Context, request *EditGeneralForumTopic) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("editGeneralForumTopic"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/editGeneralForumTopic"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditGeneralForumTopicOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/editGeneralForumTopic"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditGeneralForumTopicRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditGeneralForumTopicResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditMessageCaption invokes editMessageCaption operation.
//
// Use this method to edit captions of messages. On success, if the edited message is not an inline
// message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise
// _True_ is returned. Note that business messages that were not sent by the bot and do not contain
// an inline keyboard can only be edited within **48 hours** from the time they were sent.
//
// POST /editMessageCaption
func (c *Client) EditMessageCaption(ctx context.Context, request *EditMessageCaption) (*ResultMessageOrBoolean, error) {
	res, err := c.sendEditMessageCaption(ctx, request)
	return res, err
}

func (c *Client) sendEditMessageCaption(ctx context.Context, request *EditMessageCaption) (res *ResultMessageOrBoolean, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("editMessageCaption"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/editMessageCaption"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditMessageCaptionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/editMessageCaption"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditMessageCaptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditMessageCaptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditMessageLiveLocation invokes editMessageLiveLocation operation.
//
// Use this method to edit live location messages. A location can be edited until its _live_period_
// expires or editing is explicitly disabled by a call to [stopMessageLiveLocation](https://core.
// telegram.org/bots/api#stopmessagelivelocation). On success, if the edited message is not an inline
// message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise
// _True_ is returned.
//
// POST /editMessageLiveLocation
func (c *Client) EditMessageLiveLocation(ctx context.Context, request *EditMessageLiveLocation) (*ResultMessageOrBoolean, error) {
	res, err := c.sendEditMessageLiveLocation(ctx, request)
	return res, err
}

func (c *Client) sendEditMessageLiveLocation(ctx context.Context, request *EditMessageLiveLocation) (res *ResultMessageOrBoolean, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("editMessageLiveLocation"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/editMessageLiveLocation"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditMessageLiveLocationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/editMessageLiveLocation"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditMessageLiveLocationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditMessageLiveLocationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditMessageMedia invokes editMessageMedia operation.
//
// Use this method to edit animation, audio, document, photo, or video messages, or to add media to
// text messages. If a message is part of a message album, then it can be edited only to an audio for
// audio albums, only to a document for document albums and to a photo or a video otherwise. When an
// inline message is edited, a new file can't be uploaded; use a previously uploaded file via its
// file_id or specify a URL. On success, if the edited message is not an inline message, the edited
// [Message](https://core.telegram.org/bots/api#message) is returned, otherwise _True_ is returned.
// Note that business messages that were not sent by the bot and do not contain an inline keyboard
// can only be edited within **48 hours** from the time they were sent.
//
// POST /editMessageMedia
func (c *Client) EditMessageMedia(ctx context.Context, request *EditMessageMedia) (*ResultMessageOrBoolean, error) {
	res, err := c.sendEditMessageMedia(ctx, request)
	return res, err
}

func (c *Client) sendEditMessageMedia(ctx context.Context, request *EditMessageMedia) (res *ResultMessageOrBoolean, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("editMessageMedia"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/editMessageMedia"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditMessageMediaOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/editMessageMedia"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditMessageMediaRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditMessageMediaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditMessageReplyMarkup invokes editMessageReplyMarkup operation.
//
// Use this method to edit only the reply markup of messages. On success, if the edited message is
// not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is
// returned, otherwise _True_ is returned. Note that business messages that were not sent by the bot
// and do not contain an inline keyboard can only be edited within **48 hours** from the time they
// were sent.
//
// POST /editMessageReplyMarkup
func (c *Client) EditMessageReplyMarkup(ctx context.Context, request *EditMessageReplyMarkup) (*ResultMessageOrBoolean, error) {
	res, err := c.sendEditMessageReplyMarkup(ctx, request)
	return res, err
}

func (c *Client) sendEditMessageReplyMarkup(ctx context.Context, request *EditMessageReplyMarkup) (res *ResultMessageOrBoolean, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("editMessageReplyMarkup"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/editMessageReplyMarkup"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditMessageReplyMarkupOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/editMessageReplyMarkup"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditMessageReplyMarkupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditMessageReplyMarkupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditMessageText invokes editMessageText operation.
//
// Use this method to edit text and [game](https://core.telegram.org/bots/api#games) messages. On
// success, if the edited message is not an inline message, the edited [Message](https://core.
// telegram.org/bots/api#message) is returned, otherwise _True_ is returned. Note that business
// messages that were not sent by the bot and do not contain an inline keyboard can only be edited
// within **48 hours** from the time they were sent.
//
// POST /editMessageText
func (c *Client) EditMessageText(ctx context.Context, request *EditMessageText) (*ResultMessageOrBoolean, error) {
	res, err := c.sendEditMessageText(ctx, request)
	return res, err
}

func (c *Client) sendEditMessageText(ctx context.Context, request *EditMessageText) (res *ResultMessageOrBoolean, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("editMessageText"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/editMessageText"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditMessageTextOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/editMessageText"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditMessageTextRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditMessageTextResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditUserStarSubscription invokes editUserStarSubscription operation.
//
// Allows the bot to cancel or re-enable extension of a subscription paid in Telegram Stars. Returns
// _True_ on success.
//
// POST /editUserStarSubscription
func (c *Client) EditUserStarSubscription(ctx context.Context, request *EditUserStarSubscription) (*Result, error) {
	res, err := c.sendEditUserStarSubscription(ctx, request)
	return res, err
}

func (c *Client) sendEditUserStarSubscription(ctx context.Context, request *EditUserStarSubscription) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("editUserStarSubscription"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/editUserStarSubscription"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditUserStarSubscriptionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/editUserStarSubscription"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditUserStarSubscriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditUserStarSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExportChatInviteLink invokes exportChatInviteLink operation.
//
// Use this method to generate a new primary invite link for a chat; any previously generated primary
// link is revoked. The bot must be an administrator in the chat for this to work and must have the
// appropriate administrator rights. Returns the new invite link as _String_ on success.
//
// POST /exportChatInviteLink
func (c *Client) ExportChatInviteLink(ctx context.Context, request *ExportChatInviteLink) (*ResultString, error) {
	res, err := c.sendExportChatInviteLink(ctx, request)
	return res, err
}

func (c *Client) sendExportChatInviteLink(ctx context.Context, request *ExportChatInviteLink) (res *ResultString, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("exportChatInviteLink"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/exportChatInviteLink"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ExportChatInviteLinkOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/exportChatInviteLink"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeExportChatInviteLinkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeExportChatInviteLinkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ForwardMessage invokes forwardMessage operation.
//
// Use this method to forward messages of any kind. Service messages and messages with protected
// content can't be forwarded. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned.
//
// POST /forwardMessage
func (c *Client) ForwardMessage(ctx context.Context, request *ForwardMessage) (*ResultMessage, error) {
	res, err := c.sendForwardMessage(ctx, request)
	return res, err
}

func (c *Client) sendForwardMessage(ctx context.Context, request *ForwardMessage) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("forwardMessage"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/forwardMessage"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ForwardMessageOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/forwardMessage"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeForwardMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeForwardMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ForwardMessages invokes forwardMessages operation.
//
// Use this method to forward multiple messages of any kind. If some of the specified messages can't
// be found or forwarded, they are skipped. Service messages and messages with protected content
// can't be forwarded. Album grouping is kept for forwarded messages. On success, an array of
// [MessageId](https://core.telegram.org/bots/api#messageid) of the sent messages is returned.
//
// POST /forwardMessages
func (c *Client) ForwardMessages(ctx context.Context, request *ForwardMessages) (*ResultArrayOfMessageId, error) {
	res, err := c.sendForwardMessages(ctx, request)
	return res, err
}

func (c *Client) sendForwardMessages(ctx context.Context, request *ForwardMessages) (res *ResultArrayOfMessageId, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("forwardMessages"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/forwardMessages"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ForwardMessagesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/forwardMessages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeForwardMessagesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeForwardMessagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAvailableGifts invokes getAvailableGifts operation.
//
// Returns the list of gifts that can be sent by the bot to users. Requires no parameters. Returns a
// [Gifts](https://core.telegram.org/bots/api#gifts) object.
//
// POST /getAvailableGifts
func (c *Client) GetAvailableGifts(ctx context.Context) (*Result, error) {
	res, err := c.sendGetAvailableGifts(ctx)
	return res, err
}

func (c *Client) sendGetAvailableGifts(ctx context.Context) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAvailableGifts"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getAvailableGifts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetAvailableGiftsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getAvailableGifts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAvailableGiftsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBusinessConnection invokes getBusinessConnection operation.
//
// Use this method to get information about the connection of the bot with a business account.
// Returns a [BusinessConnection](https://core.telegram.org/bots/api#businessconnection) object on
// success.
//
// POST /getBusinessConnection
func (c *Client) GetBusinessConnection(ctx context.Context, request *GetBusinessConnection) (*Result, error) {
	res, err := c.sendGetBusinessConnection(ctx, request)
	return res, err
}

func (c *Client) sendGetBusinessConnection(ctx context.Context, request *GetBusinessConnection) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBusinessConnection"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getBusinessConnection"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetBusinessConnectionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getBusinessConnection"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetBusinessConnectionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetBusinessConnectionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChat invokes getChat operation.
//
// Use this method to get up-to-date information about the chat. Returns a
// [ChatFullInfo](https://core.telegram.org/bots/api#chatfullinfo) object on success.
//
// POST /getChat
func (c *Client) GetChat(ctx context.Context, request *GetChat) (*Result, error) {
	res, err := c.sendGetChat(ctx, request)
	return res, err
}

func (c *Client) sendGetChat(ctx context.Context, request *GetChat) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getChat"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getChat"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetChatOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getChat"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetChatRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetChatResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChatAdministrators invokes getChatAdministrators operation.
//
// Use this method to get a list of administrators in a chat, which aren't bots. Returns an Array of
// [ChatMember](https://core.telegram.org/bots/api#chatmember) objects.
//
// POST /getChatAdministrators
func (c *Client) GetChatAdministrators(ctx context.Context, request *GetChatAdministrators) (*ResultArrayOfChatMember, error) {
	res, err := c.sendGetChatAdministrators(ctx, request)
	return res, err
}

func (c *Client) sendGetChatAdministrators(ctx context.Context, request *GetChatAdministrators) (res *ResultArrayOfChatMember, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getChatAdministrators"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getChatAdministrators"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetChatAdministratorsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getChatAdministrators"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetChatAdministratorsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetChatAdministratorsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChatMember invokes getChatMember operation.
//
// Use this method to get information about a member of a chat. The method is only guaranteed to work
// for other users if the bot is an administrator in the chat. Returns a [ChatMember](https://core.
// telegram.org/bots/api#chatmember) object on success.
//
// POST /getChatMember
func (c *Client) GetChatMember(ctx context.Context, request *GetChatMember) (*ResultChatMember, error) {
	res, err := c.sendGetChatMember(ctx, request)
	return res, err
}

func (c *Client) sendGetChatMember(ctx context.Context, request *GetChatMember) (res *ResultChatMember, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getChatMember"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getChatMember"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetChatMemberOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getChatMember"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetChatMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetChatMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChatMemberCount invokes getChatMemberCount operation.
//
// Use this method to get the number of members in a chat. Returns _Int_ on success.
//
// POST /getChatMemberCount
func (c *Client) GetChatMemberCount(ctx context.Context, request *GetChatMemberCount) (*ResultInt, error) {
	res, err := c.sendGetChatMemberCount(ctx, request)
	return res, err
}

func (c *Client) sendGetChatMemberCount(ctx context.Context, request *GetChatMemberCount) (res *ResultInt, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getChatMemberCount"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getChatMemberCount"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetChatMemberCountOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getChatMemberCount"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetChatMemberCountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetChatMemberCountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChatMenuButton invokes getChatMenuButton operation.
//
// Use this method to get the current value of the bot's menu button in a private chat, or the
// default menu button. Returns [MenuButton](https://core.telegram.org/bots/api#menubutton) on
// success.
//
// POST /getChatMenuButton
func (c *Client) GetChatMenuButton(ctx context.Context, request OptGetChatMenuButton) (*Result, error) {
	res, err := c.sendGetChatMenuButton(ctx, request)
	return res, err
}

func (c *Client) sendGetChatMenuButton(ctx context.Context, request OptGetChatMenuButton) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getChatMenuButton"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getChatMenuButton"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetChatMenuButtonOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getChatMenuButton"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetChatMenuButtonRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetChatMenuButtonResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCustomEmojiStickers invokes getCustomEmojiStickers operation.
//
// Use this method to get information about custom emoji stickers by their identifiers. Returns an
// Array of [Sticker](https://core.telegram.org/bots/api#sticker) objects.
//
// POST /getCustomEmojiStickers
func (c *Client) GetCustomEmojiStickers(ctx context.Context, request *GetCustomEmojiStickers) (*ResultArrayOfSticker, error) {
	res, err := c.sendGetCustomEmojiStickers(ctx, request)
	return res, err
}

func (c *Client) sendGetCustomEmojiStickers(ctx context.Context, request *GetCustomEmojiStickers) (res *ResultArrayOfSticker, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCustomEmojiStickers"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getCustomEmojiStickers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetCustomEmojiStickersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getCustomEmojiStickers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetCustomEmojiStickersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCustomEmojiStickersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetFile invokes getFile operation.
//
// Use this method to get basic information about a file and prepare it for downloading. For the
// moment, bots can download files of up to 20MB in size. On success, a [File](https://core.telegram.
// org/bots/api#file) object is returned. The file can then be downloaded via the link `https://api.
// telegram.org/file/bot<token>/<file_path>`, where `<file_path>` is taken from the response. It is
// guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can
// be requested by calling [getFile](https://core.telegram.org/bots/api#getfile) again.
//
// POST /getFile
func (c *Client) GetFile(ctx context.Context, request *GetFile) (*ResultFile, error) {
	res, err := c.sendGetFile(ctx, request)
	return res, err
}

func (c *Client) sendGetFile(ctx context.Context, request *GetFile) (res *ResultFile, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getFile"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getFile"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetFileOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getFile"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetFileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetFileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetForumTopicIconStickers invokes getForumTopicIconStickers operation.
//
// Use this method to get custom emoji stickers, which can be used as a forum topic icon by any user.
// Requires no parameters. Returns an Array of [Sticker](https://core.telegram.org/bots/api#sticker)
// objects.
//
// POST /getForumTopicIconStickers
func (c *Client) GetForumTopicIconStickers(ctx context.Context) (*ResultArrayOfSticker, error) {
	res, err := c.sendGetForumTopicIconStickers(ctx)
	return res, err
}

func (c *Client) sendGetForumTopicIconStickers(ctx context.Context) (res *ResultArrayOfSticker, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getForumTopicIconStickers"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getForumTopicIconStickers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetForumTopicIconStickersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getForumTopicIconStickers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetForumTopicIconStickersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGameHighScores invokes getGameHighScores operation.
//
// Use this method to get data for high score tables. Will return the score of the specified user and
// several of their neighbors in a game. Returns an Array of [GameHighScore](https://core.telegram.
// org/bots/api#gamehighscore) objects.
//
// POST /getGameHighScores
func (c *Client) GetGameHighScores(ctx context.Context, request *GetGameHighScores) (*ResultArrayOfGameHighScore, error) {
	res, err := c.sendGetGameHighScores(ctx, request)
	return res, err
}

func (c *Client) sendGetGameHighScores(ctx context.Context, request *GetGameHighScores) (res *ResultArrayOfGameHighScore, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getGameHighScores"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getGameHighScores"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetGameHighScoresOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getGameHighScores"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetGameHighScoresRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetGameHighScoresResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMe invokes getMe operation.
//
// A simple method for testing your bot's authentication token. Requires no parameters. Returns basic
// information about the bot in form of a [User](https://core.telegram.org/bots/api#user) object.
//
// POST /getMe
func (c *Client) GetMe(ctx context.Context) (*ResultUser, error) {
	res, err := c.sendGetMe(ctx)
	return res, err
}

func (c *Client) sendGetMe(ctx context.Context) (res *ResultUser, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getMe"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getMe"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetMeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getMe"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyCommands invokes getMyCommands operation.
//
// Use this method to get the current list of the bot's commands for the given scope and user
// language. Returns an Array of [BotCommand](https://core.telegram.org/bots/api#botcommand) objects.
// If commands aren't set, an empty list is returned.
//
// POST /getMyCommands
func (c *Client) GetMyCommands(ctx context.Context, request OptGetMyCommands) (*ResultArrayOfBotCommand, error) {
	res, err := c.sendGetMyCommands(ctx, request)
	return res, err
}

func (c *Client) sendGetMyCommands(ctx context.Context, request OptGetMyCommands) (res *ResultArrayOfBotCommand, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getMyCommands"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getMyCommands"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetMyCommandsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getMyCommands"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetMyCommandsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMyCommandsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyDefaultAdministratorRights invokes getMyDefaultAdministratorRights operation.
//
// Use this method to get the current default administrator rights of the bot. Returns
// [ChatAdministratorRights](https://core.telegram.org/bots/api#chatadministratorrights) on success.
//
// POST /getMyDefaultAdministratorRights
func (c *Client) GetMyDefaultAdministratorRights(ctx context.Context, request OptGetMyDefaultAdministratorRights) (*Result, error) {
	res, err := c.sendGetMyDefaultAdministratorRights(ctx, request)
	return res, err
}

func (c *Client) sendGetMyDefaultAdministratorRights(ctx context.Context, request OptGetMyDefaultAdministratorRights) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getMyDefaultAdministratorRights"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getMyDefaultAdministratorRights"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetMyDefaultAdministratorRightsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getMyDefaultAdministratorRights"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetMyDefaultAdministratorRightsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMyDefaultAdministratorRightsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyDescription invokes getMyDescription operation.
//
// Use this method to get the current bot description for the given user language. Returns
// [BotDescription](https://core.telegram.org/bots/api#botdescription) on success.
//
// POST /getMyDescription
func (c *Client) GetMyDescription(ctx context.Context, request OptGetMyDescription) (*Result, error) {
	res, err := c.sendGetMyDescription(ctx, request)
	return res, err
}

func (c *Client) sendGetMyDescription(ctx context.Context, request OptGetMyDescription) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getMyDescription"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getMyDescription"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetMyDescriptionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getMyDescription"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetMyDescriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMyDescriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyName invokes getMyName operation.
//
// Use this method to get the current bot name for the given user language. Returns
// [BotName](https://core.telegram.org/bots/api#botname) on success.
//
// POST /getMyName
func (c *Client) GetMyName(ctx context.Context, request OptGetMyName) (*Result, error) {
	res, err := c.sendGetMyName(ctx, request)
	return res, err
}

func (c *Client) sendGetMyName(ctx context.Context, request OptGetMyName) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getMyName"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getMyName"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetMyNameOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getMyName"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetMyNameRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMyNameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyShortDescription invokes getMyShortDescription operation.
//
// Use this method to get the current bot short description for the given user language. Returns
// [BotShortDescription](https://core.telegram.org/bots/api#botshortdescription) on success.
//
// POST /getMyShortDescription
func (c *Client) GetMyShortDescription(ctx context.Context, request OptGetMyShortDescription) (*Result, error) {
	res, err := c.sendGetMyShortDescription(ctx, request)
	return res, err
}

func (c *Client) sendGetMyShortDescription(ctx context.Context, request OptGetMyShortDescription) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getMyShortDescription"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getMyShortDescription"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetMyShortDescriptionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getMyShortDescription"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetMyShortDescriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMyShortDescriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStarTransactions invokes getStarTransactions operation.
//
// Returns the bot's Telegram Star transactions in chronological order. On success, returns a
// [StarTransactions](https://core.telegram.org/bots/api#startransactions) object.
//
// POST /getStarTransactions
func (c *Client) GetStarTransactions(ctx context.Context, request OptGetStarTransactions) (*Result, error) {
	res, err := c.sendGetStarTransactions(ctx, request)
	return res, err
}

func (c *Client) sendGetStarTransactions(ctx context.Context, request OptGetStarTransactions) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStarTransactions"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getStarTransactions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetStarTransactionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getStarTransactions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetStarTransactionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStarTransactionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStickerSet invokes getStickerSet operation.
//
// Use this method to get a sticker set. On success, a [StickerSet](https://core.telegram.
// org/bots/api#stickerset) object is returned.
//
// POST /getStickerSet
func (c *Client) GetStickerSet(ctx context.Context, request *GetStickerSet) (*ResultStickerSet, error) {
	res, err := c.sendGetStickerSet(ctx, request)
	return res, err
}

func (c *Client) sendGetStickerSet(ctx context.Context, request *GetStickerSet) (res *ResultStickerSet, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStickerSet"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getStickerSet"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetStickerSetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getStickerSet"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetStickerSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStickerSetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUpdates invokes getUpdates operation.
//
// Use this method to receive incoming updates using long polling ([wiki](https://en.wikipedia.
// org/wiki/Push_technology#Long_polling)). Returns an Array of [Update](https://core.telegram.
// org/bots/api#update) objects.
//
// POST /getUpdates
func (c *Client) GetUpdates(ctx context.Context, request OptGetUpdates) (*ResultArrayOfUpdate, error) {
	res, err := c.sendGetUpdates(ctx, request)
	return res, err
}

func (c *Client) sendGetUpdates(ctx context.Context, request OptGetUpdates) (res *ResultArrayOfUpdate, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getUpdates"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getUpdates"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetUpdatesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getUpdates"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetUpdatesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetUpdatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserChatBoosts invokes getUserChatBoosts operation.
//
// Use this method to get the list of boosts added to a chat by a user. Requires administrator rights
// in the chat. Returns a [UserChatBoosts](https://core.telegram.org/bots/api#userchatboosts) object.
//
// POST /getUserChatBoosts
func (c *Client) GetUserChatBoosts(ctx context.Context, request *GetUserChatBoosts) (*Result, error) {
	res, err := c.sendGetUserChatBoosts(ctx, request)
	return res, err
}

func (c *Client) sendGetUserChatBoosts(ctx context.Context, request *GetUserChatBoosts) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getUserChatBoosts"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getUserChatBoosts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetUserChatBoostsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getUserChatBoosts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetUserChatBoostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetUserChatBoostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserProfilePhotos invokes getUserProfilePhotos operation.
//
// Use this method to get a list of profile pictures for a user. Returns a
// [UserProfilePhotos](https://core.telegram.org/bots/api#userprofilephotos) object.
//
// POST /getUserProfilePhotos
func (c *Client) GetUserProfilePhotos(ctx context.Context, request *GetUserProfilePhotos) (*ResultUserProfilePhotos, error) {
	res, err := c.sendGetUserProfilePhotos(ctx, request)
	return res, err
}

func (c *Client) sendGetUserProfilePhotos(ctx context.Context, request *GetUserProfilePhotos) (res *ResultUserProfilePhotos, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getUserProfilePhotos"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getUserProfilePhotos"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetUserProfilePhotosOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getUserProfilePhotos"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetUserProfilePhotosRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetUserProfilePhotosResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWebhookInfo invokes getWebhookInfo operation.
//
// Use this method to get current webhook status. Requires no parameters. On success, returns a
// [WebhookInfo](https://core.telegram.org/bots/api#webhookinfo) object. If the bot is using
// [getUpdates](https://core.telegram.org/bots/api#getupdates), will return an object with the _url_
// field empty.
//
// POST /getWebhookInfo
func (c *Client) GetWebhookInfo(ctx context.Context) (*ResultWebhookInfo, error) {
	res, err := c.sendGetWebhookInfo(ctx)
	return res, err
}

func (c *Client) sendGetWebhookInfo(ctx context.Context) (res *ResultWebhookInfo, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getWebhookInfo"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/getWebhookInfo"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetWebhookInfoOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/getWebhookInfo"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWebhookInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HideGeneralForumTopic invokes hideGeneralForumTopic operation.
//
// Use this method to hide the 'General' topic in a forum supergroup chat. The bot must be an
// administrator in the chat for this to work and must have the _can_manage_topics_ administrator
// rights. The topic will be automatically closed if it was open. Returns _True_ on success.
//
// POST /hideGeneralForumTopic
func (c *Client) HideGeneralForumTopic(ctx context.Context, request *HideGeneralForumTopic) (*Result, error) {
	res, err := c.sendHideGeneralForumTopic(ctx, request)
	return res, err
}

func (c *Client) sendHideGeneralForumTopic(ctx context.Context, request *HideGeneralForumTopic) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("hideGeneralForumTopic"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/hideGeneralForumTopic"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HideGeneralForumTopicOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/hideGeneralForumTopic"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHideGeneralForumTopicRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeHideGeneralForumTopicResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeaveChat invokes leaveChat operation.
//
// Use this method for your bot to leave a group, supergroup or channel. Returns _True_ on success.
//
// POST /leaveChat
func (c *Client) LeaveChat(ctx context.Context, request *LeaveChat) (*Result, error) {
	res, err := c.sendLeaveChat(ctx, request)
	return res, err
}

func (c *Client) sendLeaveChat(ctx context.Context, request *LeaveChat) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("leaveChat"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/leaveChat"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LeaveChatOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/leaveChat"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLeaveChatRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLeaveChatResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LogOut invokes logOut operation.
//
// Use this method to log out from the cloud Bot API server before launching the bot locally. You
// **must** log out the bot before running it locally, otherwise there is no guarantee that the bot
// will receive updates. After a successful call, you can immediately log in on a local server, but
// will not be able to log in back to the cloud Bot API server for 10 minutes. Returns _True_ on
// success. Requires no parameters.
//
// POST /logOut
func (c *Client) LogOut(ctx context.Context) (*Result, error) {
	res, err := c.sendLogOut(ctx)
	return res, err
}

func (c *Client) sendLogOut(ctx context.Context) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("logOut"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/logOut"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LogOutOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/logOut"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLogOutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PinChatMessage invokes pinChatMessage operation.
//
// Use this method to add a message to the list of pinned messages in a chat. If the chat is not a
// private chat, the bot must be an administrator in the chat for this to work and must have the
// 'can_pin_messages' administrator right in a supergroup or 'can_edit_messages' administrator right
// in a channel. Returns _True_ on success.
//
// POST /pinChatMessage
func (c *Client) PinChatMessage(ctx context.Context, request *PinChatMessage) (*Result, error) {
	res, err := c.sendPinChatMessage(ctx, request)
	return res, err
}

func (c *Client) sendPinChatMessage(ctx context.Context, request *PinChatMessage) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pinChatMessage"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/pinChatMessage"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, PinChatMessageOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/pinChatMessage"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePinChatMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePinChatMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PromoteChatMember invokes promoteChatMember operation.
//
// Use this method to promote or demote a user in a supergroup or a channel. The bot must be an
// administrator in the chat for this to work and must have the appropriate administrator rights.
// Pass _False_ for all boolean parameters to demote a user. Returns _True_ on success.
//
// POST /promoteChatMember
func (c *Client) PromoteChatMember(ctx context.Context, request *PromoteChatMember) (*Result, error) {
	res, err := c.sendPromoteChatMember(ctx, request)
	return res, err
}

func (c *Client) sendPromoteChatMember(ctx context.Context, request *PromoteChatMember) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("promoteChatMember"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/promoteChatMember"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, PromoteChatMemberOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/promoteChatMember"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePromoteChatMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePromoteChatMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RefundStarPayment invokes refundStarPayment operation.
//
// Refunds a successful payment in [Telegram Stars](https://t.me/BotNews/90). Returns _True_ on
// success.
//
// POST /refundStarPayment
func (c *Client) RefundStarPayment(ctx context.Context, request *RefundStarPayment) (*Result, error) {
	res, err := c.sendRefundStarPayment(ctx, request)
	return res, err
}

func (c *Client) sendRefundStarPayment(ctx context.Context, request *RefundStarPayment) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("refundStarPayment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/refundStarPayment"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RefundStarPaymentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/refundStarPayment"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRefundStarPaymentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRefundStarPaymentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveChatVerification invokes removeChatVerification operation.
//
// Removes verification from a chat that is currently verified [on behalf of the
// organization](https://telegram.org/verify#third-party-verification) represented by the bot.
// Returns _True_ on success.
//
// POST /removeChatVerification
func (c *Client) RemoveChatVerification(ctx context.Context, request *RemoveChatVerification) (*Result, error) {
	res, err := c.sendRemoveChatVerification(ctx, request)
	return res, err
}

func (c *Client) sendRemoveChatVerification(ctx context.Context, request *RemoveChatVerification) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("removeChatVerification"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/removeChatVerification"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RemoveChatVerificationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/removeChatVerification"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRemoveChatVerificationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRemoveChatVerificationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveUserVerification invokes removeUserVerification operation.
//
// Removes verification from a user who is currently verified [on behalf of the
// organization](https://telegram.org/verify#third-party-verification) represented by the bot.
// Returns _True_ on success.
//
// POST /removeUserVerification
func (c *Client) RemoveUserVerification(ctx context.Context, request *RemoveUserVerification) (*Result, error) {
	res, err := c.sendRemoveUserVerification(ctx, request)
	return res, err
}

func (c *Client) sendRemoveUserVerification(ctx context.Context, request *RemoveUserVerification) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("removeUserVerification"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/removeUserVerification"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RemoveUserVerificationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/removeUserVerification"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRemoveUserVerificationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRemoveUserVerificationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReopenForumTopic invokes reopenForumTopic operation.
//
// Use this method to reopen a closed topic in a forum supergroup chat. The bot must be an
// administrator in the chat for this to work and must have the _can_manage_topics_ administrator
// rights, unless it is the creator of the topic. Returns _True_ on success.
//
// POST /reopenForumTopic
func (c *Client) ReopenForumTopic(ctx context.Context, request *ReopenForumTopic) (*Result, error) {
	res, err := c.sendReopenForumTopic(ctx, request)
	return res, err
}

func (c *Client) sendReopenForumTopic(ctx context.Context, request *ReopenForumTopic) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reopenForumTopic"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/reopenForumTopic"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ReopenForumTopicOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/reopenForumTopic"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReopenForumTopicRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReopenForumTopicResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReopenGeneralForumTopic invokes reopenGeneralForumTopic operation.
//
// Use this method to reopen a closed 'General' topic in a forum supergroup chat. The bot must be an
// administrator in the chat for this to work and must have the _can_manage_topics_ administrator
// rights. The topic will be automatically unhidden if it was hidden. Returns _True_ on success.
//
// POST /reopenGeneralForumTopic
func (c *Client) ReopenGeneralForumTopic(ctx context.Context, request *ReopenGeneralForumTopic) (*Result, error) {
	res, err := c.sendReopenGeneralForumTopic(ctx, request)
	return res, err
}

func (c *Client) sendReopenGeneralForumTopic(ctx context.Context, request *ReopenGeneralForumTopic) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reopenGeneralForumTopic"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/reopenGeneralForumTopic"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ReopenGeneralForumTopicOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/reopenGeneralForumTopic"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReopenGeneralForumTopicRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReopenGeneralForumTopicResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReplaceStickerInSet invokes replaceStickerInSet operation.
//
// Use this method to replace an existing sticker in a sticker set with a new one. The method is
// equivalent to calling [deleteStickerFromSet](https://core.telegram.
// org/bots/api#deletestickerfromset), then [addStickerToSet](https://core.telegram.
// org/bots/api#addstickertoset), then [setStickerPositionInSet](https://core.telegram.
// org/bots/api#setstickerpositioninset). Returns _True_ on success.
//
// POST /replaceStickerInSet
func (c *Client) ReplaceStickerInSet(ctx context.Context, request *ReplaceStickerInSet) (*Result, error) {
	res, err := c.sendReplaceStickerInSet(ctx, request)
	return res, err
}

func (c *Client) sendReplaceStickerInSet(ctx context.Context, request *ReplaceStickerInSet) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("replaceStickerInSet"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/replaceStickerInSet"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ReplaceStickerInSetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/replaceStickerInSet"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReplaceStickerInSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReplaceStickerInSetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RestrictChatMember invokes restrictChatMember operation.
//
// Use this method to restrict a user in a supergroup. The bot must be an administrator in the
// supergroup for this to work and must have the appropriate administrator rights. Pass _True_ for
// all permissions to lift restrictions from a user. Returns _True_ on success.
//
// POST /restrictChatMember
func (c *Client) RestrictChatMember(ctx context.Context, request *RestrictChatMember) (*Result, error) {
	res, err := c.sendRestrictChatMember(ctx, request)
	return res, err
}

func (c *Client) sendRestrictChatMember(ctx context.Context, request *RestrictChatMember) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("restrictChatMember"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/restrictChatMember"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RestrictChatMemberOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/restrictChatMember"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRestrictChatMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRestrictChatMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RevokeChatInviteLink invokes revokeChatInviteLink operation.
//
// Use this method to revoke an invite link created by the bot. If the primary link is revoked, a new
// link is automatically generated. The bot must be an administrator in the chat for this to work and
// must have the appropriate administrator rights. Returns the revoked invite link as
// [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object.
//
// POST /revokeChatInviteLink
func (c *Client) RevokeChatInviteLink(ctx context.Context, request *RevokeChatInviteLink) (*ResultChatInviteLink, error) {
	res, err := c.sendRevokeChatInviteLink(ctx, request)
	return res, err
}

func (c *Client) sendRevokeChatInviteLink(ctx context.Context, request *RevokeChatInviteLink) (res *ResultChatInviteLink, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("revokeChatInviteLink"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/revokeChatInviteLink"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RevokeChatInviteLinkOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/revokeChatInviteLink"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRevokeChatInviteLinkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRevokeChatInviteLinkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SavePreparedInlineMessage invokes savePreparedInlineMessage operation.
//
// Stores a message that can be sent by a user of a Mini App. Returns a
// [PreparedInlineMessage](https://core.telegram.org/bots/api#preparedinlinemessage) object.
//
// POST /savePreparedInlineMessage
func (c *Client) SavePreparedInlineMessage(ctx context.Context, request *SavePreparedInlineMessage) (*Result, error) {
	res, err := c.sendSavePreparedInlineMessage(ctx, request)
	return res, err
}

func (c *Client) sendSavePreparedInlineMessage(ctx context.Context, request *SavePreparedInlineMessage) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("savePreparedInlineMessage"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/savePreparedInlineMessage"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SavePreparedInlineMessageOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/savePreparedInlineMessage"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSavePreparedInlineMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSavePreparedInlineMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendAnimation invokes sendAnimation operation.
//
// Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On success,
// the sent [Message](https://core.telegram.org/bots/api#message) is returned. Bots can currently
// send animation files of up to 50 MB in size, this limit may be changed in the future.
//
// POST /sendAnimation
func (c *Client) SendAnimation(ctx context.Context, request *SendAnimation) (*ResultMessage, error) {
	res, err := c.sendSendAnimation(ctx, request)
	return res, err
}

func (c *Client) sendSendAnimation(ctx context.Context, request *SendAnimation) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendAnimation"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendAnimation"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendAnimationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendAnimation"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendAnimationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendAnimationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendAudio invokes sendAudio operation.
//
// For sending voice messages, use the [sendVoice](https://core.telegram.org/bots/api#sendvoice)
// method instead.
//
// POST /sendAudio
func (c *Client) SendAudio(ctx context.Context, request *SendAudio) (*ResultMessage, error) {
	res, err := c.sendSendAudio(ctx, request)
	return res, err
}

func (c *Client) sendSendAudio(ctx context.Context, request *SendAudio) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendAudio"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendAudio"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendAudioOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendAudio"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendAudioRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendAudioResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendChatAction invokes sendChatAction operation.
//
// We only recommend using this method when a response from the bot will take a **noticeable** amount
// of time to arrive.
//
// POST /sendChatAction
func (c *Client) SendChatAction(ctx context.Context, request *SendChatAction) (*Result, error) {
	res, err := c.sendSendChatAction(ctx, request)
	return res, err
}

func (c *Client) sendSendChatAction(ctx context.Context, request *SendChatAction) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendChatAction"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendChatAction"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendChatActionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendChatAction"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendChatActionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendChatActionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendContact invokes sendContact operation.
//
// Use this method to send phone contacts. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned.
//
// POST /sendContact
func (c *Client) SendContact(ctx context.Context, request *SendContact) (*ResultMessage, error) {
	res, err := c.sendSendContact(ctx, request)
	return res, err
}

func (c *Client) sendSendContact(ctx context.Context, request *SendContact) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendContact"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendContact"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendContactOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendContact"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendContactRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendContactResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendDice invokes sendDice operation.
//
// Use this method to send an animated emoji that will display a random value. On success, the sent
// [Message](https://core.telegram.org/bots/api#message) is returned.
//
// POST /sendDice
func (c *Client) SendDice(ctx context.Context, request *SendDice) (*ResultMessage, error) {
	res, err := c.sendSendDice(ctx, request)
	return res, err
}

func (c *Client) sendSendDice(ctx context.Context, request *SendDice) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendDice"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendDice"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendDiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendDice"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendDiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendDiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendDocument invokes sendDocument operation.
//
// Use this method to send general files. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned. Bots can currently send files of any type of up to 50 MB in
// size, this limit may be changed in the future.
//
// POST /sendDocument
func (c *Client) SendDocument(ctx context.Context, request *SendDocument) (*ResultMessage, error) {
	res, err := c.sendSendDocument(ctx, request)
	return res, err
}

func (c *Client) sendSendDocument(ctx context.Context, request *SendDocument) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendDocument"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendDocument"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendDocumentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendDocument"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendDocumentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendDocumentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendGame invokes sendGame operation.
//
// Use this method to send a game. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned.
//
// POST /sendGame
func (c *Client) SendGame(ctx context.Context, request *SendGame) (*ResultMessage, error) {
	res, err := c.sendSendGame(ctx, request)
	return res, err
}

func (c *Client) sendSendGame(ctx context.Context, request *SendGame) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendGame"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendGame"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendGameOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendGame"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendGameRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendGameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendGift invokes sendGift operation.
//
// Sends a gift to the given user. The gift can't be converted to Telegram Stars by the user. Returns
// _True_ on success.
//
// POST /sendGift
func (c *Client) SendGift(ctx context.Context, request *SendGift) (*Result, error) {
	res, err := c.sendSendGift(ctx, request)
	return res, err
}

func (c *Client) sendSendGift(ctx context.Context, request *SendGift) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendGift"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendGift"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendGiftOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendGift"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendGiftRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendGiftResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendInvoice invokes sendInvoice operation.
//
// Use this method to send invoices. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned.
//
// POST /sendInvoice
func (c *Client) SendInvoice(ctx context.Context, request *SendInvoice) (*ResultMessage, error) {
	res, err := c.sendSendInvoice(ctx, request)
	return res, err
}

func (c *Client) sendSendInvoice(ctx context.Context, request *SendInvoice) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendInvoice"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendInvoice"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendInvoiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendInvoice"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendInvoiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendInvoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendLocation invokes sendLocation operation.
//
// Use this method to send point on the map. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned.
//
// POST /sendLocation
func (c *Client) SendLocation(ctx context.Context, request *SendLocation) (*ResultMessage, error) {
	res, err := c.sendSendLocation(ctx, request)
	return res, err
}

func (c *Client) sendSendLocation(ctx context.Context, request *SendLocation) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendLocation"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendLocation"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendLocationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendLocation"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendLocationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendLocationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendMediaGroup invokes sendMediaGroup operation.
//
// Use this method to send a group of photos, videos, documents or audios as an album. Documents and
// audio files can be only grouped in an album with messages of the same type. On success, an array
// of [Messages](https://core.telegram.org/bots/api#message) that were sent is returned.
//
// POST /sendMediaGroup
func (c *Client) SendMediaGroup(ctx context.Context, request *SendMediaGroup) (*ResultArrayOfMessage, error) {
	res, err := c.sendSendMediaGroup(ctx, request)
	return res, err
}

func (c *Client) sendSendMediaGroup(ctx context.Context, request *SendMediaGroup) (res *ResultArrayOfMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendMediaGroup"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendMediaGroup"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendMediaGroupOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendMediaGroup"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendMediaGroupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendMediaGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendMessage invokes sendMessage operation.
//
// Use this method to send text messages. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned.
//
// POST /sendMessage
func (c *Client) SendMessage(ctx context.Context, request *SendMessage) (*ResultMessage, error) {
	res, err := c.sendSendMessage(ctx, request)
	return res, err
}

func (c *Client) sendSendMessage(ctx context.Context, request *SendMessage) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendMessage"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendMessage"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendMessageOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendMessage"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendPaidMedia invokes sendPaidMedia operation.
//
// Use this method to send paid media. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned.
//
// POST /sendPaidMedia
func (c *Client) SendPaidMedia(ctx context.Context, request *SendPaidMedia) (*ResultMessage, error) {
	res, err := c.sendSendPaidMedia(ctx, request)
	return res, err
}

func (c *Client) sendSendPaidMedia(ctx context.Context, request *SendPaidMedia) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendPaidMedia"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendPaidMedia"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendPaidMediaOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendPaidMedia"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendPaidMediaRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendPaidMediaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendPhoto invokes sendPhoto operation.
//
// Use this method to send photos. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned.
//
// POST /sendPhoto
func (c *Client) SendPhoto(ctx context.Context, request *SendPhoto) (*ResultMessage, error) {
	res, err := c.sendSendPhoto(ctx, request)
	return res, err
}

func (c *Client) sendSendPhoto(ctx context.Context, request *SendPhoto) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendPhoto"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendPhoto"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendPhotoOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendPhoto"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendPhotoRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendPhotoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendPoll invokes sendPoll operation.
//
// Use this method to send a native poll. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned.
//
// POST /sendPoll
func (c *Client) SendPoll(ctx context.Context, request *SendPoll) (*ResultMessage, error) {
	res, err := c.sendSendPoll(ctx, request)
	return res, err
}

func (c *Client) sendSendPoll(ctx context.Context, request *SendPoll) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendPoll"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendPoll"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendPollOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendPoll"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendPollRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendPollResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendSticker invokes sendSticker operation.
//
// Use this method to send static .WEBP, [animated](https://telegram.org/blog/animated-stickers) .TGS,
//
//	or [video](https://telegram.org/blog/video-stickers-better-reactions) .WEBM stickers. On success,
//
// the sent [Message](https://core.telegram.org/bots/api#message) is returned.
//
// POST /sendSticker
func (c *Client) SendSticker(ctx context.Context, request *SendSticker) (*ResultMessage, error) {
	res, err := c.sendSendSticker(ctx, request)
	return res, err
}

func (c *Client) sendSendSticker(ctx context.Context, request *SendSticker) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendSticker"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendSticker"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendStickerOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendSticker"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendStickerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendStickerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendVenue invokes sendVenue operation.
//
// Use this method to send information about a venue. On success, the sent [Message](https://core.
// telegram.org/bots/api#message) is returned.
//
// POST /sendVenue
func (c *Client) SendVenue(ctx context.Context, request *SendVenue) (*ResultMessage, error) {
	res, err := c.sendSendVenue(ctx, request)
	return res, err
}

func (c *Client) sendSendVenue(ctx context.Context, request *SendVenue) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendVenue"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendVenue"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendVenueOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendVenue"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendVenueRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendVenueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendVideo invokes sendVideo operation.
//
// Use this method to send video files, Telegram clients support MPEG4 videos (other formats may be
// sent as [Document](https://core.telegram.org/bots/api#document)). On success, the sent
// [Message](https://core.telegram.org/bots/api#message) is returned. Bots can currently send video
// files of up to 50 MB in size, this limit may be changed in the future.
//
// POST /sendVideo
func (c *Client) SendVideo(ctx context.Context, request *SendVideo) (*ResultMessage, error) {
	res, err := c.sendSendVideo(ctx, request)
	return res, err
}

func (c *Client) sendSendVideo(ctx context.Context, request *SendVideo) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendVideo"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendVideo"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendVideoOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendVideo"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendVideoRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendVideoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendVideoNote invokes sendVideoNote operation.
//
// As of [v.4.0](https://telegram.org/blog/video-messages-and-telescope), Telegram clients support
// rounded square MPEG4 videos of up to 1 minute long. Use this method to send video messages. On
// success, the sent [Message](https://core.telegram.org/bots/api#message) is returned.
//
// POST /sendVideoNote
func (c *Client) SendVideoNote(ctx context.Context, request *SendVideoNote) (*ResultMessage, error) {
	res, err := c.sendSendVideoNote(ctx, request)
	return res, err
}

func (c *Client) sendSendVideoNote(ctx context.Context, request *SendVideoNote) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendVideoNote"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendVideoNote"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendVideoNoteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendVideoNote"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendVideoNoteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendVideoNoteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendVoice invokes sendVoice operation.
//
// Use this method to send audio files, if you want Telegram clients to display the file as a
// playable voice message. For this to work, your audio must be in an .OGG file encoded with OPUS, or
// in .MP3 format, or in .M4A format (other formats may be sent as [Audio](https://core.telegram.
// org/bots/api#audio) or [Document](https://core.telegram.org/bots/api#document)). On success, the
// sent [Message](https://core.telegram.org/bots/api#message) is returned. Bots can currently send
// voice messages of up to 50 MB in size, this limit may be changed in the future.
//
// POST /sendVoice
func (c *Client) SendVoice(ctx context.Context, request *SendVoice) (*ResultMessage, error) {
	res, err := c.sendSendVoice(ctx, request)
	return res, err
}

func (c *Client) sendSendVoice(ctx context.Context, request *SendVoice) (res *ResultMessage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendVoice"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/sendVoice"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SendVoiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sendVoice"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendVoiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSendVoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetChatAdministratorCustomTitle invokes setChatAdministratorCustomTitle operation.
//
// Use this method to set a custom title for an administrator in a supergroup promoted by the bot.
// Returns _True_ on success.
//
// POST /setChatAdministratorCustomTitle
func (c *Client) SetChatAdministratorCustomTitle(ctx context.Context, request *SetChatAdministratorCustomTitle) (*Result, error) {
	res, err := c.sendSetChatAdministratorCustomTitle(ctx, request)
	return res, err
}

func (c *Client) sendSetChatAdministratorCustomTitle(ctx context.Context, request *SetChatAdministratorCustomTitle) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setChatAdministratorCustomTitle"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setChatAdministratorCustomTitle"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetChatAdministratorCustomTitleOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setChatAdministratorCustomTitle"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetChatAdministratorCustomTitleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetChatAdministratorCustomTitleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetChatDescription invokes setChatDescription operation.
//
// Use this method to change the description of a group, a supergroup or a channel. The bot must be
// an administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns _True_ on success.
//
// POST /setChatDescription
func (c *Client) SetChatDescription(ctx context.Context, request *SetChatDescription) (*Result, error) {
	res, err := c.sendSetChatDescription(ctx, request)
	return res, err
}

func (c *Client) sendSetChatDescription(ctx context.Context, request *SetChatDescription) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setChatDescription"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setChatDescription"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetChatDescriptionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setChatDescription"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetChatDescriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetChatDescriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetChatMenuButton invokes setChatMenuButton operation.
//
// Use this method to change the bot's menu button in a private chat, or the default menu button.
// Returns _True_ on success.
//
// POST /setChatMenuButton
func (c *Client) SetChatMenuButton(ctx context.Context, request OptSetChatMenuButton) (*Result, error) {
	res, err := c.sendSetChatMenuButton(ctx, request)
	return res, err
}

func (c *Client) sendSetChatMenuButton(ctx context.Context, request OptSetChatMenuButton) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setChatMenuButton"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setChatMenuButton"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetChatMenuButtonOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setChatMenuButton"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetChatMenuButtonRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetChatMenuButtonResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetChatPermissions invokes setChatPermissions operation.
//
// Use this method to set default chat permissions for all members. The bot must be an administrator
// in the group or a supergroup for this to work and must have the _can_restrict_members_
// administrator rights. Returns _True_ on success.
//
// POST /setChatPermissions
func (c *Client) SetChatPermissions(ctx context.Context, request *SetChatPermissions) (*Result, error) {
	res, err := c.sendSetChatPermissions(ctx, request)
	return res, err
}

func (c *Client) sendSetChatPermissions(ctx context.Context, request *SetChatPermissions) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setChatPermissions"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setChatPermissions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetChatPermissionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setChatPermissions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetChatPermissionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetChatPermissionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetChatPhoto invokes setChatPhoto operation.
//
// Use this method to set a new profile photo for the chat. Photos can't be changed for private chats.
//
//	The bot must be an administrator in the chat for this to work and must have the appropriate
//
// administrator rights. Returns _True_ on success.
//
// POST /setChatPhoto
func (c *Client) SetChatPhoto(ctx context.Context, request *SetChatPhoto) (*Result, error) {
	res, err := c.sendSetChatPhoto(ctx, request)
	return res, err
}

func (c *Client) sendSetChatPhoto(ctx context.Context, request *SetChatPhoto) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setChatPhoto"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setChatPhoto"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetChatPhotoOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setChatPhoto"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetChatPhotoRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetChatPhotoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetChatStickerSet invokes setChatStickerSet operation.
//
// Use this method to set a new group sticker set for a supergroup. The bot must be an administrator
// in the chat for this to work and must have the appropriate administrator rights. Use the field
// _can_set_sticker_set_ optionally returned in [getChat](https://core.telegram.org/bots/api#getchat)
// requests to check if the bot can use this method. Returns _True_ on success.
//
// POST /setChatStickerSet
func (c *Client) SetChatStickerSet(ctx context.Context, request *SetChatStickerSet) (*Result, error) {
	res, err := c.sendSetChatStickerSet(ctx, request)
	return res, err
}

func (c *Client) sendSetChatStickerSet(ctx context.Context, request *SetChatStickerSet) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setChatStickerSet"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setChatStickerSet"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetChatStickerSetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setChatStickerSet"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetChatStickerSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetChatStickerSetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetChatTitle invokes setChatTitle operation.
//
// Use this method to change the title of a chat. Titles can't be changed for private chats. The bot
// must be an administrator in the chat for this to work and must have the appropriate administrator
// rights. Returns _True_ on success.
//
// POST /setChatTitle
func (c *Client) SetChatTitle(ctx context.Context, request *SetChatTitle) (*Result, error) {
	res, err := c.sendSetChatTitle(ctx, request)
	return res, err
}

func (c *Client) sendSetChatTitle(ctx context.Context, request *SetChatTitle) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setChatTitle"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setChatTitle"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetChatTitleOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setChatTitle"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetChatTitleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetChatTitleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetCustomEmojiStickerSetThumbnail invokes setCustomEmojiStickerSetThumbnail operation.
//
// Use this method to set the thumbnail of a custom emoji sticker set. Returns _True_ on success.
//
// POST /setCustomEmojiStickerSetThumbnail
func (c *Client) SetCustomEmojiStickerSetThumbnail(ctx context.Context, request *SetCustomEmojiStickerSetThumbnail) (*Result, error) {
	res, err := c.sendSetCustomEmojiStickerSetThumbnail(ctx, request)
	return res, err
}

func (c *Client) sendSetCustomEmojiStickerSetThumbnail(ctx context.Context, request *SetCustomEmojiStickerSetThumbnail) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setCustomEmojiStickerSetThumbnail"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setCustomEmojiStickerSetThumbnail"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetCustomEmojiStickerSetThumbnailOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setCustomEmojiStickerSetThumbnail"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetCustomEmojiStickerSetThumbnailRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetCustomEmojiStickerSetThumbnailResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetGameScore invokes setGameScore operation.
//
// Use this method to set the score of the specified user in a game message. On success, if the
// message is not an inline message, the [Message](https://core.telegram.org/bots/api#message) is
// returned, otherwise _True_ is returned. Returns an error, if the new score is not greater than the
// user's current score in the chat and _force_ is _False_.
//
// POST /setGameScore
func (c *Client) SetGameScore(ctx context.Context, request *SetGameScore) (*Result, error) {
	res, err := c.sendSetGameScore(ctx, request)
	return res, err
}

func (c *Client) sendSetGameScore(ctx context.Context, request *SetGameScore) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setGameScore"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setGameScore"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetGameScoreOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setGameScore"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetGameScoreRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetGameScoreResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetMessageReaction invokes setMessageReaction operation.
//
// Use this method to change the chosen reactions on a message. Service messages can't be reacted to.
// Automatically forwarded messages from a channel to its discussion group have the same available
// reactions as messages in the channel. Bots can't use paid reactions. Returns _True_ on success.
//
// POST /setMessageReaction
func (c *Client) SetMessageReaction(ctx context.Context, request *SetMessageReaction) (*Result, error) {
	res, err := c.sendSetMessageReaction(ctx, request)
	return res, err
}

func (c *Client) sendSetMessageReaction(ctx context.Context, request *SetMessageReaction) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setMessageReaction"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setMessageReaction"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetMessageReactionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setMessageReaction"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetMessageReactionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetMessageReactionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetMyCommands invokes setMyCommands operation.
//
// Use this method to change the list of the bot's commands. See [this manual](https://core.telegram.
// org/bots/features#commands) for more details about bot commands. Returns _True_ on success.
//
// POST /setMyCommands
func (c *Client) SetMyCommands(ctx context.Context, request *SetMyCommands) (*Result, error) {
	res, err := c.sendSetMyCommands(ctx, request)
	return res, err
}

func (c *Client) sendSetMyCommands(ctx context.Context, request *SetMyCommands) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setMyCommands"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setMyCommands"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetMyCommandsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setMyCommands"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetMyCommandsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetMyCommandsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetMyDefaultAdministratorRights invokes setMyDefaultAdministratorRights operation.
//
// Use this method to change the default administrator rights requested by the bot when it's added as
// an administrator to groups or channels. These rights will be suggested to users, but they are free
// to modify the list before adding the bot. Returns _True_ on success.
//
// POST /setMyDefaultAdministratorRights
func (c *Client) SetMyDefaultAdministratorRights(ctx context.Context, request OptSetMyDefaultAdministratorRights) (*Result, error) {
	res, err := c.sendSetMyDefaultAdministratorRights(ctx, request)
	return res, err
}

func (c *Client) sendSetMyDefaultAdministratorRights(ctx context.Context, request OptSetMyDefaultAdministratorRights) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setMyDefaultAdministratorRights"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setMyDefaultAdministratorRights"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetMyDefaultAdministratorRightsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setMyDefaultAdministratorRights"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetMyDefaultAdministratorRightsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetMyDefaultAdministratorRightsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetMyDescription invokes setMyDescription operation.
//
// Use this method to change the bot's description, which is shown in the chat with the bot if the
// chat is empty. Returns _True_ on success.
//
// POST /setMyDescription
func (c *Client) SetMyDescription(ctx context.Context, request OptSetMyDescription) (*Result, error) {
	res, err := c.sendSetMyDescription(ctx, request)
	return res, err
}

func (c *Client) sendSetMyDescription(ctx context.Context, request OptSetMyDescription) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setMyDescription"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setMyDescription"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetMyDescriptionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setMyDescription"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetMyDescriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetMyDescriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetMyName invokes setMyName operation.
//
// Use this method to change the bot's name. Returns _True_ on success.
//
// POST /setMyName
func (c *Client) SetMyName(ctx context.Context, request OptSetMyName) (*Result, error) {
	res, err := c.sendSetMyName(ctx, request)
	return res, err
}

func (c *Client) sendSetMyName(ctx context.Context, request OptSetMyName) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setMyName"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setMyName"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetMyNameOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setMyName"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetMyNameRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetMyNameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetMyShortDescription invokes setMyShortDescription operation.
//
// Use this method to change the bot's short description, which is shown on the bot's profile page
// and is sent together with the link when users share the bot. Returns _True_ on success.
//
// POST /setMyShortDescription
func (c *Client) SetMyShortDescription(ctx context.Context, request OptSetMyShortDescription) (*Result, error) {
	res, err := c.sendSetMyShortDescription(ctx, request)
	return res, err
}

func (c *Client) sendSetMyShortDescription(ctx context.Context, request OptSetMyShortDescription) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setMyShortDescription"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setMyShortDescription"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetMyShortDescriptionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setMyShortDescription"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetMyShortDescriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetMyShortDescriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetPassportDataErrors invokes setPassportDataErrors operation.
//
// Use this if the data submitted by the user doesn't satisfy the standards your service requires for
// any reason. For example, if a birthday date seems invalid, a submitted document is blurry, a scan
// shows evidence of tampering, etc. Supply some details in the error message to make sure the user
// knows how to correct the issues.
//
// POST /setPassportDataErrors
func (c *Client) SetPassportDataErrors(ctx context.Context, request *SetPassportDataErrors) (*Result, error) {
	res, err := c.sendSetPassportDataErrors(ctx, request)
	return res, err
}

func (c *Client) sendSetPassportDataErrors(ctx context.Context, request *SetPassportDataErrors) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setPassportDataErrors"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setPassportDataErrors"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetPassportDataErrorsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setPassportDataErrors"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetPassportDataErrorsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetPassportDataErrorsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetStickerEmojiList invokes setStickerEmojiList operation.
//
// Use this method to change the list of emoji assigned to a regular or custom emoji sticker. The
// sticker must belong to a sticker set created by the bot. Returns _True_ on success.
//
// POST /setStickerEmojiList
func (c *Client) SetStickerEmojiList(ctx context.Context, request *SetStickerEmojiList) (*Result, error) {
	res, err := c.sendSetStickerEmojiList(ctx, request)
	return res, err
}

func (c *Client) sendSetStickerEmojiList(ctx context.Context, request *SetStickerEmojiList) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setStickerEmojiList"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setStickerEmojiList"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetStickerEmojiListOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setStickerEmojiList"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetStickerEmojiListRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetStickerEmojiListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetStickerKeywords invokes setStickerKeywords operation.
//
// Use this method to change search keywords assigned to a regular or custom emoji sticker. The
// sticker must belong to a sticker set created by the bot. Returns _True_ on success.
//
// POST /setStickerKeywords
func (c *Client) SetStickerKeywords(ctx context.Context, request *SetStickerKeywords) (*Result, error) {
	res, err := c.sendSetStickerKeywords(ctx, request)
	return res, err
}

func (c *Client) sendSetStickerKeywords(ctx context.Context, request *SetStickerKeywords) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setStickerKeywords"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setStickerKeywords"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetStickerKeywordsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setStickerKeywords"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetStickerKeywordsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetStickerKeywordsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetStickerMaskPosition invokes setStickerMaskPosition operation.
//
// Use this method to change the [mask position](https://core.telegram.org/bots/api#maskposition) of
// a mask sticker. The sticker must belong to a sticker set that was created by the bot. Returns
// _True_ on success.
//
// POST /setStickerMaskPosition
func (c *Client) SetStickerMaskPosition(ctx context.Context, request *SetStickerMaskPosition) (*Result, error) {
	res, err := c.sendSetStickerMaskPosition(ctx, request)
	return res, err
}

func (c *Client) sendSetStickerMaskPosition(ctx context.Context, request *SetStickerMaskPosition) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setStickerMaskPosition"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setStickerMaskPosition"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetStickerMaskPositionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setStickerMaskPosition"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetStickerMaskPositionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetStickerMaskPositionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetStickerPositionInSet invokes setStickerPositionInSet operation.
//
// Use this method to move a sticker in a set created by the bot to a specific position. Returns
// _True_ on success.
//
// POST /setStickerPositionInSet
func (c *Client) SetStickerPositionInSet(ctx context.Context, request *SetStickerPositionInSet) (*Result, error) {
	res, err := c.sendSetStickerPositionInSet(ctx, request)
	return res, err
}

func (c *Client) sendSetStickerPositionInSet(ctx context.Context, request *SetStickerPositionInSet) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setStickerPositionInSet"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setStickerPositionInSet"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetStickerPositionInSetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setStickerPositionInSet"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetStickerPositionInSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetStickerPositionInSetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetStickerSetThumbnail invokes setStickerSetThumbnail operation.
//
// Use this method to set the thumbnail of a regular or mask sticker set. The format of the thumbnail
// file must match the format of the stickers in the set. Returns _True_ on success.
//
// POST /setStickerSetThumbnail
func (c *Client) SetStickerSetThumbnail(ctx context.Context, request *SetStickerSetThumbnail) (*Result, error) {
	res, err := c.sendSetStickerSetThumbnail(ctx, request)
	return res, err
}

func (c *Client) sendSetStickerSetThumbnail(ctx context.Context, request *SetStickerSetThumbnail) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setStickerSetThumbnail"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setStickerSetThumbnail"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetStickerSetThumbnailOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setStickerSetThumbnail"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetStickerSetThumbnailRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetStickerSetThumbnailResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetStickerSetTitle invokes setStickerSetTitle operation.
//
// Use this method to set the title of a created sticker set. Returns _True_ on success.
//
// POST /setStickerSetTitle
func (c *Client) SetStickerSetTitle(ctx context.Context, request *SetStickerSetTitle) (*Result, error) {
	res, err := c.sendSetStickerSetTitle(ctx, request)
	return res, err
}

func (c *Client) sendSetStickerSetTitle(ctx context.Context, request *SetStickerSetTitle) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setStickerSetTitle"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setStickerSetTitle"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetStickerSetTitleOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setStickerSetTitle"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetStickerSetTitleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetStickerSetTitleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetUserEmojiStatus invokes setUserEmojiStatus operation.
//
// Changes the emoji status for a given user that previously allowed the bot to manage their emoji
// status via the Mini App method [requestEmojiStatusAccess](https://core.telegram.
// org/bots/webapps#initializing-mini-apps). Returns _True_ on success.
//
// POST /setUserEmojiStatus
func (c *Client) SetUserEmojiStatus(ctx context.Context, request *SetUserEmojiStatus) (*Result, error) {
	res, err := c.sendSetUserEmojiStatus(ctx, request)
	return res, err
}

func (c *Client) sendSetUserEmojiStatus(ctx context.Context, request *SetUserEmojiStatus) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setUserEmojiStatus"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setUserEmojiStatus"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetUserEmojiStatusOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setUserEmojiStatus"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetUserEmojiStatusRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetUserEmojiStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetWebhook invokes setWebhook operation.
//
// If you'd like to make sure that the webhook was set by you, you can specify secret data in the
// parameter _secret_token_. If specified, the request will contain a header
// `X-Telegram-Bot-Api-Secret-Token` with the secret token as content.
//
// POST /setWebhook
func (c *Client) SetWebhook(ctx context.Context, request *SetWebhook) (*Result, error) {
	res, err := c.sendSetWebhook(ctx, request)
	return res, err
}

func (c *Client) sendSetWebhook(ctx context.Context, request *SetWebhook) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setWebhook"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/setWebhook"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SetWebhookOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/setWebhook"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetWebhookRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSetWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopMessageLiveLocation invokes stopMessageLiveLocation operation.
//
// Use this method to stop updating a live location message before _live_period_ expires. On success,
// if the message is not an inline message, the edited [Message](https://core.telegram.
// org/bots/api#message) is returned, otherwise _True_ is returned.
//
// POST /stopMessageLiveLocation
func (c *Client) StopMessageLiveLocation(ctx context.Context, request *StopMessageLiveLocation) (*ResultMessageOrBoolean, error) {
	res, err := c.sendStopMessageLiveLocation(ctx, request)
	return res, err
}

func (c *Client) sendStopMessageLiveLocation(ctx context.Context, request *StopMessageLiveLocation) (res *ResultMessageOrBoolean, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("stopMessageLiveLocation"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/stopMessageLiveLocation"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, StopMessageLiveLocationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/stopMessageLiveLocation"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopMessageLiveLocationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStopMessageLiveLocationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopPoll invokes stopPoll operation.
//
// Use this method to stop a poll which was sent by the bot. On success, the stopped
// [Poll](https://core.telegram.org/bots/api#poll) is returned.
//
// POST /stopPoll
func (c *Client) StopPoll(ctx context.Context, request *StopPoll) (*ResultPoll, error) {
	res, err := c.sendStopPoll(ctx, request)
	return res, err
}

func (c *Client) sendStopPoll(ctx context.Context, request *StopPoll) (res *ResultPoll, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("stopPoll"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/stopPoll"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, StopPollOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/stopPoll"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopPollRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStopPollResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnbanChatMember invokes unbanChatMember operation.
//
// Use this method to unban a previously banned user in a supergroup or channel. The user will
// **not** return to the group or channel automatically, but will be able to join via link, etc. The
// bot must be an administrator for this to work. By default, this method guarantees that after the
// call the user is not a member of the chat, but will be able to join it. So if the user is a member
// of the chat they will also be **removed** from the chat. If you don't want this, use the parameter
// _only_if_banned_. Returns _True_ on success.
//
// POST /unbanChatMember
func (c *Client) UnbanChatMember(ctx context.Context, request *UnbanChatMember) (*Result, error) {
	res, err := c.sendUnbanChatMember(ctx, request)
	return res, err
}

func (c *Client) sendUnbanChatMember(ctx context.Context, request *UnbanChatMember) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unbanChatMember"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/unbanChatMember"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UnbanChatMemberOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/unbanChatMember"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUnbanChatMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnbanChatMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnbanChatSenderChat invokes unbanChatSenderChat operation.
//
// Use this method to unban a previously banned channel chat in a supergroup or channel. The bot must
// be an administrator for this to work and must have the appropriate administrator rights. Returns
// _True_ on success.
//
// POST /unbanChatSenderChat
func (c *Client) UnbanChatSenderChat(ctx context.Context, request *UnbanChatSenderChat) (*Result, error) {
	res, err := c.sendUnbanChatSenderChat(ctx, request)
	return res, err
}

func (c *Client) sendUnbanChatSenderChat(ctx context.Context, request *UnbanChatSenderChat) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unbanChatSenderChat"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/unbanChatSenderChat"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UnbanChatSenderChatOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/unbanChatSenderChat"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUnbanChatSenderChatRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnbanChatSenderChatResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnhideGeneralForumTopic invokes unhideGeneralForumTopic operation.
//
// Use this method to unhide the 'General' topic in a forum supergroup chat. The bot must be an
// administrator in the chat for this to work and must have the _can_manage_topics_ administrator
// rights. Returns _True_ on success.
//
// POST /unhideGeneralForumTopic
func (c *Client) UnhideGeneralForumTopic(ctx context.Context, request *UnhideGeneralForumTopic) (*Result, error) {
	res, err := c.sendUnhideGeneralForumTopic(ctx, request)
	return res, err
}

func (c *Client) sendUnhideGeneralForumTopic(ctx context.Context, request *UnhideGeneralForumTopic) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unhideGeneralForumTopic"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/unhideGeneralForumTopic"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UnhideGeneralForumTopicOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/unhideGeneralForumTopic"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUnhideGeneralForumTopicRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnhideGeneralForumTopicResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnpinAllChatMessages invokes unpinAllChatMessages operation.
//
// Use this method to clear the list of pinned messages in a chat. If the chat is not a private chat,
// the bot must be an administrator in the chat for this to work and must have the 'can_pin_messages'
// administrator right in a supergroup or 'can_edit_messages' administrator right in a channel.
// Returns _True_ on success.
//
// POST /unpinAllChatMessages
func (c *Client) UnpinAllChatMessages(ctx context.Context, request *UnpinAllChatMessages) (*Result, error) {
	res, err := c.sendUnpinAllChatMessages(ctx, request)
	return res, err
}

func (c *Client) sendUnpinAllChatMessages(ctx context.Context, request *UnpinAllChatMessages) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unpinAllChatMessages"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/unpinAllChatMessages"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UnpinAllChatMessagesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/unpinAllChatMessages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUnpinAllChatMessagesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnpinAllChatMessagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnpinAllForumTopicMessages invokes unpinAllForumTopicMessages operation.
//
// Use this method to clear the list of pinned messages in a forum topic. The bot must be an
// administrator in the chat for this to work and must have the _can_pin_messages_ administrator
// right in the supergroup. Returns _True_ on success.
//
// POST /unpinAllForumTopicMessages
func (c *Client) UnpinAllForumTopicMessages(ctx context.Context, request *UnpinAllForumTopicMessages) (*Result, error) {
	res, err := c.sendUnpinAllForumTopicMessages(ctx, request)
	return res, err
}

func (c *Client) sendUnpinAllForumTopicMessages(ctx context.Context, request *UnpinAllForumTopicMessages) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unpinAllForumTopicMessages"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/unpinAllForumTopicMessages"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UnpinAllForumTopicMessagesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/unpinAllForumTopicMessages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUnpinAllForumTopicMessagesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnpinAllForumTopicMessagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnpinAllGeneralForumTopicMessages invokes unpinAllGeneralForumTopicMessages operation.
//
// Use this method to clear the list of pinned messages in a General forum topic. The bot must be an
// administrator in the chat for this to work and must have the _can_pin_messages_ administrator
// right in the supergroup. Returns _True_ on success.
//
// POST /unpinAllGeneralForumTopicMessages
func (c *Client) UnpinAllGeneralForumTopicMessages(ctx context.Context, request *UnpinAllGeneralForumTopicMessages) (*Result, error) {
	res, err := c.sendUnpinAllGeneralForumTopicMessages(ctx, request)
	return res, err
}

func (c *Client) sendUnpinAllGeneralForumTopicMessages(ctx context.Context, request *UnpinAllGeneralForumTopicMessages) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unpinAllGeneralForumTopicMessages"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/unpinAllGeneralForumTopicMessages"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UnpinAllGeneralForumTopicMessagesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/unpinAllGeneralForumTopicMessages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUnpinAllGeneralForumTopicMessagesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnpinAllGeneralForumTopicMessagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnpinChatMessage invokes unpinChatMessage operation.
//
// Use this method to remove a message from the list of pinned messages in a chat. If the chat is not
// a private chat, the bot must be an administrator in the chat for this to work and must have the
// 'can_pin_messages' administrator right in a supergroup or 'can_edit_messages' administrator right
// in a channel. Returns _True_ on success.
//
// POST /unpinChatMessage
func (c *Client) UnpinChatMessage(ctx context.Context, request *UnpinChatMessage) (*Result, error) {
	res, err := c.sendUnpinChatMessage(ctx, request)
	return res, err
}

func (c *Client) sendUnpinChatMessage(ctx context.Context, request *UnpinChatMessage) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unpinChatMessage"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/unpinChatMessage"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UnpinChatMessageOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/unpinChatMessage"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUnpinChatMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnpinChatMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UploadStickerFile invokes uploadStickerFile operation.
//
// Use this method to upload a file with a sticker for later use in the
// [createNewStickerSet](https://core.telegram.org/bots/api#createnewstickerset),
// [addStickerToSet](https://core.telegram.org/bots/api#addstickertoset), or
// [replaceStickerInSet](https://core.telegram.org/bots/api#replacestickerinset) methods (the file
// can be used multiple times). Returns the uploaded [File](https://core.telegram.org/bots/api#file)
// on success.
//
// POST /uploadStickerFile
func (c *Client) UploadStickerFile(ctx context.Context, request *UploadStickerFile) (*ResultFile, error) {
	res, err := c.sendUploadStickerFile(ctx, request)
	return res, err
}

func (c *Client) sendUploadStickerFile(ctx context.Context, request *UploadStickerFile) (res *ResultFile, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("uploadStickerFile"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/uploadStickerFile"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UploadStickerFileOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/uploadStickerFile"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUploadStickerFileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUploadStickerFileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// VerifyChat invokes verifyChat operation.
//
// Verifies a chat [on behalf of the organization](https://telegram.
// org/verify#third-party-verification) which is represented by the bot. Returns _True_ on success.
//
// POST /verifyChat
func (c *Client) VerifyChat(ctx context.Context, request *VerifyChat) (*Result, error) {
	res, err := c.sendVerifyChat(ctx, request)
	return res, err
}

func (c *Client) sendVerifyChat(ctx context.Context, request *VerifyChat) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("verifyChat"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/verifyChat"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, VerifyChatOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verifyChat"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeVerifyChatRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeVerifyChatResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// VerifyUser invokes verifyUser operation.
//
// Verifies a user [on behalf of the organization](https://telegram.
// org/verify#third-party-verification) which is represented by the bot. Returns _True_ on success.
//
// POST /verifyUser
func (c *Client) VerifyUser(ctx context.Context, request *VerifyUser) (*Result, error) {
	res, err := c.sendVerifyUser(ctx, request)
	return res, err
}

func (c *Client) sendVerifyUser(ctx context.Context, request *VerifyUser) (res *Result, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("verifyUser"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/verifyUser"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, VerifyUserOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verifyUser"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeVerifyUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeVerifyUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
