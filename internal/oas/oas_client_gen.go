// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"context"
	"net/url"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric/instrument/syncint64"
	"go.opentelemetry.io/otel/trace"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	cfg       config
	requests  syncint64.Counter
	errors    syncint64.Counter
	duration  syncint64.Histogram
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...Option) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	c := &Client{
		cfg:       newConfig(opts...),
		serverURL: u,
	}
	if c.requests, err = c.cfg.Meter.SyncInt64().Counter(otelogen.ClientRequestCount); err != nil {
		return nil, err
	}
	if c.errors, err = c.cfg.Meter.SyncInt64().Counter(otelogen.ClientErrorsCount); err != nil {
		return nil, err
	}
	if c.duration, err = c.cfg.Meter.SyncInt64().Histogram(otelogen.ClientDuration); err != nil {
		return nil, err
	}
	return c, nil
}

// AddStickerToSet invokes addStickerToSet operation.
//
// Use this method to add a new sticker to a set created by the bot. You **must** use exactly one of
// the fields _png_sticker_, _tgs_sticker_, or _webm_sticker_. Animated stickers can be added to
// animated sticker sets and only to them. Animated sticker sets can have up to 50 stickers. Static
// sticker sets can have up to 120 stickers. Returns _True_ on success.
//
// POST /addStickerToSet
func (c *Client) AddStickerToSet(ctx context.Context, request AddStickerToSet) (res Result, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addStickerToSet"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AddStickerToSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/addStickerToSet"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeAddStickerToSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddStickerToSetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AnswerCallbackQuery invokes answerCallbackQuery operation.
//
// Use this method to send answers to callback queries sent from [inline keyboards](https://core.
// telegram.org/bots#inline-keyboards-and-on-the-fly-updating). The answer will be displayed to the
// user as a notification at the top of the chat screen or as an alert. On success, _True_ is
// returned.
//
// POST /answerCallbackQuery
func (c *Client) AnswerCallbackQuery(ctx context.Context, request AnswerCallbackQuery) (res Result, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("answerCallbackQuery"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AnswerCallbackQuery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/answerCallbackQuery"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeAnswerCallbackQueryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAnswerCallbackQueryResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AnswerInlineQuery invokes answerInlineQuery operation.
//
// Use this method to send answers to an inline query. On success, _True_ is returned.No more than
// **50** results per query are allowed.
//
// POST /answerInlineQuery
func (c *Client) AnswerInlineQuery(ctx context.Context, request AnswerInlineQuery) (res Result, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("answerInlineQuery"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AnswerInlineQuery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/answerInlineQuery"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeAnswerInlineQueryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAnswerInlineQueryResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AnswerPreCheckoutQuery invokes answerPreCheckoutQuery operation.
//
// Once the user has confirmed their payment and shipping details, the Bot API sends the final
// confirmation in the form of an [Update](https://core.telegram.org/bots/api#update) with the field
// _pre_checkout_query_. Use this method to respond to such pre-checkout queries. On success, _True_
// is returned. **Note:** The Bot API must receive an answer within 10 seconds after the pre-checkout
// query was sent.
//
// POST /answerPreCheckoutQuery
func (c *Client) AnswerPreCheckoutQuery(ctx context.Context, request AnswerPreCheckoutQuery) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("answerPreCheckoutQuery"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AnswerPreCheckoutQuery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/answerPreCheckoutQuery"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeAnswerPreCheckoutQueryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAnswerPreCheckoutQueryResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AnswerShippingQuery invokes answerShippingQuery operation.
//
// If you sent an invoice requesting a shipping address and the parameter _is_flexible_ was specified,
//  the Bot API will send an [Update](https://core.telegram.org/bots/api#update) with a
// _shipping_query_ field to the bot. Use this method to reply to shipping queries. On success,
// _True_ is returned.
//
// POST /answerShippingQuery
func (c *Client) AnswerShippingQuery(ctx context.Context, request AnswerShippingQuery) (res Result, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("answerShippingQuery"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AnswerShippingQuery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/answerShippingQuery"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeAnswerShippingQueryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAnswerShippingQueryResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AnswerWebAppQuery invokes answerWebAppQuery operation.
//
// Use this method to set the result of an interaction with a [Web App](https://core.telegram.
// org/bots/webapps) and send a corresponding message on behalf of the user to the chat from which
// the query originated. On success, a [SentWebAppMessage](https://core.telegram.
// org/bots/api#sentwebappmessage) object is returned.
//
// POST /answerWebAppQuery
func (c *Client) AnswerWebAppQuery(ctx context.Context, request AnswerWebAppQuery) (res Result, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("answerWebAppQuery"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "AnswerWebAppQuery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/answerWebAppQuery"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeAnswerWebAppQueryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAnswerWebAppQueryResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ApproveChatJoinRequest invokes approveChatJoinRequest operation.
//
// Use this method to approve a chat join request. The bot must be an administrator in the chat for
// this to work and must have the _can_invite_users_ administrator right. Returns _True_ on success.
//
// POST /approveChatJoinRequest
func (c *Client) ApproveChatJoinRequest(ctx context.Context, request ApproveChatJoinRequest) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("approveChatJoinRequest"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ApproveChatJoinRequest",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/approveChatJoinRequest"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeApproveChatJoinRequestRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeApproveChatJoinRequestResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BanChatMember invokes banChatMember operation.
//
// Use this method to ban a user in a group, a supergroup or a channel. In the case of supergroups
// and channels, the user will not be able to return to the chat on their own using invite links, etc.
// , unless [unbanned](https://core.telegram.org/bots/api#unbanchatmember) first. The bot must be an
// administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns _True_ on success.
//
// POST /banChatMember
func (c *Client) BanChatMember(ctx context.Context, request BanChatMember) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("banChatMember"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "BanChatMember",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/banChatMember"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeBanChatMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeBanChatMemberResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BanChatSenderChat invokes banChatSenderChat operation.
//
// Use this method to ban a channel chat in a supergroup or a channel. Until the chat is
// [unbanned](https://core.telegram.org/bots/api#unbanchatsenderchat), the owner of the banned chat
// won't be able to send messages on behalf of **any of their channels**. The bot must be an
// administrator in the supergroup or channel for this to work and must have the appropriate
// administrator rights. Returns _True_ on success.
//
// POST /banChatSenderChat
func (c *Client) BanChatSenderChat(ctx context.Context, request BanChatSenderChat) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("banChatSenderChat"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "BanChatSenderChat",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/banChatSenderChat"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeBanChatSenderChatRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeBanChatSenderChatResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Close invokes close operation.
//
// Use this method to close the bot instance before moving it from one local server to another. You
// need to delete the webhook before calling this method to ensure that the bot isn't launched again
// after server restart. The method will return error 429 in the first 10 minutes after the bot is
// launched. Returns _True_ on success. Requires no parameters.
//
// POST /close
func (c *Client) Close(ctx context.Context) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("close"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "Close",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/close"

	r := ht.NewRequest(ctx, "POST", u, nil)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCloseResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CopyMessage invokes copyMessage operation.
//
// Use this method to copy messages of any kind. Service messages and invoice messages can't be
// copied. The method is analogous to the method [forwardMessage](https://core.telegram.
// org/bots/api#forwardmessage), but the copied message doesn't have a link to the original message.
// Returns the [MessageId](https://core.telegram.org/bots/api#messageid) of the sent message on
// success.
//
// POST /copyMessage
func (c *Client) CopyMessage(ctx context.Context, request CopyMessage) (res ResultMessageId, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("copyMessage"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CopyMessage",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/copyMessage"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeCopyMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCopyMessageResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateChatInviteLink invokes createChatInviteLink operation.
//
// Use this method to create an additional invite link for a chat. The bot must be an administrator
// in the chat for this to work and must have the appropriate administrator rights. The link can be
// revoked using the method [revokeChatInviteLink](https://core.telegram.
// org/bots/api#revokechatinvitelink). Returns the new invite link as [ChatInviteLink](https://core.
// telegram.org/bots/api#chatinvitelink) object.
//
// POST /createChatInviteLink
func (c *Client) CreateChatInviteLink(ctx context.Context, request CreateChatInviteLink) (res ResultChatInviteLink, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createChatInviteLink"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateChatInviteLink",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/createChatInviteLink"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeCreateChatInviteLinkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateChatInviteLinkResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateInvoiceLink invokes createInvoiceLink operation.
//
// Use this method to create a link for an invoice. Returns the created invoice link as _String_ on
// success.
//
// POST /createInvoiceLink
func (c *Client) CreateInvoiceLink(ctx context.Context, request CreateInvoiceLink) (res ResultString, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createInvoiceLink"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateInvoiceLink",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/createInvoiceLink"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeCreateInvoiceLinkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateInvoiceLinkResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateNewStickerSet invokes createNewStickerSet operation.
//
// Use this method to create a new sticker set owned by a user. The bot will be able to edit the
// sticker set thus created. You **must** use exactly one of the fields _png_sticker_, _tgs_sticker_,
// or _webm_sticker_. Returns _True_ on success.
//
// POST /createNewStickerSet
func (c *Client) CreateNewStickerSet(ctx context.Context, request CreateNewStickerSet) (res Result, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createNewStickerSet"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateNewStickerSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/createNewStickerSet"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeCreateNewStickerSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateNewStickerSetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeclineChatJoinRequest invokes declineChatJoinRequest operation.
//
// Use this method to decline a chat join request. The bot must be an administrator in the chat for
// this to work and must have the _can_invite_users_ administrator right. Returns _True_ on success.
//
// POST /declineChatJoinRequest
func (c *Client) DeclineChatJoinRequest(ctx context.Context, request DeclineChatJoinRequest) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("declineChatJoinRequest"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "DeclineChatJoinRequest",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/declineChatJoinRequest"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeDeclineChatJoinRequestRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeclineChatJoinRequestResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteChatPhoto invokes deleteChatPhoto operation.
//
// Use this method to delete a chat photo. Photos can't be changed for private chats. The bot must be
// an administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns _True_ on success.
//
// POST /deleteChatPhoto
func (c *Client) DeleteChatPhoto(ctx context.Context, request DeleteChatPhoto) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteChatPhoto"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteChatPhoto",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/deleteChatPhoto"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeDeleteChatPhotoRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteChatPhotoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteChatStickerSet invokes deleteChatStickerSet operation.
//
// Use this method to delete a group sticker set from a supergroup. The bot must be an administrator
// in the chat for this to work and must have the appropriate administrator rights. Use the field
// _can_set_sticker_set_ optionally returned in [getChat](https://core.telegram.org/bots/api#getchat)
// requests to check if the bot can use this method. Returns _True_ on success.
//
// POST /deleteChatStickerSet
func (c *Client) DeleteChatStickerSet(ctx context.Context, request DeleteChatStickerSet) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteChatStickerSet"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteChatStickerSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/deleteChatStickerSet"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeDeleteChatStickerSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteChatStickerSetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteMessage invokes deleteMessage operation.
//
// Use this method to delete a message, including service messages, with the following limitations:-
// A message can only be deleted if it was sent less than 48 hours ago.- A dice message in a private
// chat can only be deleted if it was sent more than 24 hours ago.- Bots can delete outgoing messages
// in private chats, groups, and supergroups.- Bots can delete incoming messages in private chats.-
// Bots granted _can_post_messages_ permissions can delete outgoing messages in channels.- If the bot
// is an administrator of a group, it can delete any message there.- If the bot has
// _can_delete_messages_ permission in a supergroup or a channel, it can delete any message there.
// Returns _True_ on success.
//
// POST /deleteMessage
func (c *Client) DeleteMessage(ctx context.Context, request DeleteMessage) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteMessage"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteMessage",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/deleteMessage"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeDeleteMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteMessageResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteMyCommands invokes deleteMyCommands operation.
//
// Use this method to delete the list of the bot's commands for the given scope and user language.
// After deletion, [higher level commands](https://core.telegram.
// org/bots/api#determining-list-of-commands) will be shown to affected users. Returns _True_ on
// success.
//
// POST /deleteMyCommands
func (c *Client) DeleteMyCommands(ctx context.Context, request OptDeleteMyCommands) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteMyCommands"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteMyCommands",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/deleteMyCommands"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeDeleteMyCommandsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteMyCommandsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteStickerFromSet invokes deleteStickerFromSet operation.
//
// Use this method to delete a sticker from a set created by the bot. Returns _True_ on success.
//
// POST /deleteStickerFromSet
func (c *Client) DeleteStickerFromSet(ctx context.Context, request DeleteStickerFromSet) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteStickerFromSet"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteStickerFromSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/deleteStickerFromSet"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeDeleteStickerFromSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteStickerFromSetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteWebhook invokes deleteWebhook operation.
//
// Use this method to remove webhook integration if you decide to switch back to
// [getUpdates](https://core.telegram.org/bots/api#getupdates). Returns _True_ on success.
//
// POST /deleteWebhook
func (c *Client) DeleteWebhook(ctx context.Context, request OptDeleteWebhook) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteWebhook"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/deleteWebhook"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeDeleteWebhookRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteWebhookResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditChatInviteLink invokes editChatInviteLink operation.
//
// Use this method to edit a non-primary invite link created by the bot. The bot must be an
// administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns the edited invite link as a [ChatInviteLink](https://core.telegram.
// org/bots/api#chatinvitelink) object.
//
// POST /editChatInviteLink
func (c *Client) EditChatInviteLink(ctx context.Context, request EditChatInviteLink) (res ResultChatInviteLink, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("editChatInviteLink"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EditChatInviteLink",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/editChatInviteLink"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeEditChatInviteLinkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditChatInviteLinkResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditMessageCaption invokes editMessageCaption operation.
//
// Use this method to edit captions of messages. On success, if the edited message is not an inline
// message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise
// _True_ is returned.
//
// POST /editMessageCaption
func (c *Client) EditMessageCaption(ctx context.Context, request EditMessageCaption) (res ResultMessageOrBoolean, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("editMessageCaption"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EditMessageCaption",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/editMessageCaption"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeEditMessageCaptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditMessageCaptionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditMessageLiveLocation invokes editMessageLiveLocation operation.
//
// Use this method to edit live location messages. A location can be edited until its _live_period_
// expires or editing is explicitly disabled by a call to [stopMessageLiveLocation](https://core.
// telegram.org/bots/api#stopmessagelivelocation). On success, if the edited message is not an inline
// message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise
// _True_ is returned.
//
// POST /editMessageLiveLocation
func (c *Client) EditMessageLiveLocation(ctx context.Context, request EditMessageLiveLocation) (res ResultMessageOrBoolean, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("editMessageLiveLocation"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EditMessageLiveLocation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/editMessageLiveLocation"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeEditMessageLiveLocationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditMessageLiveLocationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditMessageMedia invokes editMessageMedia operation.
//
// Use this method to edit animation, audio, document, photo, or video messages. If a message is part
// of a message album, then it can be edited only to an audio for audio albums, only to a document
// for document albums and to a photo or a video otherwise. When an inline message is edited, a new
// file can't be uploaded; use a previously uploaded file via its file_id or specify a URL. On
// success, if the edited message is not an inline message, the edited [Message](https://core.
// telegram.org/bots/api#message) is returned, otherwise _True_ is returned.
//
// POST /editMessageMedia
func (c *Client) EditMessageMedia(ctx context.Context, request EditMessageMedia) (res ResultMessageOrBoolean, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("editMessageMedia"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EditMessageMedia",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/editMessageMedia"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeEditMessageMediaRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditMessageMediaResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditMessageReplyMarkup invokes editMessageReplyMarkup operation.
//
// Use this method to edit only the reply markup of messages. On success, if the edited message is
// not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is
// returned, otherwise _True_ is returned.
//
// POST /editMessageReplyMarkup
func (c *Client) EditMessageReplyMarkup(ctx context.Context, request EditMessageReplyMarkup) (res ResultMessageOrBoolean, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("editMessageReplyMarkup"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EditMessageReplyMarkup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/editMessageReplyMarkup"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeEditMessageReplyMarkupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditMessageReplyMarkupResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditMessageText invokes editMessageText operation.
//
// Use this method to edit text and [game](https://core.telegram.org/bots/api#games) messages. On
// success, if the edited message is not an inline message, the edited [Message](https://core.
// telegram.org/bots/api#message) is returned, otherwise _True_ is returned.
//
// POST /editMessageText
func (c *Client) EditMessageText(ctx context.Context, request EditMessageText) (res ResultMessageOrBoolean, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("editMessageText"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "EditMessageText",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/editMessageText"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeEditMessageTextRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditMessageTextResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExportChatInviteLink invokes exportChatInviteLink operation.
//
// Use this method to generate a new primary invite link for a chat; any previously generated primary
// link is revoked. The bot must be an administrator in the chat for this to work and must have the
// appropriate administrator rights. Returns the new invite link as _String_ on success.
//
// POST /exportChatInviteLink
func (c *Client) ExportChatInviteLink(ctx context.Context, request ExportChatInviteLink) (res ResultString, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("exportChatInviteLink"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ExportChatInviteLink",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/exportChatInviteLink"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeExportChatInviteLinkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeExportChatInviteLinkResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ForwardMessage invokes forwardMessage operation.
//
// Use this method to forward messages of any kind. Service messages can't be forwarded. On success,
// the sent [Message](https://core.telegram.org/bots/api#message) is returned.
//
// POST /forwardMessage
func (c *Client) ForwardMessage(ctx context.Context, request ForwardMessage) (res ResultMessage, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("forwardMessage"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ForwardMessage",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/forwardMessage"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeForwardMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeForwardMessageResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChat invokes getChat operation.
//
// Use this method to get up to date information about the chat (current name of the user for
// one-on-one conversations, current username of a user, group or channel, etc.). Returns a
// [Chat](https://core.telegram.org/bots/api#chat) object on success.
//
// POST /getChat
func (c *Client) GetChat(ctx context.Context, request GetChat) (res ResultChat, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getChat"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetChat",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/getChat"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeGetChatRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChatResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChatAdministrators invokes getChatAdministrators operation.
//
// Use this method to get a list of administrators in a chat. On success, returns an Array of
// [ChatMember](https://core.telegram.org/bots/api#chatmember) objects that contains information
// about all chat administrators except other bots. If the chat is a group or a supergroup and no
// administrators were appointed, only the creator will be returned.
//
// POST /getChatAdministrators
func (c *Client) GetChatAdministrators(ctx context.Context, request GetChatAdministrators) (res ResultArrayOfChatMember, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getChatAdministrators"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetChatAdministrators",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/getChatAdministrators"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeGetChatAdministratorsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChatAdministratorsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChatMember invokes getChatMember operation.
//
// Use this method to get information about a member of a chat. Returns a [ChatMember](https://core.
// telegram.org/bots/api#chatmember) object on success.
//
// POST /getChatMember
func (c *Client) GetChatMember(ctx context.Context, request GetChatMember) (res ResultChatMember, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getChatMember"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetChatMember",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/getChatMember"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeGetChatMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChatMemberResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChatMemberCount invokes getChatMemberCount operation.
//
// Use this method to get the number of members in a chat. Returns _Int_ on success.
//
// POST /getChatMemberCount
func (c *Client) GetChatMemberCount(ctx context.Context, request GetChatMemberCount) (res ResultInt, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getChatMemberCount"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetChatMemberCount",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/getChatMemberCount"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeGetChatMemberCountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChatMemberCountResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChatMenuButton invokes getChatMenuButton operation.
//
// Use this method to get the current value of the bot's menu button in a private chat, or the
// default menu button. Returns [MenuButton](https://core.telegram.org/bots/api#menubutton) on
// success.
//
// POST /getChatMenuButton
func (c *Client) GetChatMenuButton(ctx context.Context, request OptGetChatMenuButton) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getChatMenuButton"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetChatMenuButton",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/getChatMenuButton"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeGetChatMenuButtonRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChatMenuButtonResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetFile invokes getFile operation.
//
// Use this method to get basic information about a file and prepare it for downloading. For the
// moment, bots can download files of up to 20MB in size. On success, a [File](https://core.telegram.
// org/bots/api#file) object is returned. The file can then be downloaded via the link `https://api.
// telegram.org/file/bot<token>/<file_path>`, where `<file_path>` is taken from the response. It is
// guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can
// be requested by calling [getFile](https://core.telegram.org/bots/api#getfile) again.
//
// POST /getFile
func (c *Client) GetFile(ctx context.Context, request GetFile) (res ResultFile, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getFile"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetFile",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/getFile"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeGetFileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetFileResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGameHighScores invokes getGameHighScores operation.
//
// Use this method to get data for high score tables. Will return the score of the specified user and
// several of their neighbors in a game. On success, returns an _Array_ of
// [GameHighScore](https://core.telegram.org/bots/api#gamehighscore) objects.
//
// POST /getGameHighScores
func (c *Client) GetGameHighScores(ctx context.Context, request GetGameHighScores) (res ResultArrayOfGameHighScore, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getGameHighScores"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetGameHighScores",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/getGameHighScores"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeGetGameHighScoresRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetGameHighScoresResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMe invokes getMe operation.
//
// A simple method for testing your bot's authentication token. Requires no parameters. Returns basic
// information about the bot in form of a [User](https://core.telegram.org/bots/api#user) object.
//
// POST /getMe
func (c *Client) GetMe(ctx context.Context) (res ResultUser, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getMe"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetMe",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/getMe"

	r := ht.NewRequest(ctx, "POST", u, nil)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMeResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyCommands invokes getMyCommands operation.
//
// Use this method to get the current list of the bot's commands for the given scope and user
// language. Returns Array of [BotCommand](https://core.telegram.org/bots/api#botcommand) on success.
// If commands aren't set, an empty list is returned.
//
// POST /getMyCommands
func (c *Client) GetMyCommands(ctx context.Context, request OptGetMyCommands) (res ResultArrayOfBotCommand, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getMyCommands"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetMyCommands",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/getMyCommands"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeGetMyCommandsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMyCommandsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyDefaultAdministratorRights invokes getMyDefaultAdministratorRights operation.
//
// Use this method to get the current default administrator rights of the bot. Returns
// [ChatAdministratorRights](https://core.telegram.org/bots/api#chatadministratorrights) on success.
//
// POST /getMyDefaultAdministratorRights
func (c *Client) GetMyDefaultAdministratorRights(ctx context.Context, request OptGetMyDefaultAdministratorRights) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getMyDefaultAdministratorRights"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetMyDefaultAdministratorRights",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/getMyDefaultAdministratorRights"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeGetMyDefaultAdministratorRightsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMyDefaultAdministratorRightsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStickerSet invokes getStickerSet operation.
//
// Use this method to get a sticker set. On success, a [StickerSet](https://core.telegram.
// org/bots/api#stickerset) object is returned.
//
// POST /getStickerSet
func (c *Client) GetStickerSet(ctx context.Context, request GetStickerSet) (res ResultStickerSet, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStickerSet"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetStickerSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/getStickerSet"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeGetStickerSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetStickerSetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUpdates invokes getUpdates operation.
//
// Use this method to receive incoming updates using long polling ([wiki](https://en.wikipedia.
// org/wiki/Push_technology#Long_polling)). An Array of [Update](https://core.telegram.
// org/bots/api#update) objects is returned.
//
// POST /getUpdates
func (c *Client) GetUpdates(ctx context.Context, request OptGetUpdates) (res ResultArrayOfUpdate, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getUpdates"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetUpdates",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/getUpdates"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeGetUpdatesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUpdatesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserProfilePhotos invokes getUserProfilePhotos operation.
//
// Use this method to get a list of profile pictures for a user. Returns a
// [UserProfilePhotos](https://core.telegram.org/bots/api#userprofilephotos) object.
//
// POST /getUserProfilePhotos
func (c *Client) GetUserProfilePhotos(ctx context.Context, request GetUserProfilePhotos) (res ResultUserProfilePhotos, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getUserProfilePhotos"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetUserProfilePhotos",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/getUserProfilePhotos"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeGetUserProfilePhotosRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserProfilePhotosResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWebhookInfo invokes getWebhookInfo operation.
//
// Use this method to get current webhook status. Requires no parameters. On success, returns a
// [WebhookInfo](https://core.telegram.org/bots/api#webhookinfo) object. If the bot is using
// [getUpdates](https://core.telegram.org/bots/api#getupdates), will return an object with the _url_
// field empty.
//
// POST /getWebhookInfo
func (c *Client) GetWebhookInfo(ctx context.Context) (res ResultWebhookInfo, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getWebhookInfo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetWebhookInfo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/getWebhookInfo"

	r := ht.NewRequest(ctx, "POST", u, nil)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetWebhookInfoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeaveChat invokes leaveChat operation.
//
// Use this method for your bot to leave a group, supergroup or channel. Returns _True_ on success.
//
// POST /leaveChat
func (c *Client) LeaveChat(ctx context.Context, request LeaveChat) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("leaveChat"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "LeaveChat",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/leaveChat"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeLeaveChatRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLeaveChatResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LogOut invokes logOut operation.
//
// Use this method to log out from the cloud Bot API server before launching the bot locally. You
// **must** log out the bot before running it locally, otherwise there is no guarantee that the bot
// will receive updates. After a successful call, you can immediately log in on a local server, but
// will not be able to log in back to the cloud Bot API server for 10 minutes. Returns _True_ on
// success. Requires no parameters.
//
// POST /logOut
func (c *Client) LogOut(ctx context.Context) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("logOut"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "LogOut",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/logOut"

	r := ht.NewRequest(ctx, "POST", u, nil)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLogOutResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PinChatMessage invokes pinChatMessage operation.
//
// Use this method to add a message to the list of pinned messages in a chat. If the chat is not a
// private chat, the bot must be an administrator in the chat for this to work and must have the
// 'can_pin_messages' administrator right in a supergroup or 'can_edit_messages' administrator right
// in a channel. Returns _True_ on success.
//
// POST /pinChatMessage
func (c *Client) PinChatMessage(ctx context.Context, request PinChatMessage) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pinChatMessage"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PinChatMessage",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/pinChatMessage"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodePinChatMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePinChatMessageResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PromoteChatMember invokes promoteChatMember operation.
//
// Use this method to promote or demote a user in a supergroup or a channel. The bot must be an
// administrator in the chat for this to work and must have the appropriate administrator rights.
// Pass _False_ for all boolean parameters to demote a user. Returns _True_ on success.
//
// POST /promoteChatMember
func (c *Client) PromoteChatMember(ctx context.Context, request PromoteChatMember) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("promoteChatMember"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "PromoteChatMember",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/promoteChatMember"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodePromoteChatMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePromoteChatMemberResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RestrictChatMember invokes restrictChatMember operation.
//
// Use this method to restrict a user in a supergroup. The bot must be an administrator in the
// supergroup for this to work and must have the appropriate administrator rights. Pass _True_ for
// all permissions to lift restrictions from a user. Returns _True_ on success.
//
// POST /restrictChatMember
func (c *Client) RestrictChatMember(ctx context.Context, request RestrictChatMember) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("restrictChatMember"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "RestrictChatMember",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/restrictChatMember"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeRestrictChatMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRestrictChatMemberResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RevokeChatInviteLink invokes revokeChatInviteLink operation.
//
// Use this method to revoke an invite link created by the bot. If the primary link is revoked, a new
// link is automatically generated. The bot must be an administrator in the chat for this to work and
// must have the appropriate administrator rights. Returns the revoked invite link as
// [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object.
//
// POST /revokeChatInviteLink
func (c *Client) RevokeChatInviteLink(ctx context.Context, request RevokeChatInviteLink) (res ResultChatInviteLink, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("revokeChatInviteLink"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "RevokeChatInviteLink",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/revokeChatInviteLink"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeRevokeChatInviteLinkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRevokeChatInviteLinkResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendAnimation invokes sendAnimation operation.
//
// Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On success,
// the sent [Message](https://core.telegram.org/bots/api#message) is returned. Bots can currently
// send animation files of up to 50 MB in size, this limit may be changed in the future.
//
// POST /sendAnimation
func (c *Client) SendAnimation(ctx context.Context, request SendAnimation) (res ResultMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendAnimation"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendAnimation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendAnimation"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendAnimationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendAnimationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendAudio invokes sendAudio operation.
//
// For sending voice messages, use the [sendVoice](https://core.telegram.org/bots/api#sendvoice)
// method instead.
//
// POST /sendAudio
func (c *Client) SendAudio(ctx context.Context, request SendAudio) (res ResultMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendAudio"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendAudio",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendAudio"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendAudioRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendAudioResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendChatAction invokes sendChatAction operation.
//
// We only recommend using this method when a response from the bot will take a **noticeable** amount
// of time to arrive.
//
// POST /sendChatAction
func (c *Client) SendChatAction(ctx context.Context, request SendChatAction) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendChatAction"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendChatAction",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendChatAction"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendChatActionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendChatActionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendContact invokes sendContact operation.
//
// Use this method to send phone contacts. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned.
//
// POST /sendContact
func (c *Client) SendContact(ctx context.Context, request SendContact) (res ResultMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendContact"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendContact",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendContact"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendContactRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendContactResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendDice invokes sendDice operation.
//
// Use this method to send an animated emoji that will display a random value. On success, the sent
// [Message](https://core.telegram.org/bots/api#message) is returned.
//
// POST /sendDice
func (c *Client) SendDice(ctx context.Context, request SendDice) (res ResultMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendDice"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendDice",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendDice"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendDiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendDiceResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendDocument invokes sendDocument operation.
//
// Use this method to send general files. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned. Bots can currently send files of any type of up to 50 MB in
// size, this limit may be changed in the future.
//
// POST /sendDocument
func (c *Client) SendDocument(ctx context.Context, request SendDocument) (res ResultMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendDocument"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendDocument",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendDocument"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendDocumentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendDocumentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendGame invokes sendGame operation.
//
// Use this method to send a game. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned.
//
// POST /sendGame
func (c *Client) SendGame(ctx context.Context, request SendGame) (res ResultMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendGame"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendGame",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendGame"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendGameRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendGameResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendInvoice invokes sendInvoice operation.
//
// Use this method to send invoices. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned.
//
// POST /sendInvoice
func (c *Client) SendInvoice(ctx context.Context, request SendInvoice) (res ResultMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendInvoice"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendInvoice",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendInvoice"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendInvoiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendInvoiceResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendLocation invokes sendLocation operation.
//
// Use this method to send point on the map. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned.
//
// POST /sendLocation
func (c *Client) SendLocation(ctx context.Context, request SendLocation) (res ResultMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendLocation"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendLocation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendLocation"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendLocationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendLocationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendMediaGroup invokes sendMediaGroup operation.
//
// Use this method to send a group of photos, videos, documents or audios as an album. Documents and
// audio files can be only grouped in an album with messages of the same type. On success, an array
// of [Messages](https://core.telegram.org/bots/api#message) that were sent is returned.
//
// POST /sendMediaGroup
func (c *Client) SendMediaGroup(ctx context.Context, request SendMediaGroup) (res ResultArrayOfMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendMediaGroup"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendMediaGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendMediaGroup"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendMediaGroupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendMediaGroupResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendMessage invokes sendMessage operation.
//
// Use this method to send text messages. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned.
//
// POST /sendMessage
func (c *Client) SendMessage(ctx context.Context, request SendMessage) (res ResultMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendMessage"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendMessage",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendMessage"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendMessageResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendPhoto invokes sendPhoto operation.
//
// Use this method to send photos. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned.
//
// POST /sendPhoto
func (c *Client) SendPhoto(ctx context.Context, request SendPhoto) (res ResultMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendPhoto"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendPhoto",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendPhoto"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendPhotoRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendPhotoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendPoll invokes sendPoll operation.
//
// Use this method to send a native poll. On success, the sent [Message](https://core.telegram.
// org/bots/api#message) is returned.
//
// POST /sendPoll
func (c *Client) SendPoll(ctx context.Context, request SendPoll) (res ResultMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendPoll"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendPoll",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendPoll"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendPollRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendPollResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendSticker invokes sendSticker operation.
//
// Use this method to send static .WEBP, [animated](https://telegram.org/blog/animated-stickers) .TGS,
//  or [video](https://telegram.org/blog/video-stickers-better-reactions) .WEBM stickers. On success,
// the sent [Message](https://core.telegram.org/bots/api#message) is returned.
//
// POST /sendSticker
func (c *Client) SendSticker(ctx context.Context, request SendSticker) (res ResultMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendSticker"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendSticker",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendSticker"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendStickerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendStickerResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendVenue invokes sendVenue operation.
//
// Use this method to send information about a venue. On success, the sent [Message](https://core.
// telegram.org/bots/api#message) is returned.
//
// POST /sendVenue
func (c *Client) SendVenue(ctx context.Context, request SendVenue) (res ResultMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendVenue"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendVenue",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendVenue"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendVenueRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendVenueResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendVideo invokes sendVideo operation.
//
// Use this method to send video files, Telegram clients support MPEG4 videos (other formats may be
// sent as [Document](https://core.telegram.org/bots/api#document)). On success, the sent
// [Message](https://core.telegram.org/bots/api#message) is returned. Bots can currently send video
// files of up to 50 MB in size, this limit may be changed in the future.
//
// POST /sendVideo
func (c *Client) SendVideo(ctx context.Context, request SendVideo) (res ResultMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendVideo"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendVideo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendVideo"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendVideoRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendVideoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendVideoNote invokes sendVideoNote operation.
//
// As of [v.4.0](https://telegram.org/blog/video-messages-and-telescope), Telegram clients support
// rounded square MPEG4 videos of up to 1 minute long. Use this method to send video messages. On
// success, the sent [Message](https://core.telegram.org/bots/api#message) is returned.
//
// POST /sendVideoNote
func (c *Client) SendVideoNote(ctx context.Context, request SendVideoNote) (res ResultMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendVideoNote"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendVideoNote",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendVideoNote"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendVideoNoteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendVideoNoteResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendVoice invokes sendVoice operation.
//
// Use this method to send audio files, if you want Telegram clients to display the file as a
// playable voice message. For this to work, your audio must be in an .OGG file encoded with OPUS
// (other formats may be sent as [Audio](https://core.telegram.org/bots/api#audio) or
// [Document](https://core.telegram.org/bots/api#document)). On success, the sent
// [Message](https://core.telegram.org/bots/api#message) is returned. Bots can currently send voice
// messages of up to 50 MB in size, this limit may be changed in the future.
//
// POST /sendVoice
func (c *Client) SendVoice(ctx context.Context, request SendVoice) (res ResultMessage, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sendVoice"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SendVoice",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/sendVoice"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSendVoiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendVoiceResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetChatAdministratorCustomTitle invokes setChatAdministratorCustomTitle operation.
//
// Use this method to set a custom title for an administrator in a supergroup promoted by the bot.
// Returns _True_ on success.
//
// POST /setChatAdministratorCustomTitle
func (c *Client) SetChatAdministratorCustomTitle(ctx context.Context, request SetChatAdministratorCustomTitle) (res Result, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setChatAdministratorCustomTitle"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SetChatAdministratorCustomTitle",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/setChatAdministratorCustomTitle"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSetChatAdministratorCustomTitleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetChatAdministratorCustomTitleResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetChatDescription invokes setChatDescription operation.
//
// Use this method to change the description of a group, a supergroup or a channel. The bot must be
// an administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns _True_ on success.
//
// POST /setChatDescription
func (c *Client) SetChatDescription(ctx context.Context, request SetChatDescription) (res Result, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setChatDescription"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SetChatDescription",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/setChatDescription"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSetChatDescriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetChatDescriptionResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetChatMenuButton invokes setChatMenuButton operation.
//
// Use this method to change the bot's menu button in a private chat, or the default menu button.
// Returns _True_ on success.
//
// POST /setChatMenuButton
func (c *Client) SetChatMenuButton(ctx context.Context, request OptSetChatMenuButton) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setChatMenuButton"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SetChatMenuButton",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/setChatMenuButton"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSetChatMenuButtonRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetChatMenuButtonResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetChatPermissions invokes setChatPermissions operation.
//
// Use this method to set default chat permissions for all members. The bot must be an administrator
// in the group or a supergroup for this to work and must have the _can_restrict_members_
// administrator rights. Returns _True_ on success.
//
// POST /setChatPermissions
func (c *Client) SetChatPermissions(ctx context.Context, request SetChatPermissions) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setChatPermissions"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SetChatPermissions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/setChatPermissions"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSetChatPermissionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetChatPermissionsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetChatPhoto invokes setChatPhoto operation.
//
// Use this method to set a new profile photo for the chat. Photos can't be changed for private chats.
//  The bot must be an administrator in the chat for this to work and must have the appropriate
// administrator rights. Returns _True_ on success.
//
// POST /setChatPhoto
func (c *Client) SetChatPhoto(ctx context.Context, request SetChatPhoto) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setChatPhoto"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SetChatPhoto",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/setChatPhoto"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSetChatPhotoRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetChatPhotoResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetChatStickerSet invokes setChatStickerSet operation.
//
// Use this method to set a new group sticker set for a supergroup. The bot must be an administrator
// in the chat for this to work and must have the appropriate administrator rights. Use the field
// _can_set_sticker_set_ optionally returned in [getChat](https://core.telegram.org/bots/api#getchat)
// requests to check if the bot can use this method. Returns _True_ on success.
//
// POST /setChatStickerSet
func (c *Client) SetChatStickerSet(ctx context.Context, request SetChatStickerSet) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setChatStickerSet"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SetChatStickerSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/setChatStickerSet"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSetChatStickerSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetChatStickerSetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetChatTitle invokes setChatTitle operation.
//
// Use this method to change the title of a chat. Titles can't be changed for private chats. The bot
// must be an administrator in the chat for this to work and must have the appropriate administrator
// rights. Returns _True_ on success.
//
// POST /setChatTitle
func (c *Client) SetChatTitle(ctx context.Context, request SetChatTitle) (res Result, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setChatTitle"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SetChatTitle",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/setChatTitle"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSetChatTitleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetChatTitleResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetGameScore invokes setGameScore operation.
//
// Use this method to set the score of the specified user in a game message. On success, if the
// message is not an inline message, the [Message](https://core.telegram.org/bots/api#message) is
// returned, otherwise _True_ is returned. Returns an error, if the new score is not greater than the
// user's current score in the chat and _force_ is _False_.
//
// POST /setGameScore
func (c *Client) SetGameScore(ctx context.Context, request SetGameScore) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setGameScore"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SetGameScore",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/setGameScore"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSetGameScoreRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetGameScoreResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetMyCommands invokes setMyCommands operation.
//
// Use this method to change the list of the bot's commands. See [](https://core.telegram.
// org/bots#commands)[https://core.telegram.org/bots#commands](https://core.telegram.
// org/bots#commands) for more details about bot commands. Returns _True_ on success.
//
// POST /setMyCommands
func (c *Client) SetMyCommands(ctx context.Context, request SetMyCommands) (res Result, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setMyCommands"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SetMyCommands",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/setMyCommands"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSetMyCommandsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetMyCommandsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetMyDefaultAdministratorRights invokes setMyDefaultAdministratorRights operation.
//
// Use this method to change the default administrator rights requested by the bot when it's added as
// an administrator to groups or channels. These rights will be suggested to users, but they are are
// free to modify the list before adding the bot. Returns _True_ on success.
//
// POST /setMyDefaultAdministratorRights
func (c *Client) SetMyDefaultAdministratorRights(ctx context.Context, request OptSetMyDefaultAdministratorRights) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setMyDefaultAdministratorRights"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SetMyDefaultAdministratorRights",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/setMyDefaultAdministratorRights"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSetMyDefaultAdministratorRightsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetMyDefaultAdministratorRightsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetPassportDataErrors invokes setPassportDataErrors operation.
//
// Use this if the data submitted by the user doesn't satisfy the standards your service requires for
// any reason. For example, if a birthday date seems invalid, a submitted document is blurry, a scan
// shows evidence of tampering, etc. Supply some details in the error message to make sure the user
// knows how to correct the issues.
//
// POST /setPassportDataErrors
func (c *Client) SetPassportDataErrors(ctx context.Context, request SetPassportDataErrors) (res Result, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setPassportDataErrors"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SetPassportDataErrors",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/setPassportDataErrors"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSetPassportDataErrorsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetPassportDataErrorsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetStickerPositionInSet invokes setStickerPositionInSet operation.
//
// Use this method to move a sticker in a set created by the bot to a specific position. Returns
// _True_ on success.
//
// POST /setStickerPositionInSet
func (c *Client) SetStickerPositionInSet(ctx context.Context, request SetStickerPositionInSet) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setStickerPositionInSet"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SetStickerPositionInSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/setStickerPositionInSet"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSetStickerPositionInSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetStickerPositionInSetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetStickerSetThumb invokes setStickerSetThumb operation.
//
// Use this method to set the thumbnail of a sticker set. Animated thumbnails can be set for animated
// sticker sets only. Video thumbnails can be set only for video sticker sets only. Returns _True_ on
// success.
//
// POST /setStickerSetThumb
func (c *Client) SetStickerSetThumb(ctx context.Context, request SetStickerSetThumb) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setStickerSetThumb"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SetStickerSetThumb",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/setStickerSetThumb"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSetStickerSetThumbRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetStickerSetThumbResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetWebhook invokes setWebhook operation.
//
// If you'd like to make sure that the webhook was set by you, you can specify secret data in the
// parameter _secret_token_. If specified, the request will contain a header
// `X-Telegram-Bot-Api-Secret-Token` with the secret token as content.
//
// POST /setWebhook
func (c *Client) SetWebhook(ctx context.Context, request SetWebhook) (res Result, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("setWebhook"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "SetWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/setWebhook"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeSetWebhookRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetWebhookResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopMessageLiveLocation invokes stopMessageLiveLocation operation.
//
// Use this method to stop updating a live location message before _live_period_ expires. On success,
// if the message is not an inline message, the edited [Message](https://core.telegram.
// org/bots/api#message) is returned, otherwise _True_ is returned.
//
// POST /stopMessageLiveLocation
func (c *Client) StopMessageLiveLocation(ctx context.Context, request StopMessageLiveLocation) (res ResultMessageOrBoolean, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("stopMessageLiveLocation"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "StopMessageLiveLocation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/stopMessageLiveLocation"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeStopMessageLiveLocationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStopMessageLiveLocationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopPoll invokes stopPoll operation.
//
// Use this method to stop a poll which was sent by the bot. On success, the stopped
// [Poll](https://core.telegram.org/bots/api#poll) is returned.
//
// POST /stopPoll
func (c *Client) StopPoll(ctx context.Context, request StopPoll) (res ResultPoll, err error) {
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("stopPoll"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "StopPoll",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/stopPoll"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeStopPollRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStopPollResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnbanChatMember invokes unbanChatMember operation.
//
// Use this method to unban a previously banned user in a supergroup or channel. The user will
// **not** return to the group or channel automatically, but will be able to join via link, etc. The
// bot must be an administrator for this to work. By default, this method guarantees that after the
// call the user is not a member of the chat, but will be able to join it. So if the user is a member
// of the chat they will also be **removed** from the chat. If you don't want this, use the parameter
// _only_if_banned_. Returns _True_ on success.
//
// POST /unbanChatMember
func (c *Client) UnbanChatMember(ctx context.Context, request UnbanChatMember) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unbanChatMember"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UnbanChatMember",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/unbanChatMember"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeUnbanChatMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUnbanChatMemberResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnbanChatSenderChat invokes unbanChatSenderChat operation.
//
// Use this method to unban a previously banned channel chat in a supergroup or channel. The bot must
// be an administrator for this to work and must have the appropriate administrator rights. Returns
// _True_ on success.
//
// POST /unbanChatSenderChat
func (c *Client) UnbanChatSenderChat(ctx context.Context, request UnbanChatSenderChat) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unbanChatSenderChat"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UnbanChatSenderChat",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/unbanChatSenderChat"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeUnbanChatSenderChatRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUnbanChatSenderChatResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnpinAllChatMessages invokes unpinAllChatMessages operation.
//
// Use this method to clear the list of pinned messages in a chat. If the chat is not a private chat,
// the bot must be an administrator in the chat for this to work and must have the 'can_pin_messages'
// administrator right in a supergroup or 'can_edit_messages' administrator right in a channel.
// Returns _True_ on success.
//
// POST /unpinAllChatMessages
func (c *Client) UnpinAllChatMessages(ctx context.Context, request UnpinAllChatMessages) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unpinAllChatMessages"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UnpinAllChatMessages",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/unpinAllChatMessages"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeUnpinAllChatMessagesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUnpinAllChatMessagesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnpinChatMessage invokes unpinChatMessage operation.
//
// Use this method to remove a message from the list of pinned messages in a chat. If the chat is not
// a private chat, the bot must be an administrator in the chat for this to work and must have the
// 'can_pin_messages' administrator right in a supergroup or 'can_edit_messages' administrator right
// in a channel. Returns _True_ on success.
//
// POST /unpinChatMessage
func (c *Client) UnpinChatMessage(ctx context.Context, request UnpinChatMessage) (res Result, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unpinChatMessage"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UnpinChatMessage",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/unpinChatMessage"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeUnpinChatMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUnpinChatMessageResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UploadStickerFile invokes uploadStickerFile operation.
//
// Use this method to upload a .PNG file with a sticker for later use in _createNewStickerSet_ and
// _addStickerToSet_ methods (can be used multiple times). Returns the uploaded [File](https://core.
// telegram.org/bots/api#file) on success.
//
// POST /uploadStickerFile
func (c *Client) UploadStickerFile(ctx context.Context, request UploadStickerFile) (res ResultFile, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("uploadStickerFile"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UploadStickerFile",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/uploadStickerFile"

	r := ht.NewRequest(ctx, "POST", u, nil)
	if err := encodeUploadStickerFileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUploadStickerFileResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
