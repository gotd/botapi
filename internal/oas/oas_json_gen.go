// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AddStickerToSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddStickerToSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("sticker")
		s.Sticker.Encode(e)
	}
}

var jsonFieldsNameOfAddStickerToSet = [3]string{
	0: "user_id",
	1: "name",
	2: "sticker",
}

// Decode decodes AddStickerToSet from json.
func (s *AddStickerToSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddStickerToSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "sticker":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Sticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddStickerToSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddStickerToSet) {
					name = jsonFieldsNameOfAddStickerToSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddStickerToSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddStickerToSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Animation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Animation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		e.FieldStart("width")
		e.Int(s.Width)
	}
	{
		e.FieldStart("height")
		e.Int(s.Height)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
	{
		if s.FileName.Set {
			e.FieldStart("file_name")
			s.FileName.Encode(e)
		}
	}
	{
		if s.MimeType.Set {
			e.FieldStart("mime_type")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnimation = [9]string{
	0: "file_id",
	1: "file_unique_id",
	2: "width",
	3: "height",
	4: "duration",
	5: "thumbnail",
	6: "file_name",
	7: "mime_type",
	8: "file_size",
}

// Decode decodes Animation from json.
func (s *Animation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Animation to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "width":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Width = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Height = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "file_name":
			if err := func() error {
				s.FileName.Reset()
				if err := s.FileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_name\"")
			}
		case "mime_type":
			if err := func() error {
				s.MimeType.Reset()
				if err := s.MimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Animation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnimation) {
					name = jsonFieldsNameOfAnimation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Animation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Animation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnswerCallbackQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnswerCallbackQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("callback_query_id")
		e.Str(s.CallbackQueryID)
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.ShowAlert.Set {
			e.FieldStart("show_alert")
			s.ShowAlert.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.CacheTime.Set {
			e.FieldStart("cache_time")
			s.CacheTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnswerCallbackQuery = [5]string{
	0: "callback_query_id",
	1: "text",
	2: "show_alert",
	3: "url",
	4: "cache_time",
}

// Decode decodes AnswerCallbackQuery from json.
func (s *AnswerCallbackQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerCallbackQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "callback_query_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CallbackQueryID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"callback_query_id\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "show_alert":
			if err := func() error {
				s.ShowAlert.Reset()
				if err := s.ShowAlert.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_alert\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "cache_time":
			if err := func() error {
				s.CacheTime.Reset()
				if err := s.CacheTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cache_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnswerCallbackQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnswerCallbackQuery) {
					name = jsonFieldsNameOfAnswerCallbackQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnswerCallbackQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerCallbackQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnswerInlineQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnswerInlineQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("inline_query_id")
		e.Str(s.InlineQueryID)
	}
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.CacheTime.Set {
			e.FieldStart("cache_time")
			s.CacheTime.Encode(e)
		}
	}
	{
		if s.IsPersonal.Set {
			e.FieldStart("is_personal")
			s.IsPersonal.Encode(e)
		}
	}
	{
		if s.NextOffset.Set {
			e.FieldStart("next_offset")
			s.NextOffset.Encode(e)
		}
	}
	{
		if s.Button.Set {
			e.FieldStart("button")
			s.Button.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnswerInlineQuery = [6]string{
	0: "inline_query_id",
	1: "results",
	2: "cache_time",
	3: "is_personal",
	4: "next_offset",
	5: "button",
}

// Decode decodes AnswerInlineQuery from json.
func (s *AnswerInlineQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerInlineQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inline_query_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.InlineQueryID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_query_id\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Results = make([]InlineQueryResult, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InlineQueryResult
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "cache_time":
			if err := func() error {
				s.CacheTime.Reset()
				if err := s.CacheTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cache_time\"")
			}
		case "is_personal":
			if err := func() error {
				s.IsPersonal.Reset()
				if err := s.IsPersonal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_personal\"")
			}
		case "next_offset":
			if err := func() error {
				s.NextOffset.Reset()
				if err := s.NextOffset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_offset\"")
			}
		case "button":
			if err := func() error {
				s.Button.Reset()
				if err := s.Button.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"button\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnswerInlineQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnswerInlineQuery) {
					name = jsonFieldsNameOfAnswerInlineQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnswerInlineQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerInlineQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnswerPreCheckoutQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnswerPreCheckoutQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pre_checkout_query_id")
		e.Str(s.PreCheckoutQueryID)
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
	{
		if s.ErrorMessage.Set {
			e.FieldStart("error_message")
			s.ErrorMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnswerPreCheckoutQuery = [3]string{
	0: "pre_checkout_query_id",
	1: "ok",
	2: "error_message",
}

// Decode decodes AnswerPreCheckoutQuery from json.
func (s *AnswerPreCheckoutQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerPreCheckoutQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pre_checkout_query_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PreCheckoutQueryID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pre_checkout_query_id\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		case "error_message":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnswerPreCheckoutQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnswerPreCheckoutQuery) {
					name = jsonFieldsNameOfAnswerPreCheckoutQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnswerPreCheckoutQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerPreCheckoutQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnswerShippingQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnswerShippingQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("shipping_query_id")
		e.Str(s.ShippingQueryID)
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
	{
		if s.ShippingOptions != nil {
			e.FieldStart("shipping_options")
			e.ArrStart()
			for _, elem := range s.ShippingOptions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ErrorMessage.Set {
			e.FieldStart("error_message")
			s.ErrorMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnswerShippingQuery = [4]string{
	0: "shipping_query_id",
	1: "ok",
	2: "shipping_options",
	3: "error_message",
}

// Decode decodes AnswerShippingQuery from json.
func (s *AnswerShippingQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerShippingQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shipping_query_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ShippingQueryID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shipping_query_id\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		case "shipping_options":
			if err := func() error {
				s.ShippingOptions = make([]ShippingOption, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ShippingOption
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ShippingOptions = append(s.ShippingOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shipping_options\"")
			}
		case "error_message":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnswerShippingQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnswerShippingQuery) {
					name = jsonFieldsNameOfAnswerShippingQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnswerShippingQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerShippingQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnswerWebAppQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnswerWebAppQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("web_app_query_id")
		e.Str(s.WebAppQueryID)
	}
	{
		e.FieldStart("result")
		s.Result.Encode(e)
	}
}

var jsonFieldsNameOfAnswerWebAppQuery = [2]string{
	0: "web_app_query_id",
	1: "result",
}

// Decode decodes AnswerWebAppQuery from json.
func (s *AnswerWebAppQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerWebAppQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "web_app_query_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.WebAppQueryID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"web_app_query_id\"")
			}
		case "result":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnswerWebAppQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnswerWebAppQuery) {
					name = jsonFieldsNameOfAnswerWebAppQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnswerWebAppQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerWebAppQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApproveChatJoinRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApproveChatJoinRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
}

var jsonFieldsNameOfApproveChatJoinRequest = [2]string{
	0: "chat_id",
	1: "user_id",
}

// Decode decodes ApproveChatJoinRequest from json.
func (s *ApproveChatJoinRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApproveChatJoinRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApproveChatJoinRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApproveChatJoinRequest) {
					name = jsonFieldsNameOfApproveChatJoinRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApproveChatJoinRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApproveChatJoinRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Audio) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Audio) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
	{
		if s.Performer.Set {
			e.FieldStart("performer")
			s.Performer.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.FileName.Set {
			e.FieldStart("file_name")
			s.FileName.Encode(e)
		}
	}
	{
		if s.MimeType.Set {
			e.FieldStart("mime_type")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
}

var jsonFieldsNameOfAudio = [9]string{
	0: "file_id",
	1: "file_unique_id",
	2: "duration",
	3: "performer",
	4: "title",
	5: "file_name",
	6: "mime_type",
	7: "file_size",
	8: "thumbnail",
}

// Decode decodes Audio from json.
func (s *Audio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Audio to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "performer":
			if err := func() error {
				s.Performer.Reset()
				if err := s.Performer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performer\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "file_name":
			if err := func() error {
				s.FileName.Reset()
				if err := s.FileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_name\"")
			}
		case "mime_type":
			if err := func() error {
				s.MimeType.Reset()
				if err := s.MimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Audio")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAudio) {
					name = jsonFieldsNameOfAudio[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Audio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Audio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BackgroundFill as json.
func (s BackgroundFill) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s BackgroundFill) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case BackgroundFillFreeformGradientBackgroundFill:
		e.FieldStart("type")
		e.Str("BackgroundFillFreeformGradient")
		{
			s := s.BackgroundFillFreeformGradient
			{
				e.FieldStart("colors")
				e.ArrStart()
				for _, elem := range s.Colors {
					e.Int(elem)
				}
				e.ArrEnd()
			}
		}
	case BackgroundFillGradientBackgroundFill:
		e.FieldStart("type")
		e.Str("BackgroundFillGradient")
		{
			s := s.BackgroundFillGradient
			{
				e.FieldStart("top_color")
				e.Int(s.TopColor)
			}
			{
				e.FieldStart("bottom_color")
				e.Int(s.BottomColor)
			}
			{
				e.FieldStart("rotation_angle")
				e.Int(s.RotationAngle)
			}
		}
	case BackgroundFillSolidBackgroundFill:
		e.FieldStart("type")
		e.Str("BackgroundFillSolid")
		{
			s := s.BackgroundFillSolid
			{
				e.FieldStart("color")
				e.Int(s.Color)
			}
		}
	}
}

// Decode decodes BackgroundFill from json.
func (s *BackgroundFill) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackgroundFill to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "BackgroundFillFreeformGradient":
					s.Type = BackgroundFillFreeformGradientBackgroundFill
					found = true
				case "BackgroundFillGradient":
					s.Type = BackgroundFillGradientBackgroundFill
					found = true
				case "BackgroundFillSolid":
					s.Type = BackgroundFillSolidBackgroundFill
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case BackgroundFillSolidBackgroundFill:
		if err := s.BackgroundFillSolid.Decode(d); err != nil {
			return err
		}
	case BackgroundFillGradientBackgroundFill:
		if err := s.BackgroundFillGradient.Decode(d); err != nil {
			return err
		}
	case BackgroundFillFreeformGradientBackgroundFill:
		if err := s.BackgroundFillFreeformGradient.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BackgroundFill) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackgroundFill) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BackgroundFillFreeformGradient) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BackgroundFillFreeformGradient) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("colors")
		e.ArrStart()
		for _, elem := range s.Colors {
			e.Int(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBackgroundFillFreeformGradient = [2]string{
	0: "type",
	1: "colors",
}

// Decode decodes BackgroundFillFreeformGradient from json.
func (s *BackgroundFillFreeformGradient) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackgroundFillFreeformGradient to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "colors":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Colors = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Colors = append(s.Colors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"colors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BackgroundFillFreeformGradient")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBackgroundFillFreeformGradient) {
					name = jsonFieldsNameOfBackgroundFillFreeformGradient[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BackgroundFillFreeformGradient) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackgroundFillFreeformGradient) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BackgroundFillGradient) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BackgroundFillGradient) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("top_color")
		e.Int(s.TopColor)
	}
	{
		e.FieldStart("bottom_color")
		e.Int(s.BottomColor)
	}
	{
		e.FieldStart("rotation_angle")
		e.Int(s.RotationAngle)
	}
}

var jsonFieldsNameOfBackgroundFillGradient = [4]string{
	0: "type",
	1: "top_color",
	2: "bottom_color",
	3: "rotation_angle",
}

// Decode decodes BackgroundFillGradient from json.
func (s *BackgroundFillGradient) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackgroundFillGradient to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "top_color":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TopColor = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_color\"")
			}
		case "bottom_color":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.BottomColor = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bottom_color\"")
			}
		case "rotation_angle":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.RotationAngle = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rotation_angle\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BackgroundFillGradient")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBackgroundFillGradient) {
					name = jsonFieldsNameOfBackgroundFillGradient[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BackgroundFillGradient) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackgroundFillGradient) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BackgroundFillSolid) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BackgroundFillSolid) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("color")
		e.Int(s.Color)
	}
}

var jsonFieldsNameOfBackgroundFillSolid = [2]string{
	0: "type",
	1: "color",
}

// Decode decodes BackgroundFillSolid from json.
func (s *BackgroundFillSolid) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackgroundFillSolid to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "color":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Color = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BackgroundFillSolid")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBackgroundFillSolid) {
					name = jsonFieldsNameOfBackgroundFillSolid[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BackgroundFillSolid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackgroundFillSolid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BackgroundType as json.
func (s BackgroundType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s BackgroundType) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case BackgroundTypeChatThemeBackgroundType:
		e.FieldStart("type")
		e.Str("BackgroundTypeChatTheme")
		{
			s := s.BackgroundTypeChatTheme
			{
				e.FieldStart("theme_name")
				e.Str(s.ThemeName)
			}
		}
	case BackgroundTypeFillBackgroundType:
		e.FieldStart("type")
		e.Str("BackgroundTypeFill")
		{
			s := s.BackgroundTypeFill
			{
				e.FieldStart("fill")
				s.Fill.Encode(e)
			}
			{
				e.FieldStart("dark_theme_dimming")
				e.Int(s.DarkThemeDimming)
			}
		}
	case BackgroundTypePatternBackgroundType:
		e.FieldStart("type")
		e.Str("BackgroundTypePattern")
		{
			s := s.BackgroundTypePattern
			{
				e.FieldStart("document")
				s.Document.Encode(e)
			}
			{
				e.FieldStart("fill")
				s.Fill.Encode(e)
			}
			{
				e.FieldStart("intensity")
				e.Int(s.Intensity)
			}
			{
				if s.IsInverted.Set {
					e.FieldStart("is_inverted")
					s.IsInverted.Encode(e)
				}
			}
			{
				if s.IsMoving.Set {
					e.FieldStart("is_moving")
					s.IsMoving.Encode(e)
				}
			}
		}
	case BackgroundTypeWallpaperBackgroundType:
		e.FieldStart("type")
		e.Str("BackgroundTypeWallpaper")
		{
			s := s.BackgroundTypeWallpaper
			{
				e.FieldStart("document")
				s.Document.Encode(e)
			}
			{
				e.FieldStart("dark_theme_dimming")
				e.Int(s.DarkThemeDimming)
			}
			{
				if s.IsBlurred.Set {
					e.FieldStart("is_blurred")
					s.IsBlurred.Encode(e)
				}
			}
			{
				if s.IsMoving.Set {
					e.FieldStart("is_moving")
					s.IsMoving.Encode(e)
				}
			}
		}
	}
}

// Decode decodes BackgroundType from json.
func (s *BackgroundType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackgroundType to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "BackgroundTypeChatTheme":
					s.Type = BackgroundTypeChatThemeBackgroundType
					found = true
				case "BackgroundTypeFill":
					s.Type = BackgroundTypeFillBackgroundType
					found = true
				case "BackgroundTypePattern":
					s.Type = BackgroundTypePatternBackgroundType
					found = true
				case "BackgroundTypeWallpaper":
					s.Type = BackgroundTypeWallpaperBackgroundType
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case BackgroundTypeFillBackgroundType:
		if err := s.BackgroundTypeFill.Decode(d); err != nil {
			return err
		}
	case BackgroundTypeWallpaperBackgroundType:
		if err := s.BackgroundTypeWallpaper.Decode(d); err != nil {
			return err
		}
	case BackgroundTypePatternBackgroundType:
		if err := s.BackgroundTypePattern.Decode(d); err != nil {
			return err
		}
	case BackgroundTypeChatThemeBackgroundType:
		if err := s.BackgroundTypeChatTheme.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BackgroundType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackgroundType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BackgroundTypeChatTheme) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BackgroundTypeChatTheme) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("theme_name")
		e.Str(s.ThemeName)
	}
}

var jsonFieldsNameOfBackgroundTypeChatTheme = [2]string{
	0: "type",
	1: "theme_name",
}

// Decode decodes BackgroundTypeChatTheme from json.
func (s *BackgroundTypeChatTheme) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackgroundTypeChatTheme to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "theme_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ThemeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"theme_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BackgroundTypeChatTheme")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBackgroundTypeChatTheme) {
					name = jsonFieldsNameOfBackgroundTypeChatTheme[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BackgroundTypeChatTheme) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackgroundTypeChatTheme) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BackgroundTypeFill) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BackgroundTypeFill) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("fill")
		s.Fill.Encode(e)
	}
	{
		e.FieldStart("dark_theme_dimming")
		e.Int(s.DarkThemeDimming)
	}
}

var jsonFieldsNameOfBackgroundTypeFill = [3]string{
	0: "type",
	1: "fill",
	2: "dark_theme_dimming",
}

// Decode decodes BackgroundTypeFill from json.
func (s *BackgroundTypeFill) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackgroundTypeFill to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "fill":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Fill.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fill\"")
			}
		case "dark_theme_dimming":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DarkThemeDimming = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dark_theme_dimming\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BackgroundTypeFill")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBackgroundTypeFill) {
					name = jsonFieldsNameOfBackgroundTypeFill[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BackgroundTypeFill) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackgroundTypeFill) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BackgroundTypePattern) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BackgroundTypePattern) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("document")
		s.Document.Encode(e)
	}
	{
		e.FieldStart("fill")
		s.Fill.Encode(e)
	}
	{
		e.FieldStart("intensity")
		e.Int(s.Intensity)
	}
	{
		if s.IsInverted.Set {
			e.FieldStart("is_inverted")
			s.IsInverted.Encode(e)
		}
	}
	{
		if s.IsMoving.Set {
			e.FieldStart("is_moving")
			s.IsMoving.Encode(e)
		}
	}
}

var jsonFieldsNameOfBackgroundTypePattern = [6]string{
	0: "type",
	1: "document",
	2: "fill",
	3: "intensity",
	4: "is_inverted",
	5: "is_moving",
}

// Decode decodes BackgroundTypePattern from json.
func (s *BackgroundTypePattern) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackgroundTypePattern to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "document":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Document.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document\"")
			}
		case "fill":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Fill.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fill\"")
			}
		case "intensity":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Intensity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"intensity\"")
			}
		case "is_inverted":
			if err := func() error {
				s.IsInverted.Reset()
				if err := s.IsInverted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_inverted\"")
			}
		case "is_moving":
			if err := func() error {
				s.IsMoving.Reset()
				if err := s.IsMoving.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_moving\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BackgroundTypePattern")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBackgroundTypePattern) {
					name = jsonFieldsNameOfBackgroundTypePattern[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BackgroundTypePattern) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackgroundTypePattern) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BackgroundTypeWallpaper) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BackgroundTypeWallpaper) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("document")
		s.Document.Encode(e)
	}
	{
		e.FieldStart("dark_theme_dimming")
		e.Int(s.DarkThemeDimming)
	}
	{
		if s.IsBlurred.Set {
			e.FieldStart("is_blurred")
			s.IsBlurred.Encode(e)
		}
	}
	{
		if s.IsMoving.Set {
			e.FieldStart("is_moving")
			s.IsMoving.Encode(e)
		}
	}
}

var jsonFieldsNameOfBackgroundTypeWallpaper = [5]string{
	0: "type",
	1: "document",
	2: "dark_theme_dimming",
	3: "is_blurred",
	4: "is_moving",
}

// Decode decodes BackgroundTypeWallpaper from json.
func (s *BackgroundTypeWallpaper) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackgroundTypeWallpaper to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "document":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Document.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document\"")
			}
		case "dark_theme_dimming":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DarkThemeDimming = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dark_theme_dimming\"")
			}
		case "is_blurred":
			if err := func() error {
				s.IsBlurred.Reset()
				if err := s.IsBlurred.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_blurred\"")
			}
		case "is_moving":
			if err := func() error {
				s.IsMoving.Reset()
				if err := s.IsMoving.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_moving\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BackgroundTypeWallpaper")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBackgroundTypeWallpaper) {
					name = jsonFieldsNameOfBackgroundTypeWallpaper[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BackgroundTypeWallpaper) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackgroundTypeWallpaper) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BanChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BanChatMember) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		if s.UntilDate.Set {
			e.FieldStart("until_date")
			s.UntilDate.Encode(e)
		}
	}
	{
		if s.RevokeMessages.Set {
			e.FieldStart("revoke_messages")
			s.RevokeMessages.Encode(e)
		}
	}
}

var jsonFieldsNameOfBanChatMember = [4]string{
	0: "chat_id",
	1: "user_id",
	2: "until_date",
	3: "revoke_messages",
}

// Decode decodes BanChatMember from json.
func (s *BanChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BanChatMember to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "until_date":
			if err := func() error {
				s.UntilDate.Reset()
				if err := s.UntilDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"until_date\"")
			}
		case "revoke_messages":
			if err := func() error {
				s.RevokeMessages.Reset()
				if err := s.RevokeMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revoke_messages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BanChatMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBanChatMember) {
					name = jsonFieldsNameOfBanChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BanChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BanChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BanChatSenderChat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BanChatSenderChat) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("sender_chat_id")
		e.Int64(s.SenderChatID)
	}
}

var jsonFieldsNameOfBanChatSenderChat = [2]string{
	0: "chat_id",
	1: "sender_chat_id",
}

// Decode decodes BanChatSenderChat from json.
func (s *BanChatSenderChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BanChatSenderChat to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "sender_chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.SenderChatID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sender_chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BanChatSenderChat")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBanChatSenderChat) {
					name = jsonFieldsNameOfBanChatSenderChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BanChatSenderChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BanChatSenderChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotCommand) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotCommand) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("command")
		e.Str(s.Command)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfBotCommand = [2]string{
	0: "command",
	1: "description",
}

// Decode decodes BotCommand from json.
func (s *BotCommand) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommand to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "command":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Command = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotCommand")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommand) {
					name = jsonFieldsNameOfBotCommand[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotCommand) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommand) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BotCommandScope as json.
func (s BotCommandScope) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s BotCommandScope) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case BotCommandScopeAllChatAdministratorsBotCommandScope:
		e.FieldStart("type")
		e.Str("all_chat_administrators")
	case BotCommandScopeAllGroupChatsBotCommandScope:
		e.FieldStart("type")
		e.Str("all_group_chats")
	case BotCommandScopeAllPrivateChatsBotCommandScope:
		e.FieldStart("type")
		e.Str("all_private_chats")
	case BotCommandScopeChatBotCommandScope:
		e.FieldStart("type")
		e.Str("chat")
		{
			s := s.BotCommandScopeChat
			{
				e.FieldStart("chat_id")
				s.ChatID.Encode(e)
			}
		}
	case BotCommandScopeChatAdministratorsBotCommandScope:
		e.FieldStart("type")
		e.Str("chat_administrators")
		{
			s := s.BotCommandScopeChatAdministrators
			{
				e.FieldStart("chat_id")
				s.ChatID.Encode(e)
			}
		}
	case BotCommandScopeChatMemberBotCommandScope:
		e.FieldStart("type")
		e.Str("chat_member")
		{
			s := s.BotCommandScopeChatMember
			{
				e.FieldStart("chat_id")
				s.ChatID.Encode(e)
			}
			{
				e.FieldStart("user_id")
				e.Int64(s.UserID)
			}
		}
	case BotCommandScopeDefaultBotCommandScope:
		e.FieldStart("type")
		e.Str("default")
	}
}

// Decode decodes BotCommandScope from json.
func (s *BotCommandScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommandScope to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "all_chat_administrators":
					s.Type = BotCommandScopeAllChatAdministratorsBotCommandScope
					found = true
				case "all_group_chats":
					s.Type = BotCommandScopeAllGroupChatsBotCommandScope
					found = true
				case "all_private_chats":
					s.Type = BotCommandScopeAllPrivateChatsBotCommandScope
					found = true
				case "chat":
					s.Type = BotCommandScopeChatBotCommandScope
					found = true
				case "chat_administrators":
					s.Type = BotCommandScopeChatAdministratorsBotCommandScope
					found = true
				case "chat_member":
					s.Type = BotCommandScopeChatMemberBotCommandScope
					found = true
				case "default":
					s.Type = BotCommandScopeDefaultBotCommandScope
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case BotCommandScopeDefaultBotCommandScope:
		if err := s.BotCommandScopeDefault.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeAllPrivateChatsBotCommandScope:
		if err := s.BotCommandScopeAllPrivateChats.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeAllGroupChatsBotCommandScope:
		if err := s.BotCommandScopeAllGroupChats.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeAllChatAdministratorsBotCommandScope:
		if err := s.BotCommandScopeAllChatAdministrators.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeChatBotCommandScope:
		if err := s.BotCommandScopeChat.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeChatAdministratorsBotCommandScope:
		if err := s.BotCommandScopeChatAdministrators.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeChatMemberBotCommandScope:
		if err := s.BotCommandScopeChatMember.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BotCommandScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommandScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotCommandScopeAllChatAdministrators) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotCommandScopeAllChatAdministrators) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfBotCommandScopeAllChatAdministrators = [1]string{
	0: "type",
}

// Decode decodes BotCommandScopeAllChatAdministrators from json.
func (s *BotCommandScopeAllChatAdministrators) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommandScopeAllChatAdministrators to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotCommandScopeAllChatAdministrators")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeAllChatAdministrators) {
					name = jsonFieldsNameOfBotCommandScopeAllChatAdministrators[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotCommandScopeAllChatAdministrators) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommandScopeAllChatAdministrators) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotCommandScopeAllGroupChats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotCommandScopeAllGroupChats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfBotCommandScopeAllGroupChats = [1]string{
	0: "type",
}

// Decode decodes BotCommandScopeAllGroupChats from json.
func (s *BotCommandScopeAllGroupChats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommandScopeAllGroupChats to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotCommandScopeAllGroupChats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeAllGroupChats) {
					name = jsonFieldsNameOfBotCommandScopeAllGroupChats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotCommandScopeAllGroupChats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommandScopeAllGroupChats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotCommandScopeAllPrivateChats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotCommandScopeAllPrivateChats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfBotCommandScopeAllPrivateChats = [1]string{
	0: "type",
}

// Decode decodes BotCommandScopeAllPrivateChats from json.
func (s *BotCommandScopeAllPrivateChats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommandScopeAllPrivateChats to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotCommandScopeAllPrivateChats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeAllPrivateChats) {
					name = jsonFieldsNameOfBotCommandScopeAllPrivateChats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotCommandScopeAllPrivateChats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommandScopeAllPrivateChats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotCommandScopeChat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotCommandScopeChat) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfBotCommandScopeChat = [2]string{
	0: "type",
	1: "chat_id",
}

// Decode decodes BotCommandScopeChat from json.
func (s *BotCommandScopeChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommandScopeChat to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotCommandScopeChat")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeChat) {
					name = jsonFieldsNameOfBotCommandScopeChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotCommandScopeChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommandScopeChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotCommandScopeChatAdministrators) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotCommandScopeChatAdministrators) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfBotCommandScopeChatAdministrators = [2]string{
	0: "type",
	1: "chat_id",
}

// Decode decodes BotCommandScopeChatAdministrators from json.
func (s *BotCommandScopeChatAdministrators) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommandScopeChatAdministrators to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotCommandScopeChatAdministrators")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeChatAdministrators) {
					name = jsonFieldsNameOfBotCommandScopeChatAdministrators[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotCommandScopeChatAdministrators) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommandScopeChatAdministrators) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotCommandScopeChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotCommandScopeChatMember) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
}

var jsonFieldsNameOfBotCommandScopeChatMember = [3]string{
	0: "type",
	1: "chat_id",
	2: "user_id",
}

// Decode decodes BotCommandScopeChatMember from json.
func (s *BotCommandScopeChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommandScopeChatMember to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotCommandScopeChatMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeChatMember) {
					name = jsonFieldsNameOfBotCommandScopeChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotCommandScopeChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommandScopeChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BotCommandScopeDefault) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BotCommandScopeDefault) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfBotCommandScopeDefault = [1]string{
	0: "type",
}

// Decode decodes BotCommandScopeDefault from json.
func (s *BotCommandScopeDefault) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BotCommandScopeDefault to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BotCommandScopeDefault")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeDefault) {
					name = jsonFieldsNameOfBotCommandScopeDefault[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BotCommandScopeDefault) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BotCommandScopeDefault) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BusinessConnection) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BusinessConnection) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("user_chat_id")
		e.Int64(s.UserChatID)
	}
	{
		e.FieldStart("date")
		e.Int(s.Date)
	}
	{
		e.FieldStart("can_reply")
		e.Bool(s.CanReply)
	}
	{
		e.FieldStart("is_enabled")
		e.Bool(s.IsEnabled)
	}
}

var jsonFieldsNameOfBusinessConnection = [6]string{
	0: "id",
	1: "user",
	2: "user_chat_id",
	3: "date",
	4: "can_reply",
	5: "is_enabled",
}

// Decode decodes BusinessConnection from json.
func (s *BusinessConnection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BusinessConnection to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "user_chat_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.UserChatID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_chat_id\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Date = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "can_reply":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.CanReply = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_reply\"")
			}
		case "is_enabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BusinessConnection")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBusinessConnection) {
					name = jsonFieldsNameOfBusinessConnection[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BusinessConnection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BusinessConnection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BusinessMessagesDeleted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BusinessMessagesDeleted) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("business_connection_id")
		e.Str(s.BusinessConnectionID)
	}
	{
		e.FieldStart("chat")
		s.Chat.Encode(e)
	}
	{
		e.FieldStart("message_ids")
		e.ArrStart()
		for _, elem := range s.MessageIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBusinessMessagesDeleted = [3]string{
	0: "business_connection_id",
	1: "chat",
	2: "message_ids",
}

// Decode decodes BusinessMessagesDeleted from json.
func (s *BusinessMessagesDeleted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BusinessMessagesDeleted to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BusinessConnectionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Chat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat\"")
			}
		case "message_ids":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.MessageIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.MessageIds = append(s.MessageIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BusinessMessagesDeleted")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBusinessMessagesDeleted) {
					name = jsonFieldsNameOfBusinessMessagesDeleted[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BusinessMessagesDeleted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BusinessMessagesDeleted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallbackGame) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallbackGame) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCallbackGame = [0]string{}

// Decode decodes CallbackGame from json.
func (s *CallbackGame) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallbackGame to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CallbackGame")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallbackGame) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallbackGame) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallbackQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallbackQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("from")
		s.From.Encode(e)
	}
	{
		if s.Message != nil {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_instance")
		e.Str(s.ChatInstance)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.GameShortName.Set {
			e.FieldStart("game_short_name")
			s.GameShortName.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallbackQuery = [7]string{
	0: "id",
	1: "from",
	2: "message",
	3: "inline_message_id",
	4: "chat_instance",
	5: "data",
	6: "game_short_name",
}

// Decode decodes CallbackQuery from json.
func (s *CallbackQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallbackQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "message":
			if err := func() error {
				s.Message = nil
				var elem MaybeInaccessibleMessage
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Message = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		case "chat_instance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ChatInstance = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_instance\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "game_short_name":
			if err := func() error {
				s.GameShortName.Reset()
				if err := s.GameShortName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_short_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallbackQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCallbackQuery) {
					name = jsonFieldsNameOfCallbackQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallbackQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallbackQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Chat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Chat) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.FirstName.Set {
			e.FieldStart("first_name")
			s.FirstName.Encode(e)
		}
	}
	{
		if s.LastName.Set {
			e.FieldStart("last_name")
			s.LastName.Encode(e)
		}
	}
	{
		if s.IsForum.Set {
			e.FieldStart("is_forum")
			s.IsForum.Encode(e)
		}
	}
	{
		if s.AllMembersAreAdministrators.Set {
			e.FieldStart("all_members_are_administrators")
			s.AllMembersAreAdministrators.Encode(e)
		}
	}
}

var jsonFieldsNameOfChat = [8]string{
	0: "id",
	1: "type",
	2: "title",
	3: "username",
	4: "first_name",
	5: "last_name",
	6: "is_forum",
	7: "all_members_are_administrators",
}

// Decode decodes Chat from json.
func (s *Chat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Chat to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "first_name":
			if err := func() error {
				s.FirstName.Reset()
				if err := s.FirstName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_name\"")
			}
		case "is_forum":
			if err := func() error {
				s.IsForum.Reset()
				if err := s.IsForum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_forum\"")
			}
		case "all_members_are_administrators":
			if err := func() error {
				s.AllMembersAreAdministrators.Reset()
				if err := s.AllMembersAreAdministrators.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"all_members_are_administrators\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Chat")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChat) {
					name = jsonFieldsNameOfChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Chat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Chat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatAdministratorRights) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatAdministratorRights) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("is_anonymous")
		e.Bool(s.IsAnonymous)
	}
	{
		e.FieldStart("can_manage_chat")
		e.Bool(s.CanManageChat)
	}
	{
		e.FieldStart("can_delete_messages")
		e.Bool(s.CanDeleteMessages)
	}
	{
		e.FieldStart("can_manage_video_chats")
		e.Bool(s.CanManageVideoChats)
	}
	{
		e.FieldStart("can_restrict_members")
		e.Bool(s.CanRestrictMembers)
	}
	{
		e.FieldStart("can_promote_members")
		e.Bool(s.CanPromoteMembers)
	}
	{
		e.FieldStart("can_change_info")
		e.Bool(s.CanChangeInfo)
	}
	{
		e.FieldStart("can_invite_users")
		e.Bool(s.CanInviteUsers)
	}
	{
		e.FieldStart("can_post_stories")
		e.Bool(s.CanPostStories)
	}
	{
		e.FieldStart("can_edit_stories")
		e.Bool(s.CanEditStories)
	}
	{
		e.FieldStart("can_delete_stories")
		e.Bool(s.CanDeleteStories)
	}
	{
		if s.CanPostMessages.Set {
			e.FieldStart("can_post_messages")
			s.CanPostMessages.Encode(e)
		}
	}
	{
		if s.CanEditMessages.Set {
			e.FieldStart("can_edit_messages")
			s.CanEditMessages.Encode(e)
		}
	}
	{
		if s.CanPinMessages.Set {
			e.FieldStart("can_pin_messages")
			s.CanPinMessages.Encode(e)
		}
	}
	{
		if s.CanManageTopics.Set {
			e.FieldStart("can_manage_topics")
			s.CanManageTopics.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatAdministratorRights = [15]string{
	0:  "is_anonymous",
	1:  "can_manage_chat",
	2:  "can_delete_messages",
	3:  "can_manage_video_chats",
	4:  "can_restrict_members",
	5:  "can_promote_members",
	6:  "can_change_info",
	7:  "can_invite_users",
	8:  "can_post_stories",
	9:  "can_edit_stories",
	10: "can_delete_stories",
	11: "can_post_messages",
	12: "can_edit_messages",
	13: "can_pin_messages",
	14: "can_manage_topics",
}

// Decode decodes ChatAdministratorRights from json.
func (s *ChatAdministratorRights) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatAdministratorRights to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_anonymous":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsAnonymous = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_anonymous\"")
			}
		case "can_manage_chat":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.CanManageChat = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_manage_chat\"")
			}
		case "can_delete_messages":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.CanDeleteMessages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_delete_messages\"")
			}
		case "can_manage_video_chats":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.CanManageVideoChats = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_manage_video_chats\"")
			}
		case "can_restrict_members":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.CanRestrictMembers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_restrict_members\"")
			}
		case "can_promote_members":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.CanPromoteMembers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_promote_members\"")
			}
		case "can_change_info":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.CanChangeInfo = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_change_info\"")
			}
		case "can_invite_users":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.CanInviteUsers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_invite_users\"")
			}
		case "can_post_stories":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CanPostStories = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_post_stories\"")
			}
		case "can_edit_stories":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.CanEditStories = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_edit_stories\"")
			}
		case "can_delete_stories":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.CanDeleteStories = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_delete_stories\"")
			}
		case "can_post_messages":
			if err := func() error {
				s.CanPostMessages.Reset()
				if err := s.CanPostMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_post_messages\"")
			}
		case "can_edit_messages":
			if err := func() error {
				s.CanEditMessages.Reset()
				if err := s.CanEditMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_edit_messages\"")
			}
		case "can_pin_messages":
			if err := func() error {
				s.CanPinMessages.Reset()
				if err := s.CanPinMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_pin_messages\"")
			}
		case "can_manage_topics":
			if err := func() error {
				s.CanManageTopics.Reset()
				if err := s.CanManageTopics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_manage_topics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatAdministratorRights")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatAdministratorRights) {
					name = jsonFieldsNameOfChatAdministratorRights[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatAdministratorRights) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatAdministratorRights) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatBackground) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatBackground) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfChatBackground = [1]string{
	0: "type",
}

// Decode decodes ChatBackground from json.
func (s *ChatBackground) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatBackground to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatBackground")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatBackground) {
					name = jsonFieldsNameOfChatBackground[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatBackground) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatBackground) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatBoost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatBoost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("boost_id")
		e.Str(s.BoostID)
	}
	{
		e.FieldStart("add_date")
		e.Int(s.AddDate)
	}
	{
		e.FieldStart("expiration_date")
		e.Int(s.ExpirationDate)
	}
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
}

var jsonFieldsNameOfChatBoost = [4]string{
	0: "boost_id",
	1: "add_date",
	2: "expiration_date",
	3: "source",
}

// Decode decodes ChatBoost from json.
func (s *ChatBoost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatBoost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "boost_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BoostID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boost_id\"")
			}
		case "add_date":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AddDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add_date\"")
			}
		case "expiration_date":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ExpirationDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration_date\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatBoost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatBoost) {
					name = jsonFieldsNameOfChatBoost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatBoost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatBoost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatBoostAdded) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatBoostAdded) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("boost_count")
		e.Int(s.BoostCount)
	}
}

var jsonFieldsNameOfChatBoostAdded = [1]string{
	0: "boost_count",
}

// Decode decodes ChatBoostAdded from json.
func (s *ChatBoostAdded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatBoostAdded to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "boost_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.BoostCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boost_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatBoostAdded")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatBoostAdded) {
					name = jsonFieldsNameOfChatBoostAdded[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatBoostAdded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatBoostAdded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatBoostRemoved) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatBoostRemoved) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat")
		s.Chat.Encode(e)
	}
	{
		e.FieldStart("boost_id")
		e.Str(s.BoostID)
	}
	{
		e.FieldStart("remove_date")
		e.Int(s.RemoveDate)
	}
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
}

var jsonFieldsNameOfChatBoostRemoved = [4]string{
	0: "chat",
	1: "boost_id",
	2: "remove_date",
	3: "source",
}

// Decode decodes ChatBoostRemoved from json.
func (s *ChatBoostRemoved) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatBoostRemoved to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Chat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat\"")
			}
		case "boost_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BoostID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boost_id\"")
			}
		case "remove_date":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.RemoveDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_date\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatBoostRemoved")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatBoostRemoved) {
					name = jsonFieldsNameOfChatBoostRemoved[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatBoostRemoved) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatBoostRemoved) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatBoostSource as json.
func (s ChatBoostSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ChatBoostSource) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case ChatBoostSourceGiftCodeChatBoostSource:
		e.FieldStart("source")
		e.Str("ChatBoostSourceGiftCode")
		{
			s := s.ChatBoostSourceGiftCode
			{
				e.FieldStart("user")
				s.User.Encode(e)
			}
		}
	case ChatBoostSourceGiveawayChatBoostSource:
		e.FieldStart("source")
		e.Str("ChatBoostSourceGiveaway")
		{
			s := s.ChatBoostSourceGiveaway
			{
				e.FieldStart("giveaway_message_id")
				e.Int(s.GiveawayMessageID)
			}
			{
				if s.User.Set {
					e.FieldStart("user")
					s.User.Encode(e)
				}
			}
			{
				if s.PrizeStarCount.Set {
					e.FieldStart("prize_star_count")
					s.PrizeStarCount.Encode(e)
				}
			}
			{
				if s.IsUnclaimed.Set {
					e.FieldStart("is_unclaimed")
					s.IsUnclaimed.Encode(e)
				}
			}
		}
	case ChatBoostSourcePremiumChatBoostSource:
		e.FieldStart("source")
		e.Str("ChatBoostSourcePremium")
		{
			s := s.ChatBoostSourcePremium
			{
				e.FieldStart("user")
				s.User.Encode(e)
			}
		}
	}
}

// Decode decodes ChatBoostSource from json.
func (s *ChatBoostSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatBoostSource to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "source":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "ChatBoostSourceGiftCode":
					s.Type = ChatBoostSourceGiftCodeChatBoostSource
					found = true
				case "ChatBoostSourceGiveaway":
					s.Type = ChatBoostSourceGiveawayChatBoostSource
					found = true
				case "ChatBoostSourcePremium":
					s.Type = ChatBoostSourcePremiumChatBoostSource
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ChatBoostSourcePremiumChatBoostSource:
		if err := s.ChatBoostSourcePremium.Decode(d); err != nil {
			return err
		}
	case ChatBoostSourceGiftCodeChatBoostSource:
		if err := s.ChatBoostSourceGiftCode.Decode(d); err != nil {
			return err
		}
	case ChatBoostSourceGiveawayChatBoostSource:
		if err := s.ChatBoostSourceGiveaway.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChatBoostSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatBoostSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatBoostSourceGiftCode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatBoostSourceGiftCode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
}

var jsonFieldsNameOfChatBoostSourceGiftCode = [2]string{
	0: "source",
	1: "user",
}

// Decode decodes ChatBoostSourceGiftCode from json.
func (s *ChatBoostSourceGiftCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatBoostSourceGiftCode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatBoostSourceGiftCode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatBoostSourceGiftCode) {
					name = jsonFieldsNameOfChatBoostSourceGiftCode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatBoostSourceGiftCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatBoostSourceGiftCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatBoostSourceGiveaway) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatBoostSourceGiveaway) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("giveaway_message_id")
		e.Int(s.GiveawayMessageID)
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.PrizeStarCount.Set {
			e.FieldStart("prize_star_count")
			s.PrizeStarCount.Encode(e)
		}
	}
	{
		if s.IsUnclaimed.Set {
			e.FieldStart("is_unclaimed")
			s.IsUnclaimed.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatBoostSourceGiveaway = [5]string{
	0: "source",
	1: "giveaway_message_id",
	2: "user",
	3: "prize_star_count",
	4: "is_unclaimed",
}

// Decode decodes ChatBoostSourceGiveaway from json.
func (s *ChatBoostSourceGiveaway) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatBoostSourceGiveaway to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "giveaway_message_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.GiveawayMessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"giveaway_message_id\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "prize_star_count":
			if err := func() error {
				s.PrizeStarCount.Reset()
				if err := s.PrizeStarCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prize_star_count\"")
			}
		case "is_unclaimed":
			if err := func() error {
				s.IsUnclaimed.Reset()
				if err := s.IsUnclaimed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_unclaimed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatBoostSourceGiveaway")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatBoostSourceGiveaway) {
					name = jsonFieldsNameOfChatBoostSourceGiveaway[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatBoostSourceGiveaway) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatBoostSourceGiveaway) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatBoostSourcePremium) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatBoostSourcePremium) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
}

var jsonFieldsNameOfChatBoostSourcePremium = [2]string{
	0: "source",
	1: "user",
}

// Decode decodes ChatBoostSourcePremium from json.
func (s *ChatBoostSourcePremium) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatBoostSourcePremium to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatBoostSourcePremium")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatBoostSourcePremium) {
					name = jsonFieldsNameOfChatBoostSourcePremium[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatBoostSourcePremium) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatBoostSourcePremium) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatBoostUpdated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatBoostUpdated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat")
		s.Chat.Encode(e)
	}
	{
		e.FieldStart("boost")
		s.Boost.Encode(e)
	}
}

var jsonFieldsNameOfChatBoostUpdated = [2]string{
	0: "chat",
	1: "boost",
}

// Decode decodes ChatBoostUpdated from json.
func (s *ChatBoostUpdated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatBoostUpdated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Chat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat\"")
			}
		case "boost":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Boost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boost\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatBoostUpdated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatBoostUpdated) {
					name = jsonFieldsNameOfChatBoostUpdated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatBoostUpdated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatBoostUpdated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatInviteLink) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("invite_link")
		e.Str(s.InviteLink)
	}
	{
		e.FieldStart("creator")
		s.Creator.Encode(e)
	}
	{
		e.FieldStart("creates_join_request")
		e.Bool(s.CreatesJoinRequest)
	}
	{
		e.FieldStart("is_primary")
		e.Bool(s.IsPrimary)
	}
	{
		e.FieldStart("is_revoked")
		e.Bool(s.IsRevoked)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ExpireDate.Set {
			e.FieldStart("expire_date")
			s.ExpireDate.Encode(e)
		}
	}
	{
		if s.MemberLimit.Set {
			e.FieldStart("member_limit")
			s.MemberLimit.Encode(e)
		}
	}
	{
		if s.PendingJoinRequestCount.Set {
			e.FieldStart("pending_join_request_count")
			s.PendingJoinRequestCount.Encode(e)
		}
	}
	{
		if s.SubscriptionPeriod.Set {
			e.FieldStart("subscription_period")
			s.SubscriptionPeriod.Encode(e)
		}
	}
	{
		if s.SubscriptionPrice.Set {
			e.FieldStart("subscription_price")
			s.SubscriptionPrice.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatInviteLink = [11]string{
	0:  "invite_link",
	1:  "creator",
	2:  "creates_join_request",
	3:  "is_primary",
	4:  "is_revoked",
	5:  "name",
	6:  "expire_date",
	7:  "member_limit",
	8:  "pending_join_request_count",
	9:  "subscription_period",
	10: "subscription_price",
}

// Decode decodes ChatInviteLink from json.
func (s *ChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatInviteLink to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "invite_link":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.InviteLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invite_link\"")
			}
		case "creator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "creates_join_request":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.CreatesJoinRequest = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creates_join_request\"")
			}
		case "is_primary":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsPrimary = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_primary\"")
			}
		case "is_revoked":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsRevoked = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_revoked\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "expire_date":
			if err := func() error {
				s.ExpireDate.Reset()
				if err := s.ExpireDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expire_date\"")
			}
		case "member_limit":
			if err := func() error {
				s.MemberLimit.Reset()
				if err := s.MemberLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"member_limit\"")
			}
		case "pending_join_request_count":
			if err := func() error {
				s.PendingJoinRequestCount.Reset()
				if err := s.PendingJoinRequestCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pending_join_request_count\"")
			}
		case "subscription_period":
			if err := func() error {
				s.SubscriptionPeriod.Reset()
				if err := s.SubscriptionPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_period\"")
			}
		case "subscription_price":
			if err := func() error {
				s.SubscriptionPrice.Reset()
				if err := s.SubscriptionPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatInviteLink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatInviteLink) {
					name = jsonFieldsNameOfChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatInviteLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatInviteLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatJoinRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatJoinRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat")
		s.Chat.Encode(e)
	}
	{
		e.FieldStart("from")
		s.From.Encode(e)
	}
	{
		e.FieldStart("user_chat_id")
		e.Int64(s.UserChatID)
	}
	{
		e.FieldStart("date")
		e.Int(s.Date)
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.InviteLink.Set {
			e.FieldStart("invite_link")
			s.InviteLink.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatJoinRequest = [6]string{
	0: "chat",
	1: "from",
	2: "user_chat_id",
	3: "date",
	4: "bio",
	5: "invite_link",
}

// Decode decodes ChatJoinRequest from json.
func (s *ChatJoinRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatJoinRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Chat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "user_chat_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.UserChatID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_chat_id\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Date = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "invite_link":
			if err := func() error {
				s.InviteLink.Reset()
				if err := s.InviteLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invite_link\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatJoinRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatJoinRequest) {
					name = jsonFieldsNameOfChatJoinRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatJoinRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatJoinRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatMember as json.
func (s ChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ChatMember) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case ChatMemberAdministratorChatMember:
		e.FieldStart("status")
		e.Str("ChatMemberAdministrator")
		{
			s := s.ChatMemberAdministrator
			{
				e.FieldStart("user")
				s.User.Encode(e)
			}
			{
				e.FieldStart("can_be_edited")
				e.Bool(s.CanBeEdited)
			}
			{
				e.FieldStart("is_anonymous")
				e.Bool(s.IsAnonymous)
			}
			{
				e.FieldStart("can_manage_chat")
				e.Bool(s.CanManageChat)
			}
			{
				e.FieldStart("can_delete_messages")
				e.Bool(s.CanDeleteMessages)
			}
			{
				e.FieldStart("can_manage_video_chats")
				e.Bool(s.CanManageVideoChats)
			}
			{
				e.FieldStart("can_restrict_members")
				e.Bool(s.CanRestrictMembers)
			}
			{
				e.FieldStart("can_promote_members")
				e.Bool(s.CanPromoteMembers)
			}
			{
				e.FieldStart("can_change_info")
				e.Bool(s.CanChangeInfo)
			}
			{
				e.FieldStart("can_invite_users")
				e.Bool(s.CanInviteUsers)
			}
			{
				e.FieldStart("can_post_stories")
				e.Bool(s.CanPostStories)
			}
			{
				e.FieldStart("can_edit_stories")
				e.Bool(s.CanEditStories)
			}
			{
				e.FieldStart("can_delete_stories")
				e.Bool(s.CanDeleteStories)
			}
			{
				if s.CanPostMessages.Set {
					e.FieldStart("can_post_messages")
					s.CanPostMessages.Encode(e)
				}
			}
			{
				if s.CanEditMessages.Set {
					e.FieldStart("can_edit_messages")
					s.CanEditMessages.Encode(e)
				}
			}
			{
				if s.CanPinMessages.Set {
					e.FieldStart("can_pin_messages")
					s.CanPinMessages.Encode(e)
				}
			}
			{
				if s.CanManageTopics.Set {
					e.FieldStart("can_manage_topics")
					s.CanManageTopics.Encode(e)
				}
			}
			{
				if s.CustomTitle.Set {
					e.FieldStart("custom_title")
					s.CustomTitle.Encode(e)
				}
			}
		}
	case ChatMemberBannedChatMember:
		e.FieldStart("status")
		e.Str("ChatMemberBanned")
		{
			s := s.ChatMemberBanned
			{
				e.FieldStart("user")
				s.User.Encode(e)
			}
			{
				e.FieldStart("until_date")
				e.Int(s.UntilDate)
			}
		}
	case ChatMemberLeftChatMember:
		e.FieldStart("status")
		e.Str("ChatMemberLeft")
		{
			s := s.ChatMemberLeft
			{
				e.FieldStart("user")
				s.User.Encode(e)
			}
		}
	case ChatMemberMemberChatMember:
		e.FieldStart("status")
		e.Str("ChatMemberMember")
		{
			s := s.ChatMemberMember
			{
				e.FieldStart("user")
				s.User.Encode(e)
			}
			{
				if s.UntilDate.Set {
					e.FieldStart("until_date")
					s.UntilDate.Encode(e)
				}
			}
		}
	case ChatMemberOwnerChatMember:
		e.FieldStart("status")
		e.Str("ChatMemberOwner")
		{
			s := s.ChatMemberOwner
			{
				e.FieldStart("user")
				s.User.Encode(e)
			}
			{
				e.FieldStart("is_anonymous")
				e.Bool(s.IsAnonymous)
			}
			{
				if s.CustomTitle.Set {
					e.FieldStart("custom_title")
					s.CustomTitle.Encode(e)
				}
			}
		}
	case ChatMemberRestrictedChatMember:
		e.FieldStart("status")
		e.Str("ChatMemberRestricted")
		{
			s := s.ChatMemberRestricted
			{
				e.FieldStart("user")
				s.User.Encode(e)
			}
			{
				e.FieldStart("is_member")
				e.Bool(s.IsMember)
			}
			{
				e.FieldStart("can_send_messages")
				e.Bool(s.CanSendMessages)
			}
			{
				e.FieldStart("can_send_audios")
				e.Bool(s.CanSendAudios)
			}
			{
				e.FieldStart("can_send_documents")
				e.Bool(s.CanSendDocuments)
			}
			{
				e.FieldStart("can_send_photos")
				e.Bool(s.CanSendPhotos)
			}
			{
				e.FieldStart("can_send_videos")
				e.Bool(s.CanSendVideos)
			}
			{
				e.FieldStart("can_send_video_notes")
				e.Bool(s.CanSendVideoNotes)
			}
			{
				e.FieldStart("can_send_voice_notes")
				e.Bool(s.CanSendVoiceNotes)
			}
			{
				e.FieldStart("can_send_polls")
				e.Bool(s.CanSendPolls)
			}
			{
				e.FieldStart("can_send_other_messages")
				e.Bool(s.CanSendOtherMessages)
			}
			{
				e.FieldStart("can_add_web_page_previews")
				e.Bool(s.CanAddWebPagePreviews)
			}
			{
				e.FieldStart("can_change_info")
				e.Bool(s.CanChangeInfo)
			}
			{
				e.FieldStart("can_invite_users")
				e.Bool(s.CanInviteUsers)
			}
			{
				e.FieldStart("can_pin_messages")
				e.Bool(s.CanPinMessages)
			}
			{
				e.FieldStart("can_manage_topics")
				e.Bool(s.CanManageTopics)
			}
			{
				e.FieldStart("until_date")
				e.Int(s.UntilDate)
			}
		}
	}
}

// Decode decodes ChatMember from json.
func (s *ChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatMember to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "status":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "ChatMemberAdministrator":
					s.Type = ChatMemberAdministratorChatMember
					found = true
				case "ChatMemberBanned":
					s.Type = ChatMemberBannedChatMember
					found = true
				case "ChatMemberLeft":
					s.Type = ChatMemberLeftChatMember
					found = true
				case "ChatMemberMember":
					s.Type = ChatMemberMemberChatMember
					found = true
				case "ChatMemberOwner":
					s.Type = ChatMemberOwnerChatMember
					found = true
				case "ChatMemberRestricted":
					s.Type = ChatMemberRestrictedChatMember
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ChatMemberOwnerChatMember:
		if err := s.ChatMemberOwner.Decode(d); err != nil {
			return err
		}
	case ChatMemberAdministratorChatMember:
		if err := s.ChatMemberAdministrator.Decode(d); err != nil {
			return err
		}
	case ChatMemberMemberChatMember:
		if err := s.ChatMemberMember.Decode(d); err != nil {
			return err
		}
	case ChatMemberRestrictedChatMember:
		if err := s.ChatMemberRestricted.Decode(d); err != nil {
			return err
		}
	case ChatMemberLeftChatMember:
		if err := s.ChatMemberLeft.Decode(d); err != nil {
			return err
		}
	case ChatMemberBannedChatMember:
		if err := s.ChatMemberBanned.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatMemberAdministrator) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatMemberAdministrator) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("can_be_edited")
		e.Bool(s.CanBeEdited)
	}
	{
		e.FieldStart("is_anonymous")
		e.Bool(s.IsAnonymous)
	}
	{
		e.FieldStart("can_manage_chat")
		e.Bool(s.CanManageChat)
	}
	{
		e.FieldStart("can_delete_messages")
		e.Bool(s.CanDeleteMessages)
	}
	{
		e.FieldStart("can_manage_video_chats")
		e.Bool(s.CanManageVideoChats)
	}
	{
		e.FieldStart("can_restrict_members")
		e.Bool(s.CanRestrictMembers)
	}
	{
		e.FieldStart("can_promote_members")
		e.Bool(s.CanPromoteMembers)
	}
	{
		e.FieldStart("can_change_info")
		e.Bool(s.CanChangeInfo)
	}
	{
		e.FieldStart("can_invite_users")
		e.Bool(s.CanInviteUsers)
	}
	{
		e.FieldStart("can_post_stories")
		e.Bool(s.CanPostStories)
	}
	{
		e.FieldStart("can_edit_stories")
		e.Bool(s.CanEditStories)
	}
	{
		e.FieldStart("can_delete_stories")
		e.Bool(s.CanDeleteStories)
	}
	{
		if s.CanPostMessages.Set {
			e.FieldStart("can_post_messages")
			s.CanPostMessages.Encode(e)
		}
	}
	{
		if s.CanEditMessages.Set {
			e.FieldStart("can_edit_messages")
			s.CanEditMessages.Encode(e)
		}
	}
	{
		if s.CanPinMessages.Set {
			e.FieldStart("can_pin_messages")
			s.CanPinMessages.Encode(e)
		}
	}
	{
		if s.CanManageTopics.Set {
			e.FieldStart("can_manage_topics")
			s.CanManageTopics.Encode(e)
		}
	}
	{
		if s.CustomTitle.Set {
			e.FieldStart("custom_title")
			s.CustomTitle.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatMemberAdministrator = [19]string{
	0:  "status",
	1:  "user",
	2:  "can_be_edited",
	3:  "is_anonymous",
	4:  "can_manage_chat",
	5:  "can_delete_messages",
	6:  "can_manage_video_chats",
	7:  "can_restrict_members",
	8:  "can_promote_members",
	9:  "can_change_info",
	10: "can_invite_users",
	11: "can_post_stories",
	12: "can_edit_stories",
	13: "can_delete_stories",
	14: "can_post_messages",
	15: "can_edit_messages",
	16: "can_pin_messages",
	17: "can_manage_topics",
	18: "custom_title",
}

// Decode decodes ChatMemberAdministrator from json.
func (s *ChatMemberAdministrator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatMemberAdministrator to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "can_be_edited":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.CanBeEdited = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_be_edited\"")
			}
		case "is_anonymous":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsAnonymous = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_anonymous\"")
			}
		case "can_manage_chat":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.CanManageChat = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_manage_chat\"")
			}
		case "can_delete_messages":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.CanDeleteMessages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_delete_messages\"")
			}
		case "can_manage_video_chats":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.CanManageVideoChats = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_manage_video_chats\"")
			}
		case "can_restrict_members":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.CanRestrictMembers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_restrict_members\"")
			}
		case "can_promote_members":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CanPromoteMembers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_promote_members\"")
			}
		case "can_change_info":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.CanChangeInfo = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_change_info\"")
			}
		case "can_invite_users":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.CanInviteUsers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_invite_users\"")
			}
		case "can_post_stories":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.CanPostStories = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_post_stories\"")
			}
		case "can_edit_stories":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.CanEditStories = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_edit_stories\"")
			}
		case "can_delete_stories":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.CanDeleteStories = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_delete_stories\"")
			}
		case "can_post_messages":
			if err := func() error {
				s.CanPostMessages.Reset()
				if err := s.CanPostMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_post_messages\"")
			}
		case "can_edit_messages":
			if err := func() error {
				s.CanEditMessages.Reset()
				if err := s.CanEditMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_edit_messages\"")
			}
		case "can_pin_messages":
			if err := func() error {
				s.CanPinMessages.Reset()
				if err := s.CanPinMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_pin_messages\"")
			}
		case "can_manage_topics":
			if err := func() error {
				s.CanManageTopics.Reset()
				if err := s.CanManageTopics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_manage_topics\"")
			}
		case "custom_title":
			if err := func() error {
				s.CustomTitle.Reset()
				if err := s.CustomTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatMemberAdministrator")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberAdministrator) {
					name = jsonFieldsNameOfChatMemberAdministrator[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatMemberAdministrator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatMemberAdministrator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatMemberBanned) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatMemberBanned) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("until_date")
		e.Int(s.UntilDate)
	}
}

var jsonFieldsNameOfChatMemberBanned = [3]string{
	0: "status",
	1: "user",
	2: "until_date",
}

// Decode decodes ChatMemberBanned from json.
func (s *ChatMemberBanned) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatMemberBanned to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "until_date":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.UntilDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"until_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatMemberBanned")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberBanned) {
					name = jsonFieldsNameOfChatMemberBanned[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatMemberBanned) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatMemberBanned) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatMemberLeft) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatMemberLeft) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
}

var jsonFieldsNameOfChatMemberLeft = [2]string{
	0: "status",
	1: "user",
}

// Decode decodes ChatMemberLeft from json.
func (s *ChatMemberLeft) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatMemberLeft to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatMemberLeft")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberLeft) {
					name = jsonFieldsNameOfChatMemberLeft[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatMemberLeft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatMemberLeft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatMemberMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatMemberMember) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		if s.UntilDate.Set {
			e.FieldStart("until_date")
			s.UntilDate.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatMemberMember = [3]string{
	0: "status",
	1: "user",
	2: "until_date",
}

// Decode decodes ChatMemberMember from json.
func (s *ChatMemberMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatMemberMember to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "until_date":
			if err := func() error {
				s.UntilDate.Reset()
				if err := s.UntilDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"until_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatMemberMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberMember) {
					name = jsonFieldsNameOfChatMemberMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatMemberMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatMemberMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatMemberOwner) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatMemberOwner) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("is_anonymous")
		e.Bool(s.IsAnonymous)
	}
	{
		if s.CustomTitle.Set {
			e.FieldStart("custom_title")
			s.CustomTitle.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatMemberOwner = [4]string{
	0: "status",
	1: "user",
	2: "is_anonymous",
	3: "custom_title",
}

// Decode decodes ChatMemberOwner from json.
func (s *ChatMemberOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatMemberOwner to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "is_anonymous":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsAnonymous = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_anonymous\"")
			}
		case "custom_title":
			if err := func() error {
				s.CustomTitle.Reset()
				if err := s.CustomTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatMemberOwner")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberOwner) {
					name = jsonFieldsNameOfChatMemberOwner[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatMemberOwner) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatMemberOwner) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatMemberRestricted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatMemberRestricted) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("is_member")
		e.Bool(s.IsMember)
	}
	{
		e.FieldStart("can_send_messages")
		e.Bool(s.CanSendMessages)
	}
	{
		e.FieldStart("can_send_audios")
		e.Bool(s.CanSendAudios)
	}
	{
		e.FieldStart("can_send_documents")
		e.Bool(s.CanSendDocuments)
	}
	{
		e.FieldStart("can_send_photos")
		e.Bool(s.CanSendPhotos)
	}
	{
		e.FieldStart("can_send_videos")
		e.Bool(s.CanSendVideos)
	}
	{
		e.FieldStart("can_send_video_notes")
		e.Bool(s.CanSendVideoNotes)
	}
	{
		e.FieldStart("can_send_voice_notes")
		e.Bool(s.CanSendVoiceNotes)
	}
	{
		e.FieldStart("can_send_polls")
		e.Bool(s.CanSendPolls)
	}
	{
		e.FieldStart("can_send_other_messages")
		e.Bool(s.CanSendOtherMessages)
	}
	{
		e.FieldStart("can_add_web_page_previews")
		e.Bool(s.CanAddWebPagePreviews)
	}
	{
		e.FieldStart("can_change_info")
		e.Bool(s.CanChangeInfo)
	}
	{
		e.FieldStart("can_invite_users")
		e.Bool(s.CanInviteUsers)
	}
	{
		e.FieldStart("can_pin_messages")
		e.Bool(s.CanPinMessages)
	}
	{
		e.FieldStart("can_manage_topics")
		e.Bool(s.CanManageTopics)
	}
	{
		e.FieldStart("until_date")
		e.Int(s.UntilDate)
	}
}

var jsonFieldsNameOfChatMemberRestricted = [18]string{
	0:  "status",
	1:  "user",
	2:  "is_member",
	3:  "can_send_messages",
	4:  "can_send_audios",
	5:  "can_send_documents",
	6:  "can_send_photos",
	7:  "can_send_videos",
	8:  "can_send_video_notes",
	9:  "can_send_voice_notes",
	10: "can_send_polls",
	11: "can_send_other_messages",
	12: "can_add_web_page_previews",
	13: "can_change_info",
	14: "can_invite_users",
	15: "can_pin_messages",
	16: "can_manage_topics",
	17: "until_date",
}

// Decode decodes ChatMemberRestricted from json.
func (s *ChatMemberRestricted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatMemberRestricted to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "is_member":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsMember = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_member\"")
			}
		case "can_send_messages":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.CanSendMessages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_messages\"")
			}
		case "can_send_audios":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.CanSendAudios = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_audios\"")
			}
		case "can_send_documents":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.CanSendDocuments = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_documents\"")
			}
		case "can_send_photos":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.CanSendPhotos = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_photos\"")
			}
		case "can_send_videos":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.CanSendVideos = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_videos\"")
			}
		case "can_send_video_notes":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CanSendVideoNotes = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_video_notes\"")
			}
		case "can_send_voice_notes":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.CanSendVoiceNotes = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_voice_notes\"")
			}
		case "can_send_polls":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.CanSendPolls = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_polls\"")
			}
		case "can_send_other_messages":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.CanSendOtherMessages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_other_messages\"")
			}
		case "can_add_web_page_previews":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.CanAddWebPagePreviews = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_add_web_page_previews\"")
			}
		case "can_change_info":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.CanChangeInfo = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_change_info\"")
			}
		case "can_invite_users":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.CanInviteUsers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_invite_users\"")
			}
		case "can_pin_messages":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.CanPinMessages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_pin_messages\"")
			}
		case "can_manage_topics":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CanManageTopics = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_manage_topics\"")
			}
		case "until_date":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.UntilDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"until_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatMemberRestricted")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberRestricted) {
					name = jsonFieldsNameOfChatMemberRestricted[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatMemberRestricted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatMemberRestricted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatMemberUpdated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatMemberUpdated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat")
		s.Chat.Encode(e)
	}
	{
		e.FieldStart("from")
		s.From.Encode(e)
	}
	{
		e.FieldStart("date")
		e.Int(s.Date)
	}
	{
		e.FieldStart("old_chat_member")
		s.OldChatMember.Encode(e)
	}
	{
		e.FieldStart("new_chat_member")
		s.NewChatMember.Encode(e)
	}
	{
		if s.InviteLink.Set {
			e.FieldStart("invite_link")
			s.InviteLink.Encode(e)
		}
	}
	{
		if s.ViaJoinRequest.Set {
			e.FieldStart("via_join_request")
			s.ViaJoinRequest.Encode(e)
		}
	}
	{
		if s.ViaChatFolderInviteLink.Set {
			e.FieldStart("via_chat_folder_invite_link")
			s.ViaChatFolderInviteLink.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatMemberUpdated = [8]string{
	0: "chat",
	1: "from",
	2: "date",
	3: "old_chat_member",
	4: "new_chat_member",
	5: "invite_link",
	6: "via_join_request",
	7: "via_chat_folder_invite_link",
}

// Decode decodes ChatMemberUpdated from json.
func (s *ChatMemberUpdated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatMemberUpdated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Chat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Date = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "old_chat_member":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OldChatMember.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_chat_member\"")
			}
		case "new_chat_member":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.NewChatMember.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_chat_member\"")
			}
		case "invite_link":
			if err := func() error {
				s.InviteLink.Reset()
				if err := s.InviteLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invite_link\"")
			}
		case "via_join_request":
			if err := func() error {
				s.ViaJoinRequest.Reset()
				if err := s.ViaJoinRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"via_join_request\"")
			}
		case "via_chat_folder_invite_link":
			if err := func() error {
				s.ViaChatFolderInviteLink.Reset()
				if err := s.ViaChatFolderInviteLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"via_chat_folder_invite_link\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatMemberUpdated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberUpdated) {
					name = jsonFieldsNameOfChatMemberUpdated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatMemberUpdated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatMemberUpdated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatPermissions) encodeFields(e *jx.Encoder) {
	{
		if s.CanSendMessages.Set {
			e.FieldStart("can_send_messages")
			s.CanSendMessages.Encode(e)
		}
	}
	{
		if s.CanSendAudios.Set {
			e.FieldStart("can_send_audios")
			s.CanSendAudios.Encode(e)
		}
	}
	{
		if s.CanSendDocuments.Set {
			e.FieldStart("can_send_documents")
			s.CanSendDocuments.Encode(e)
		}
	}
	{
		if s.CanSendPhotos.Set {
			e.FieldStart("can_send_photos")
			s.CanSendPhotos.Encode(e)
		}
	}
	{
		if s.CanSendVideos.Set {
			e.FieldStart("can_send_videos")
			s.CanSendVideos.Encode(e)
		}
	}
	{
		if s.CanSendVideoNotes.Set {
			e.FieldStart("can_send_video_notes")
			s.CanSendVideoNotes.Encode(e)
		}
	}
	{
		if s.CanSendVoiceNotes.Set {
			e.FieldStart("can_send_voice_notes")
			s.CanSendVoiceNotes.Encode(e)
		}
	}
	{
		if s.CanSendPolls.Set {
			e.FieldStart("can_send_polls")
			s.CanSendPolls.Encode(e)
		}
	}
	{
		if s.CanSendOtherMessages.Set {
			e.FieldStart("can_send_other_messages")
			s.CanSendOtherMessages.Encode(e)
		}
	}
	{
		if s.CanAddWebPagePreviews.Set {
			e.FieldStart("can_add_web_page_previews")
			s.CanAddWebPagePreviews.Encode(e)
		}
	}
	{
		if s.CanChangeInfo.Set {
			e.FieldStart("can_change_info")
			s.CanChangeInfo.Encode(e)
		}
	}
	{
		if s.CanInviteUsers.Set {
			e.FieldStart("can_invite_users")
			s.CanInviteUsers.Encode(e)
		}
	}
	{
		if s.CanPinMessages.Set {
			e.FieldStart("can_pin_messages")
			s.CanPinMessages.Encode(e)
		}
	}
	{
		if s.CanManageTopics.Set {
			e.FieldStart("can_manage_topics")
			s.CanManageTopics.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatPermissions = [14]string{
	0:  "can_send_messages",
	1:  "can_send_audios",
	2:  "can_send_documents",
	3:  "can_send_photos",
	4:  "can_send_videos",
	5:  "can_send_video_notes",
	6:  "can_send_voice_notes",
	7:  "can_send_polls",
	8:  "can_send_other_messages",
	9:  "can_add_web_page_previews",
	10: "can_change_info",
	11: "can_invite_users",
	12: "can_pin_messages",
	13: "can_manage_topics",
}

// Decode decodes ChatPermissions from json.
func (s *ChatPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatPermissions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "can_send_messages":
			if err := func() error {
				s.CanSendMessages.Reset()
				if err := s.CanSendMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_messages\"")
			}
		case "can_send_audios":
			if err := func() error {
				s.CanSendAudios.Reset()
				if err := s.CanSendAudios.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_audios\"")
			}
		case "can_send_documents":
			if err := func() error {
				s.CanSendDocuments.Reset()
				if err := s.CanSendDocuments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_documents\"")
			}
		case "can_send_photos":
			if err := func() error {
				s.CanSendPhotos.Reset()
				if err := s.CanSendPhotos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_photos\"")
			}
		case "can_send_videos":
			if err := func() error {
				s.CanSendVideos.Reset()
				if err := s.CanSendVideos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_videos\"")
			}
		case "can_send_video_notes":
			if err := func() error {
				s.CanSendVideoNotes.Reset()
				if err := s.CanSendVideoNotes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_video_notes\"")
			}
		case "can_send_voice_notes":
			if err := func() error {
				s.CanSendVoiceNotes.Reset()
				if err := s.CanSendVoiceNotes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_voice_notes\"")
			}
		case "can_send_polls":
			if err := func() error {
				s.CanSendPolls.Reset()
				if err := s.CanSendPolls.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_polls\"")
			}
		case "can_send_other_messages":
			if err := func() error {
				s.CanSendOtherMessages.Reset()
				if err := s.CanSendOtherMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_send_other_messages\"")
			}
		case "can_add_web_page_previews":
			if err := func() error {
				s.CanAddWebPagePreviews.Reset()
				if err := s.CanAddWebPagePreviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_add_web_page_previews\"")
			}
		case "can_change_info":
			if err := func() error {
				s.CanChangeInfo.Reset()
				if err := s.CanChangeInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_change_info\"")
			}
		case "can_invite_users":
			if err := func() error {
				s.CanInviteUsers.Reset()
				if err := s.CanInviteUsers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_invite_users\"")
			}
		case "can_pin_messages":
			if err := func() error {
				s.CanPinMessages.Reset()
				if err := s.CanPinMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_pin_messages\"")
			}
		case "can_manage_topics":
			if err := func() error {
				s.CanManageTopics.Reset()
				if err := s.CanManageTopics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_manage_topics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatPermissions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatShared) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatShared) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("request_id")
		e.Int(s.RequestID)
	}
	{
		e.FieldStart("chat_id")
		e.Int64(s.ChatID)
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Photo != nil {
			e.FieldStart("photo")
			e.ArrStart()
			for _, elem := range s.Photo {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfChatShared = [5]string{
	0: "request_id",
	1: "chat_id",
	2: "title",
	3: "username",
	4: "photo",
}

// Decode decodes ChatShared from json.
func (s *ChatShared) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatShared to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "request_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.RequestID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.ChatID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "photo":
			if err := func() error {
				s.Photo = make([]PhotoSize, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PhotoSize
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Photo = append(s.Photo, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatShared")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatShared) {
					name = jsonFieldsNameOfChatShared[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatShared) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatShared) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatType as json.
func (s ChatType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ChatType from json.
func (s *ChatType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ChatType(v) {
	case ChatTypePrivate:
		*s = ChatTypePrivate
	case ChatTypeGroup:
		*s = ChatTypeGroup
	case ChatTypeSupergroup:
		*s = ChatTypeSupergroup
	case ChatTypeChannel:
		*s = ChatTypeChannel
	default:
		*s = ChatType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChatType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChosenInlineResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChosenInlineResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("result_id")
		e.Str(s.ResultID)
	}
	{
		e.FieldStart("from")
		s.From.Encode(e)
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		e.FieldStart("query")
		e.Str(s.Query)
	}
}

var jsonFieldsNameOfChosenInlineResult = [5]string{
	0: "result_id",
	1: "from",
	2: "location",
	3: "inline_message_id",
	4: "query",
}

// Decode decodes ChosenInlineResult from json.
func (s *ChosenInlineResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChosenInlineResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResultID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_id\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		case "query":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Query = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChosenInlineResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChosenInlineResult) {
					name = jsonFieldsNameOfChosenInlineResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChosenInlineResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChosenInlineResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CloseForumTopic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CloseForumTopic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("message_thread_id")
		e.Int(s.MessageThreadID)
	}
}

var jsonFieldsNameOfCloseForumTopic = [2]string{
	0: "chat_id",
	1: "message_thread_id",
}

// Decode decodes CloseForumTopic from json.
func (s *CloseForumTopic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CloseForumTopic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MessageThreadID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CloseForumTopic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCloseForumTopic) {
					name = jsonFieldsNameOfCloseForumTopic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CloseForumTopic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CloseForumTopic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CloseGeneralForumTopic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CloseGeneralForumTopic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfCloseGeneralForumTopic = [1]string{
	0: "chat_id",
}

// Decode decodes CloseGeneralForumTopic from json.
func (s *CloseGeneralForumTopic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CloseGeneralForumTopic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CloseGeneralForumTopic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCloseGeneralForumTopic) {
					name = jsonFieldsNameOfCloseGeneralForumTopic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CloseGeneralForumTopic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CloseGeneralForumTopic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Contact) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Contact) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("first_name")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.FieldStart("last_name")
			s.LastName.Encode(e)
		}
	}
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
	{
		if s.Vcard.Set {
			e.FieldStart("vcard")
			s.Vcard.Encode(e)
		}
	}
}

var jsonFieldsNameOfContact = [5]string{
	0: "phone_number",
	1: "first_name",
	2: "last_name",
	3: "user_id",
	4: "vcard",
}

// Decode decodes Contact from json.
func (s *Contact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Contact to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phone_number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FirstName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_name\"")
			}
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "vcard":
			if err := func() error {
				s.Vcard.Reset()
				if err := s.Vcard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcard\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Contact")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContact) {
					name = jsonFieldsNameOfContact[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Contact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Contact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CopyMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CopyMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("from_chat_id")
		s.FromChatID.Encode(e)
	}
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfCopyMessage = [13]string{
	0:  "chat_id",
	1:  "message_thread_id",
	2:  "from_chat_id",
	3:  "message_id",
	4:  "caption",
	5:  "parse_mode",
	6:  "caption_entities",
	7:  "show_caption_above_media",
	8:  "disable_notification",
	9:  "protect_content",
	10: "allow_paid_broadcast",
	11: "reply_parameters",
	12: "reply_markup",
}

// Decode decodes CopyMessage from json.
func (s *CopyMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CopyMessage to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "from_chat_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FromChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_chat_id\"")
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CopyMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCopyMessage) {
					name = jsonFieldsNameOfCopyMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CopyMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CopyMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CopyMessages) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CopyMessages) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("from_chat_id")
		s.FromChatID.Encode(e)
	}
	{
		e.FieldStart("message_ids")
		e.ArrStart()
		for _, elem := range s.MessageIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.RemoveCaption.Set {
			e.FieldStart("remove_caption")
			s.RemoveCaption.Encode(e)
		}
	}
}

var jsonFieldsNameOfCopyMessages = [7]string{
	0: "chat_id",
	1: "message_thread_id",
	2: "from_chat_id",
	3: "message_ids",
	4: "disable_notification",
	5: "protect_content",
	6: "remove_caption",
}

// Decode decodes CopyMessages from json.
func (s *CopyMessages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CopyMessages to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "from_chat_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FromChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_chat_id\"")
			}
		case "message_ids":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.MessageIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.MessageIds = append(s.MessageIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_ids\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "remove_caption":
			if err := func() error {
				s.RemoveCaption.Reset()
				if err := s.RemoveCaption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_caption\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CopyMessages")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCopyMessages) {
					name = jsonFieldsNameOfCopyMessages[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CopyMessages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CopyMessages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CopyTextButton) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CopyTextButton) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
}

var jsonFieldsNameOfCopyTextButton = [1]string{
	0: "text",
}

// Decode decodes CopyTextButton from json.
func (s *CopyTextButton) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CopyTextButton to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CopyTextButton")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCopyTextButton) {
					name = jsonFieldsNameOfCopyTextButton[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CopyTextButton) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CopyTextButton) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateChatInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateChatInviteLink) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ExpireDate.Set {
			e.FieldStart("expire_date")
			s.ExpireDate.Encode(e)
		}
	}
	{
		if s.MemberLimit.Set {
			e.FieldStart("member_limit")
			s.MemberLimit.Encode(e)
		}
	}
	{
		if s.CreatesJoinRequest.Set {
			e.FieldStart("creates_join_request")
			s.CreatesJoinRequest.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateChatInviteLink = [5]string{
	0: "chat_id",
	1: "name",
	2: "expire_date",
	3: "member_limit",
	4: "creates_join_request",
}

// Decode decodes CreateChatInviteLink from json.
func (s *CreateChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChatInviteLink to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "expire_date":
			if err := func() error {
				s.ExpireDate.Reset()
				if err := s.ExpireDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expire_date\"")
			}
		case "member_limit":
			if err := func() error {
				s.MemberLimit.Reset()
				if err := s.MemberLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"member_limit\"")
			}
		case "creates_join_request":
			if err := func() error {
				s.CreatesJoinRequest.Reset()
				if err := s.CreatesJoinRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creates_join_request\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateChatInviteLink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateChatInviteLink) {
					name = jsonFieldsNameOfCreateChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateChatInviteLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChatInviteLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateChatSubscriptionInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateChatSubscriptionInviteLink) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("subscription_period")
		e.Int(s.SubscriptionPeriod)
	}
	{
		e.FieldStart("subscription_price")
		e.Int(s.SubscriptionPrice)
	}
}

var jsonFieldsNameOfCreateChatSubscriptionInviteLink = [4]string{
	0: "chat_id",
	1: "name",
	2: "subscription_period",
	3: "subscription_price",
}

// Decode decodes CreateChatSubscriptionInviteLink from json.
func (s *CreateChatSubscriptionInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChatSubscriptionInviteLink to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "subscription_period":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.SubscriptionPeriod = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_period\"")
			}
		case "subscription_price":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.SubscriptionPrice = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateChatSubscriptionInviteLink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateChatSubscriptionInviteLink) {
					name = jsonFieldsNameOfCreateChatSubscriptionInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateChatSubscriptionInviteLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChatSubscriptionInviteLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateForumTopic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateForumTopic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.IconColor.Set {
			e.FieldStart("icon_color")
			s.IconColor.Encode(e)
		}
	}
	{
		if s.IconCustomEmojiID.Set {
			e.FieldStart("icon_custom_emoji_id")
			s.IconCustomEmojiID.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateForumTopic = [4]string{
	0: "chat_id",
	1: "name",
	2: "icon_color",
	3: "icon_custom_emoji_id",
}

// Decode decodes CreateForumTopic from json.
func (s *CreateForumTopic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateForumTopic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "icon_color":
			if err := func() error {
				s.IconColor.Reset()
				if err := s.IconColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icon_color\"")
			}
		case "icon_custom_emoji_id":
			if err := func() error {
				s.IconCustomEmojiID.Reset()
				if err := s.IconCustomEmojiID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icon_custom_emoji_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateForumTopic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateForumTopic) {
					name = jsonFieldsNameOfCreateForumTopic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateForumTopic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateForumTopic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInvoiceLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInvoiceLink) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("payload")
		e.Str(s.Payload)
	}
	{
		if s.ProviderToken.Set {
			e.FieldStart("provider_token")
			s.ProviderToken.Encode(e)
		}
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("prices")
		e.ArrStart()
		for _, elem := range s.Prices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.SubscriptionPeriod.Set {
			e.FieldStart("subscription_period")
			s.SubscriptionPeriod.Encode(e)
		}
	}
	{
		if s.MaxTipAmount.Set {
			e.FieldStart("max_tip_amount")
			s.MaxTipAmount.Encode(e)
		}
	}
	{
		if s.SuggestedTipAmounts != nil {
			e.FieldStart("suggested_tip_amounts")
			e.ArrStart()
			for _, elem := range s.SuggestedTipAmounts {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ProviderData.Set {
			e.FieldStart("provider_data")
			s.ProviderData.Encode(e)
		}
	}
	{
		if s.PhotoURL.Set {
			e.FieldStart("photo_url")
			s.PhotoURL.Encode(e)
		}
	}
	{
		if s.PhotoSize.Set {
			e.FieldStart("photo_size")
			s.PhotoSize.Encode(e)
		}
	}
	{
		if s.PhotoWidth.Set {
			e.FieldStart("photo_width")
			s.PhotoWidth.Encode(e)
		}
	}
	{
		if s.PhotoHeight.Set {
			e.FieldStart("photo_height")
			s.PhotoHeight.Encode(e)
		}
	}
	{
		if s.NeedName.Set {
			e.FieldStart("need_name")
			s.NeedName.Encode(e)
		}
	}
	{
		if s.NeedPhoneNumber.Set {
			e.FieldStart("need_phone_number")
			s.NeedPhoneNumber.Encode(e)
		}
	}
	{
		if s.NeedEmail.Set {
			e.FieldStart("need_email")
			s.NeedEmail.Encode(e)
		}
	}
	{
		if s.NeedShippingAddress.Set {
			e.FieldStart("need_shipping_address")
			s.NeedShippingAddress.Encode(e)
		}
	}
	{
		if s.SendPhoneNumberToProvider.Set {
			e.FieldStart("send_phone_number_to_provider")
			s.SendPhoneNumberToProvider.Encode(e)
		}
	}
	{
		if s.SendEmailToProvider.Set {
			e.FieldStart("send_email_to_provider")
			s.SendEmailToProvider.Encode(e)
		}
	}
	{
		if s.IsFlexible.Set {
			e.FieldStart("is_flexible")
			s.IsFlexible.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateInvoiceLink = [22]string{
	0:  "business_connection_id",
	1:  "title",
	2:  "description",
	3:  "payload",
	4:  "provider_token",
	5:  "currency",
	6:  "prices",
	7:  "subscription_period",
	8:  "max_tip_amount",
	9:  "suggested_tip_amounts",
	10: "provider_data",
	11: "photo_url",
	12: "photo_size",
	13: "photo_width",
	14: "photo_height",
	15: "need_name",
	16: "need_phone_number",
	17: "need_email",
	18: "need_shipping_address",
	19: "send_phone_number_to_provider",
	20: "send_email_to_provider",
	21: "is_flexible",
}

// Decode decodes CreateInvoiceLink from json.
func (s *CreateInvoiceLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInvoiceLink to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Payload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "provider_token":
			if err := func() error {
				s.ProviderToken.Reset()
				if err := s.ProviderToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_token\"")
			}
		case "currency":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "prices":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.Prices = make([]LabeledPrice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LabeledPrice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Prices = append(s.Prices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prices\"")
			}
		case "subscription_period":
			if err := func() error {
				s.SubscriptionPeriod.Reset()
				if err := s.SubscriptionPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_period\"")
			}
		case "max_tip_amount":
			if err := func() error {
				s.MaxTipAmount.Reset()
				if err := s.MaxTipAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_tip_amount\"")
			}
		case "suggested_tip_amounts":
			if err := func() error {
				s.SuggestedTipAmounts = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SuggestedTipAmounts = append(s.SuggestedTipAmounts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suggested_tip_amounts\"")
			}
		case "provider_data":
			if err := func() error {
				s.ProviderData.Reset()
				if err := s.ProviderData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_data\"")
			}
		case "photo_url":
			if err := func() error {
				s.PhotoURL.Reset()
				if err := s.PhotoURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_url\"")
			}
		case "photo_size":
			if err := func() error {
				s.PhotoSize.Reset()
				if err := s.PhotoSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_size\"")
			}
		case "photo_width":
			if err := func() error {
				s.PhotoWidth.Reset()
				if err := s.PhotoWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_width\"")
			}
		case "photo_height":
			if err := func() error {
				s.PhotoHeight.Reset()
				if err := s.PhotoHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_height\"")
			}
		case "need_name":
			if err := func() error {
				s.NeedName.Reset()
				if err := s.NeedName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_name\"")
			}
		case "need_phone_number":
			if err := func() error {
				s.NeedPhoneNumber.Reset()
				if err := s.NeedPhoneNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_phone_number\"")
			}
		case "need_email":
			if err := func() error {
				s.NeedEmail.Reset()
				if err := s.NeedEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_email\"")
			}
		case "need_shipping_address":
			if err := func() error {
				s.NeedShippingAddress.Reset()
				if err := s.NeedShippingAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_shipping_address\"")
			}
		case "send_phone_number_to_provider":
			if err := func() error {
				s.SendPhoneNumberToProvider.Reset()
				if err := s.SendPhoneNumberToProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"send_phone_number_to_provider\"")
			}
		case "send_email_to_provider":
			if err := func() error {
				s.SendEmailToProvider.Reset()
				if err := s.SendEmailToProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"send_email_to_provider\"")
			}
		case "is_flexible":
			if err := func() error {
				s.IsFlexible.Reset()
				if err := s.IsFlexible.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_flexible\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInvoiceLink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01101110,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInvoiceLink) {
					name = jsonFieldsNameOfCreateInvoiceLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInvoiceLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInvoiceLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNewStickerSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNewStickerSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("stickers")
		e.ArrStart()
		for _, elem := range s.Stickers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.StickerType.Set {
			e.FieldStart("sticker_type")
			s.StickerType.Encode(e)
		}
	}
	{
		if s.NeedsRepainting.Set {
			e.FieldStart("needs_repainting")
			s.NeedsRepainting.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateNewStickerSet = [6]string{
	0: "user_id",
	1: "name",
	2: "title",
	3: "stickers",
	4: "sticker_type",
	5: "needs_repainting",
}

// Decode decodes CreateNewStickerSet from json.
func (s *CreateNewStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNewStickerSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "stickers":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Stickers = make([]InputSticker, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InputSticker
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Stickers = append(s.Stickers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stickers\"")
			}
		case "sticker_type":
			if err := func() error {
				s.StickerType.Reset()
				if err := s.StickerType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker_type\"")
			}
		case "needs_repainting":
			if err := func() error {
				s.NeedsRepainting.Reset()
				if err := s.NeedsRepainting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"needs_repainting\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNewStickerSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNewStickerSet) {
					name = jsonFieldsNameOfCreateNewStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNewStickerSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNewStickerSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeclineChatJoinRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeclineChatJoinRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
}

var jsonFieldsNameOfDeclineChatJoinRequest = [2]string{
	0: "chat_id",
	1: "user_id",
}

// Decode decodes DeclineChatJoinRequest from json.
func (s *DeclineChatJoinRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeclineChatJoinRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeclineChatJoinRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeclineChatJoinRequest) {
					name = jsonFieldsNameOfDeclineChatJoinRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeclineChatJoinRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeclineChatJoinRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteChatPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteChatPhoto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfDeleteChatPhoto = [1]string{
	0: "chat_id",
}

// Decode decodes DeleteChatPhoto from json.
func (s *DeleteChatPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteChatPhoto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteChatPhoto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteChatPhoto) {
					name = jsonFieldsNameOfDeleteChatPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteChatPhoto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteChatPhoto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteChatStickerSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteChatStickerSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfDeleteChatStickerSet = [1]string{
	0: "chat_id",
}

// Decode decodes DeleteChatStickerSet from json.
func (s *DeleteChatStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteChatStickerSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteChatStickerSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteChatStickerSet) {
					name = jsonFieldsNameOfDeleteChatStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteChatStickerSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteChatStickerSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteForumTopic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteForumTopic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("message_thread_id")
		e.Int(s.MessageThreadID)
	}
}

var jsonFieldsNameOfDeleteForumTopic = [2]string{
	0: "chat_id",
	1: "message_thread_id",
}

// Decode decodes DeleteForumTopic from json.
func (s *DeleteForumTopic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteForumTopic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MessageThreadID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteForumTopic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteForumTopic) {
					name = jsonFieldsNameOfDeleteForumTopic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteForumTopic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteForumTopic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
}

var jsonFieldsNameOfDeleteMessage = [2]string{
	0: "chat_id",
	1: "message_id",
}

// Decode decodes DeleteMessage from json.
func (s *DeleteMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteMessage) {
					name = jsonFieldsNameOfDeleteMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteMessages) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteMessages) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("message_ids")
		e.ArrStart()
		for _, elem := range s.MessageIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDeleteMessages = [2]string{
	0: "chat_id",
	1: "message_ids",
}

// Decode decodes DeleteMessages from json.
func (s *DeleteMessages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteMessages to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_ids":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.MessageIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.MessageIds = append(s.MessageIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteMessages")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteMessages) {
					name = jsonFieldsNameOfDeleteMessages[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteMessages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteMessages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteMyCommands) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteMyCommands) encodeFields(e *jx.Encoder) {
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeleteMyCommands = [2]string{
	0: "scope",
	1: "language_code",
}

// Decode decodes DeleteMyCommands from json.
func (s *DeleteMyCommands) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteMyCommands to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteMyCommands")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteMyCommands) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteMyCommands) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteStickerFromSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteStickerFromSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sticker")
		e.Str(s.Sticker)
	}
}

var jsonFieldsNameOfDeleteStickerFromSet = [1]string{
	0: "sticker",
}

// Decode decodes DeleteStickerFromSet from json.
func (s *DeleteStickerFromSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteStickerFromSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sticker":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sticker = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteStickerFromSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteStickerFromSet) {
					name = jsonFieldsNameOfDeleteStickerFromSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteStickerFromSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteStickerFromSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteStickerSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteStickerSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfDeleteStickerSet = [1]string{
	0: "name",
}

// Decode decodes DeleteStickerSet from json.
func (s *DeleteStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteStickerSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteStickerSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteStickerSet) {
					name = jsonFieldsNameOfDeleteStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteStickerSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteStickerSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteWebhook) encodeFields(e *jx.Encoder) {
	{
		if s.DropPendingUpdates.Set {
			e.FieldStart("drop_pending_updates")
			s.DropPendingUpdates.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeleteWebhook = [1]string{
	0: "drop_pending_updates",
}

// Decode decodes DeleteWebhook from json.
func (s *DeleteWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteWebhook to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "drop_pending_updates":
			if err := func() error {
				s.DropPendingUpdates.Reset()
				if err := s.DropPendingUpdates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drop_pending_updates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteWebhook")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Dice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Dice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("emoji")
		e.Str(s.Emoji)
	}
	{
		e.FieldStart("value")
		e.Int(s.Value)
	}
}

var jsonFieldsNameOfDice = [2]string{
	0: "emoji",
	1: "value",
}

// Decode decodes Dice from json.
func (s *Dice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Dice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "emoji":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Emoji = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emoji\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Value = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Dice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDice) {
					name = jsonFieldsNameOfDice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Dice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Dice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Document) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Document) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
	{
		if s.FileName.Set {
			e.FieldStart("file_name")
			s.FileName.Encode(e)
		}
	}
	{
		if s.MimeType.Set {
			e.FieldStart("mime_type")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfDocument = [6]string{
	0: "file_id",
	1: "file_unique_id",
	2: "thumbnail",
	3: "file_name",
	4: "mime_type",
	5: "file_size",
}

// Decode decodes Document from json.
func (s *Document) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Document to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "file_name":
			if err := func() error {
				s.FileName.Reset()
				if err := s.FileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_name\"")
			}
		case "mime_type":
			if err := func() error {
				s.MimeType.Reset()
				if err := s.MimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Document")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDocument) {
					name = jsonFieldsNameOfDocument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Document) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Document) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditChatInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditChatInviteLink) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("invite_link")
		e.Str(s.InviteLink)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ExpireDate.Set {
			e.FieldStart("expire_date")
			s.ExpireDate.Encode(e)
		}
	}
	{
		if s.MemberLimit.Set {
			e.FieldStart("member_limit")
			s.MemberLimit.Encode(e)
		}
	}
	{
		if s.CreatesJoinRequest.Set {
			e.FieldStart("creates_join_request")
			s.CreatesJoinRequest.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditChatInviteLink = [6]string{
	0: "chat_id",
	1: "invite_link",
	2: "name",
	3: "expire_date",
	4: "member_limit",
	5: "creates_join_request",
}

// Decode decodes EditChatInviteLink from json.
func (s *EditChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditChatInviteLink to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "invite_link":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InviteLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invite_link\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "expire_date":
			if err := func() error {
				s.ExpireDate.Reset()
				if err := s.ExpireDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expire_date\"")
			}
		case "member_limit":
			if err := func() error {
				s.MemberLimit.Reset()
				if err := s.MemberLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"member_limit\"")
			}
		case "creates_join_request":
			if err := func() error {
				s.CreatesJoinRequest.Reset()
				if err := s.CreatesJoinRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creates_join_request\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditChatInviteLink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditChatInviteLink) {
					name = jsonFieldsNameOfEditChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditChatInviteLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditChatInviteLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditChatSubscriptionInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditChatSubscriptionInviteLink) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("invite_link")
		e.Str(s.InviteLink)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditChatSubscriptionInviteLink = [3]string{
	0: "chat_id",
	1: "invite_link",
	2: "name",
}

// Decode decodes EditChatSubscriptionInviteLink from json.
func (s *EditChatSubscriptionInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditChatSubscriptionInviteLink to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "invite_link":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InviteLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invite_link\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditChatSubscriptionInviteLink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditChatSubscriptionInviteLink) {
					name = jsonFieldsNameOfEditChatSubscriptionInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditChatSubscriptionInviteLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditChatSubscriptionInviteLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditForumTopic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditForumTopic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("message_thread_id")
		e.Int(s.MessageThreadID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.IconCustomEmojiID.Set {
			e.FieldStart("icon_custom_emoji_id")
			s.IconCustomEmojiID.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditForumTopic = [4]string{
	0: "chat_id",
	1: "message_thread_id",
	2: "name",
	3: "icon_custom_emoji_id",
}

// Decode decodes EditForumTopic from json.
func (s *EditForumTopic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditForumTopic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MessageThreadID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "icon_custom_emoji_id":
			if err := func() error {
				s.IconCustomEmojiID.Reset()
				if err := s.IconCustomEmojiID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icon_custom_emoji_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditForumTopic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditForumTopic) {
					name = jsonFieldsNameOfEditForumTopic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditForumTopic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditForumTopic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditGeneralForumTopic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditGeneralForumTopic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfEditGeneralForumTopic = [2]string{
	0: "chat_id",
	1: "name",
}

// Decode decodes EditGeneralForumTopic from json.
func (s *EditGeneralForumTopic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditGeneralForumTopic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditGeneralForumTopic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditGeneralForumTopic) {
					name = jsonFieldsNameOfEditGeneralForumTopic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditGeneralForumTopic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditGeneralForumTopic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditMessageCaption) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditMessageCaption) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditMessageCaption = [9]string{
	0: "business_connection_id",
	1: "chat_id",
	2: "message_id",
	3: "inline_message_id",
	4: "caption",
	5: "parse_mode",
	6: "caption_entities",
	7: "show_caption_above_media",
	8: "reply_markup",
}

// Decode decodes EditMessageCaption from json.
func (s *EditMessageCaption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditMessageCaption to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditMessageCaption")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditMessageCaption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditMessageCaption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditMessageLiveLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditMessageLiveLocation) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		if s.LivePeriod.Set {
			e.FieldStart("live_period")
			s.LivePeriod.Encode(e)
		}
	}
	{
		if s.HorizontalAccuracy.Set {
			e.FieldStart("horizontal_accuracy")
			s.HorizontalAccuracy.Encode(e)
		}
	}
	{
		if s.Heading.Set {
			e.FieldStart("heading")
			s.Heading.Encode(e)
		}
	}
	{
		if s.ProximityAlertRadius.Set {
			e.FieldStart("proximity_alert_radius")
			s.ProximityAlertRadius.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditMessageLiveLocation = [11]string{
	0:  "business_connection_id",
	1:  "chat_id",
	2:  "message_id",
	3:  "inline_message_id",
	4:  "latitude",
	5:  "longitude",
	6:  "live_period",
	7:  "horizontal_accuracy",
	8:  "heading",
	9:  "proximity_alert_radius",
	10: "reply_markup",
}

// Decode decodes EditMessageLiveLocation from json.
func (s *EditMessageLiveLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditMessageLiveLocation to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "live_period":
			if err := func() error {
				s.LivePeriod.Reset()
				if err := s.LivePeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"live_period\"")
			}
		case "horizontal_accuracy":
			if err := func() error {
				s.HorizontalAccuracy.Reset()
				if err := s.HorizontalAccuracy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"horizontal_accuracy\"")
			}
		case "heading":
			if err := func() error {
				s.Heading.Reset()
				if err := s.Heading.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heading\"")
			}
		case "proximity_alert_radius":
			if err := func() error {
				s.ProximityAlertRadius.Reset()
				if err := s.ProximityAlertRadius.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proximity_alert_radius\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditMessageLiveLocation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00110000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditMessageLiveLocation) {
					name = jsonFieldsNameOfEditMessageLiveLocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditMessageLiveLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditMessageLiveLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditMessageMedia) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditMessageMedia) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		e.FieldStart("media")
		s.Media.Encode(e)
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditMessageMedia = [6]string{
	0: "business_connection_id",
	1: "chat_id",
	2: "message_id",
	3: "inline_message_id",
	4: "media",
	5: "reply_markup",
}

// Decode decodes EditMessageMedia from json.
func (s *EditMessageMedia) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditMessageMedia to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Media.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditMessageMedia")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditMessageMedia) {
					name = jsonFieldsNameOfEditMessageMedia[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditMessageMedia) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditMessageMedia) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditMessageReplyMarkup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditMessageReplyMarkup) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditMessageReplyMarkup = [5]string{
	0: "business_connection_id",
	1: "chat_id",
	2: "message_id",
	3: "inline_message_id",
	4: "reply_markup",
}

// Decode decodes EditMessageReplyMarkup from json.
func (s *EditMessageReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditMessageReplyMarkup to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditMessageReplyMarkup")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditMessageReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditMessageReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditMessageText) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditMessageText) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.Entities != nil {
			e.FieldStart("entities")
			e.ArrStart()
			for _, elem := range s.Entities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LinkPreviewOptions.Set {
			e.FieldStart("link_preview_options")
			s.LinkPreviewOptions.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditMessageText = [9]string{
	0: "business_connection_id",
	1: "chat_id",
	2: "message_id",
	3: "inline_message_id",
	4: "text",
	5: "parse_mode",
	6: "entities",
	7: "link_preview_options",
	8: "reply_markup",
}

// Decode decodes EditMessageText from json.
func (s *EditMessageText) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditMessageText to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "entities":
			if err := func() error {
				s.Entities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entities = append(s.Entities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entities\"")
			}
		case "link_preview_options":
			if err := func() error {
				s.LinkPreviewOptions.Reset()
				if err := s.LinkPreviewOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_preview_options\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditMessageText")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditMessageText) {
					name = jsonFieldsNameOfEditMessageText[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditMessageText) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditMessageText) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditUserStarSubscription) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditUserStarSubscription) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("telegram_payment_charge_id")
		e.Str(s.TelegramPaymentChargeID)
	}
	{
		e.FieldStart("is_canceled")
		e.Bool(s.IsCanceled)
	}
}

var jsonFieldsNameOfEditUserStarSubscription = [3]string{
	0: "user_id",
	1: "telegram_payment_charge_id",
	2: "is_canceled",
}

// Decode decodes EditUserStarSubscription from json.
func (s *EditUserStarSubscription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditUserStarSubscription to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "telegram_payment_charge_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TelegramPaymentChargeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegram_payment_charge_id\"")
			}
		case "is_canceled":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsCanceled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_canceled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditUserStarSubscription")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditUserStarSubscription) {
					name = jsonFieldsNameOfEditUserStarSubscription[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditUserStarSubscription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditUserStarSubscription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EncryptedCredentials) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EncryptedCredentials) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.Str(s.Data)
	}
	{
		e.FieldStart("hash")
		e.Str(s.Hash)
	}
	{
		e.FieldStart("secret")
		e.Str(s.Secret)
	}
}

var jsonFieldsNameOfEncryptedCredentials = [3]string{
	0: "data",
	1: "hash",
	2: "secret",
}

// Decode decodes EncryptedCredentials from json.
func (s *EncryptedCredentials) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EncryptedCredentials to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Data = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "hash":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Hash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hash\"")
			}
		case "secret":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Secret = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EncryptedCredentials")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEncryptedCredentials) {
					name = jsonFieldsNameOfEncryptedCredentials[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EncryptedCredentials) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EncryptedCredentials) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EncryptedPassportElement) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EncryptedPassportElement) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.PhoneNumber.Set {
			e.FieldStart("phone_number")
			s.PhoneNumber.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Files != nil {
			e.FieldStart("files")
			e.ArrStart()
			for _, elem := range s.Files {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FrontSide.Set {
			e.FieldStart("front_side")
			s.FrontSide.Encode(e)
		}
	}
	{
		if s.ReverseSide.Set {
			e.FieldStart("reverse_side")
			s.ReverseSide.Encode(e)
		}
	}
	{
		if s.Selfie.Set {
			e.FieldStart("selfie")
			s.Selfie.Encode(e)
		}
	}
	{
		if s.Translation != nil {
			e.FieldStart("translation")
			e.ArrStart()
			for _, elem := range s.Translation {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("hash")
		e.Str(s.Hash)
	}
}

var jsonFieldsNameOfEncryptedPassportElement = [10]string{
	0: "type",
	1: "data",
	2: "phone_number",
	3: "email",
	4: "files",
	5: "front_side",
	6: "reverse_side",
	7: "selfie",
	8: "translation",
	9: "hash",
}

// Decode decodes EncryptedPassportElement from json.
func (s *EncryptedPassportElement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EncryptedPassportElement to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "phone_number":
			if err := func() error {
				s.PhoneNumber.Reset()
				if err := s.PhoneNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "files":
			if err := func() error {
				s.Files = make([]PassportFile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PassportFile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Files = append(s.Files, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		case "front_side":
			if err := func() error {
				s.FrontSide.Reset()
				if err := s.FrontSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"front_side\"")
			}
		case "reverse_side":
			if err := func() error {
				s.ReverseSide.Reset()
				if err := s.ReverseSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reverse_side\"")
			}
		case "selfie":
			if err := func() error {
				s.Selfie.Reset()
				if err := s.Selfie.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selfie\"")
			}
		case "translation":
			if err := func() error {
				s.Translation = make([]PassportFile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PassportFile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Translation = append(s.Translation, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"translation\"")
			}
		case "hash":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Hash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hash\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EncryptedPassportElement")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEncryptedPassportElement) {
					name = jsonFieldsNameOfEncryptedPassportElement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EncryptedPassportElement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EncryptedPassportElement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EncryptedPassportElementType as json.
func (s EncryptedPassportElementType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EncryptedPassportElementType from json.
func (s *EncryptedPassportElementType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EncryptedPassportElementType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EncryptedPassportElementType(v) {
	case EncryptedPassportElementTypePersonalDetails:
		*s = EncryptedPassportElementTypePersonalDetails
	case EncryptedPassportElementTypePassport:
		*s = EncryptedPassportElementTypePassport
	case EncryptedPassportElementTypeDriverLicense:
		*s = EncryptedPassportElementTypeDriverLicense
	case EncryptedPassportElementTypeIdentityCard:
		*s = EncryptedPassportElementTypeIdentityCard
	case EncryptedPassportElementTypeInternalPassport:
		*s = EncryptedPassportElementTypeInternalPassport
	case EncryptedPassportElementTypeAddress:
		*s = EncryptedPassportElementTypeAddress
	case EncryptedPassportElementTypeUtilityBill:
		*s = EncryptedPassportElementTypeUtilityBill
	case EncryptedPassportElementTypeBankStatement:
		*s = EncryptedPassportElementTypeBankStatement
	case EncryptedPassportElementTypeRentalAgreement:
		*s = EncryptedPassportElementTypeRentalAgreement
	case EncryptedPassportElementTypePassportRegistration:
		*s = EncryptedPassportElementTypePassportRegistration
	case EncryptedPassportElementTypeTemporaryRegistration:
		*s = EncryptedPassportElementTypeTemporaryRegistration
	case EncryptedPassportElementTypePhoneNumber:
		*s = EncryptedPassportElementTypePhoneNumber
	case EncryptedPassportElementTypeEmail:
		*s = EncryptedPassportElementTypeEmail
	default:
		*s = EncryptedPassportElementType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EncryptedPassportElementType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EncryptedPassportElementType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
	{
		e.FieldStart("error_code")
		e.Int(s.ErrorCode)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [4]string{
	0: "ok",
	1: "error_code",
	2: "description",
	3: "parameters",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ok":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		case "error_code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ErrorCode = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExportChatInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExportChatInviteLink) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfExportChatInviteLink = [1]string{
	0: "chat_id",
}

// Decode decodes ExportChatInviteLink from json.
func (s *ExportChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExportChatInviteLink to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExportChatInviteLink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExportChatInviteLink) {
					name = jsonFieldsNameOfExportChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExportChatInviteLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExportChatInviteLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalReplyInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalReplyInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("origin")
		s.Origin.Encode(e)
	}
	{
		if s.Chat.Set {
			e.FieldStart("chat")
			s.Chat.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.LinkPreviewOptions.Set {
			e.FieldStart("link_preview_options")
			s.LinkPreviewOptions.Encode(e)
		}
	}
	{
		if s.Animation.Set {
			e.FieldStart("animation")
			s.Animation.Encode(e)
		}
	}
	{
		if s.Audio.Set {
			e.FieldStart("audio")
			s.Audio.Encode(e)
		}
	}
	{
		if s.Document.Set {
			e.FieldStart("document")
			s.Document.Encode(e)
		}
	}
	{
		if s.PaidMedia.Set {
			e.FieldStart("paid_media")
			s.PaidMedia.Encode(e)
		}
	}
	{
		if s.Photo != nil {
			e.FieldStart("photo")
			e.ArrStart()
			for _, elem := range s.Photo {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Sticker.Set {
			e.FieldStart("sticker")
			s.Sticker.Encode(e)
		}
	}
	{
		if s.Story.Set {
			e.FieldStart("story")
			s.Story.Encode(e)
		}
	}
	{
		if s.Video.Set {
			e.FieldStart("video")
			s.Video.Encode(e)
		}
	}
	{
		if s.VideoNote.Set {
			e.FieldStart("video_note")
			s.VideoNote.Encode(e)
		}
	}
	{
		if s.Voice.Set {
			e.FieldStart("voice")
			s.Voice.Encode(e)
		}
	}
	{
		if s.HasMediaSpoiler.Set {
			e.FieldStart("has_media_spoiler")
			s.HasMediaSpoiler.Encode(e)
		}
	}
	{
		if s.Contact.Set {
			e.FieldStart("contact")
			s.Contact.Encode(e)
		}
	}
	{
		if s.Dice.Set {
			e.FieldStart("dice")
			s.Dice.Encode(e)
		}
	}
	{
		if s.Game.Set {
			e.FieldStart("game")
			s.Game.Encode(e)
		}
	}
	{
		if s.Giveaway.Set {
			e.FieldStart("giveaway")
			s.Giveaway.Encode(e)
		}
	}
	{
		if s.GiveawayWinners.Set {
			e.FieldStart("giveaway_winners")
			s.GiveawayWinners.Encode(e)
		}
	}
	{
		if s.Invoice.Set {
			e.FieldStart("invoice")
			s.Invoice.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.Poll.Set {
			e.FieldStart("poll")
			s.Poll.Encode(e)
		}
	}
	{
		if s.Venue.Set {
			e.FieldStart("venue")
			s.Venue.Encode(e)
		}
	}
}

var jsonFieldsNameOfExternalReplyInfo = [24]string{
	0:  "origin",
	1:  "chat",
	2:  "message_id",
	3:  "link_preview_options",
	4:  "animation",
	5:  "audio",
	6:  "document",
	7:  "paid_media",
	8:  "photo",
	9:  "sticker",
	10: "story",
	11: "video",
	12: "video_note",
	13: "voice",
	14: "has_media_spoiler",
	15: "contact",
	16: "dice",
	17: "game",
	18: "giveaway",
	19: "giveaway_winners",
	20: "invoice",
	21: "location",
	22: "poll",
	23: "venue",
}

// Decode decodes ExternalReplyInfo from json.
func (s *ExternalReplyInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalReplyInfo to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "origin":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Origin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"origin\"")
			}
		case "chat":
			if err := func() error {
				s.Chat.Reset()
				if err := s.Chat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "link_preview_options":
			if err := func() error {
				s.LinkPreviewOptions.Reset()
				if err := s.LinkPreviewOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_preview_options\"")
			}
		case "animation":
			if err := func() error {
				s.Animation.Reset()
				if err := s.Animation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"animation\"")
			}
		case "audio":
			if err := func() error {
				s.Audio.Reset()
				if err := s.Audio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio\"")
			}
		case "document":
			if err := func() error {
				s.Document.Reset()
				if err := s.Document.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document\"")
			}
		case "paid_media":
			if err := func() error {
				s.PaidMedia.Reset()
				if err := s.PaidMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paid_media\"")
			}
		case "photo":
			if err := func() error {
				s.Photo = make([]PhotoSize, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PhotoSize
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Photo = append(s.Photo, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo\"")
			}
		case "sticker":
			if err := func() error {
				s.Sticker.Reset()
				if err := s.Sticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		case "story":
			if err := func() error {
				s.Story.Reset()
				if err := s.Story.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"story\"")
			}
		case "video":
			if err := func() error {
				s.Video.Reset()
				if err := s.Video.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video\"")
			}
		case "video_note":
			if err := func() error {
				s.VideoNote.Reset()
				if err := s.VideoNote.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_note\"")
			}
		case "voice":
			if err := func() error {
				s.Voice.Reset()
				if err := s.Voice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice\"")
			}
		case "has_media_spoiler":
			if err := func() error {
				s.HasMediaSpoiler.Reset()
				if err := s.HasMediaSpoiler.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_media_spoiler\"")
			}
		case "contact":
			if err := func() error {
				s.Contact.Reset()
				if err := s.Contact.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contact\"")
			}
		case "dice":
			if err := func() error {
				s.Dice.Reset()
				if err := s.Dice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dice\"")
			}
		case "game":
			if err := func() error {
				s.Game.Reset()
				if err := s.Game.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game\"")
			}
		case "giveaway":
			if err := func() error {
				s.Giveaway.Reset()
				if err := s.Giveaway.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"giveaway\"")
			}
		case "giveaway_winners":
			if err := func() error {
				s.GiveawayWinners.Reset()
				if err := s.GiveawayWinners.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"giveaway_winners\"")
			}
		case "invoice":
			if err := func() error {
				s.Invoice.Reset()
				if err := s.Invoice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoice\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "poll":
			if err := func() error {
				s.Poll.Reset()
				if err := s.Poll.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"poll\"")
			}
		case "venue":
			if err := func() error {
				s.Venue.Reset()
				if err := s.Venue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"venue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalReplyInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExternalReplyInfo) {
					name = jsonFieldsNameOfExternalReplyInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalReplyInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalReplyInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *File) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *File) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
	{
		if s.FilePath.Set {
			e.FieldStart("file_path")
			s.FilePath.Encode(e)
		}
	}
}

var jsonFieldsNameOfFile = [4]string{
	0: "file_id",
	1: "file_unique_id",
	2: "file_size",
	3: "file_path",
}

// Decode decodes File from json.
func (s *File) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode File to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		case "file_path":
			if err := func() error {
				s.FilePath.Reset()
				if err := s.FilePath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode File")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFile) {
					name = jsonFieldsNameOfFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *File) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *File) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForceReply) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForceReply) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("force_reply")
		e.Bool(s.ForceReply)
	}
	{
		if s.InputFieldPlaceholder.Set {
			e.FieldStart("input_field_placeholder")
			s.InputFieldPlaceholder.Encode(e)
		}
	}
	{
		if s.Selective.Set {
			e.FieldStart("selective")
			s.Selective.Encode(e)
		}
	}
}

var jsonFieldsNameOfForceReply = [3]string{
	0: "force_reply",
	1: "input_field_placeholder",
	2: "selective",
}

// Decode decodes ForceReply from json.
func (s *ForceReply) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForceReply to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "force_reply":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.ForceReply = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force_reply\"")
			}
		case "input_field_placeholder":
			if err := func() error {
				s.InputFieldPlaceholder.Reset()
				if err := s.InputFieldPlaceholder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_field_placeholder\"")
			}
		case "selective":
			if err := func() error {
				s.Selective.Reset()
				if err := s.Selective.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selective\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForceReply")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfForceReply) {
					name = jsonFieldsNameOfForceReply[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForceReply) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForceReply) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForumTopicClosed) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForumTopicClosed) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfForumTopicClosed = [0]string{}

// Decode decodes ForumTopicClosed from json.
func (s *ForumTopicClosed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForumTopicClosed to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ForumTopicClosed")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForumTopicClosed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForumTopicClosed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForumTopicCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForumTopicCreated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("icon_color")
		e.Int(s.IconColor)
	}
	{
		if s.IconCustomEmojiID.Set {
			e.FieldStart("icon_custom_emoji_id")
			s.IconCustomEmojiID.Encode(e)
		}
	}
}

var jsonFieldsNameOfForumTopicCreated = [3]string{
	0: "name",
	1: "icon_color",
	2: "icon_custom_emoji_id",
}

// Decode decodes ForumTopicCreated from json.
func (s *ForumTopicCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForumTopicCreated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "icon_color":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.IconColor = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icon_color\"")
			}
		case "icon_custom_emoji_id":
			if err := func() error {
				s.IconCustomEmojiID.Reset()
				if err := s.IconCustomEmojiID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icon_custom_emoji_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForumTopicCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfForumTopicCreated) {
					name = jsonFieldsNameOfForumTopicCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForumTopicCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForumTopicCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForumTopicEdited) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForumTopicEdited) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.IconCustomEmojiID.Set {
			e.FieldStart("icon_custom_emoji_id")
			s.IconCustomEmojiID.Encode(e)
		}
	}
}

var jsonFieldsNameOfForumTopicEdited = [2]string{
	0: "name",
	1: "icon_custom_emoji_id",
}

// Decode decodes ForumTopicEdited from json.
func (s *ForumTopicEdited) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForumTopicEdited to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "icon_custom_emoji_id":
			if err := func() error {
				s.IconCustomEmojiID.Reset()
				if err := s.IconCustomEmojiID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icon_custom_emoji_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForumTopicEdited")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForumTopicEdited) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForumTopicEdited) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForumTopicReopened) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForumTopicReopened) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfForumTopicReopened = [0]string{}

// Decode decodes ForumTopicReopened from json.
func (s *ForumTopicReopened) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForumTopicReopened to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ForumTopicReopened")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForumTopicReopened) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForumTopicReopened) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForwardMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForwardMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("from_chat_id")
		s.FromChatID.Encode(e)
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
}

var jsonFieldsNameOfForwardMessage = [6]string{
	0: "chat_id",
	1: "message_thread_id",
	2: "from_chat_id",
	3: "disable_notification",
	4: "protect_content",
	5: "message_id",
}

// Decode decodes ForwardMessage from json.
func (s *ForwardMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForwardMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "from_chat_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FromChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_chat_id\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForwardMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfForwardMessage) {
					name = jsonFieldsNameOfForwardMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForwardMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForwardMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForwardMessages) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForwardMessages) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("from_chat_id")
		s.FromChatID.Encode(e)
	}
	{
		e.FieldStart("message_ids")
		e.ArrStart()
		for _, elem := range s.MessageIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfForwardMessages = [6]string{
	0: "chat_id",
	1: "message_thread_id",
	2: "from_chat_id",
	3: "message_ids",
	4: "disable_notification",
	5: "protect_content",
}

// Decode decodes ForwardMessages from json.
func (s *ForwardMessages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForwardMessages to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "from_chat_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FromChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_chat_id\"")
			}
		case "message_ids":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.MessageIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.MessageIds = append(s.MessageIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_ids\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForwardMessages")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfForwardMessages) {
					name = jsonFieldsNameOfForwardMessages[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForwardMessages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForwardMessages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Game) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Game) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("photo")
		e.ArrStart()
		for _, elem := range s.Photo {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.TextEntities != nil {
			e.FieldStart("text_entities")
			e.ArrStart()
			for _, elem := range s.TextEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Animation.Set {
			e.FieldStart("animation")
			s.Animation.Encode(e)
		}
	}
}

var jsonFieldsNameOfGame = [6]string{
	0: "title",
	1: "description",
	2: "photo",
	3: "text",
	4: "text_entities",
	5: "animation",
}

// Decode decodes Game from json.
func (s *Game) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Game to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "photo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Photo = make([]PhotoSize, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PhotoSize
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Photo = append(s.Photo, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "text_entities":
			if err := func() error {
				s.TextEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TextEntities = append(s.TextEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_entities\"")
			}
		case "animation":
			if err := func() error {
				s.Animation.Reset()
				if err := s.Animation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"animation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Game")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGame) {
					name = jsonFieldsNameOfGame[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Game) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Game) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GameHighScore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GameHighScore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("position")
		e.Int(s.Position)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("score")
		e.Int(s.Score)
	}
}

var jsonFieldsNameOfGameHighScore = [3]string{
	0: "position",
	1: "user",
	2: "score",
}

// Decode decodes GameHighScore from json.
func (s *GameHighScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GameHighScore to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "position":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Position = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "score":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Score = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GameHighScore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGameHighScore) {
					name = jsonFieldsNameOfGameHighScore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GameHighScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GameHighScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GeneralForumTopicHidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GeneralForumTopicHidden) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGeneralForumTopicHidden = [0]string{}

// Decode decodes GeneralForumTopicHidden from json.
func (s *GeneralForumTopicHidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GeneralForumTopicHidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GeneralForumTopicHidden")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GeneralForumTopicHidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GeneralForumTopicHidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GeneralForumTopicUnhidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GeneralForumTopicUnhidden) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGeneralForumTopicUnhidden = [0]string{}

// Decode decodes GeneralForumTopicUnhidden from json.
func (s *GeneralForumTopicUnhidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GeneralForumTopicUnhidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GeneralForumTopicUnhidden")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GeneralForumTopicUnhidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GeneralForumTopicUnhidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBusinessConnection) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBusinessConnection) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("business_connection_id")
		e.Str(s.BusinessConnectionID)
	}
}

var jsonFieldsNameOfGetBusinessConnection = [1]string{
	0: "business_connection_id",
}

// Decode decodes GetBusinessConnection from json.
func (s *GetBusinessConnection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBusinessConnection to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BusinessConnectionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBusinessConnection")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBusinessConnection) {
					name = jsonFieldsNameOfGetBusinessConnection[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBusinessConnection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBusinessConnection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetChat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetChat) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfGetChat = [1]string{
	0: "chat_id",
}

// Decode decodes GetChat from json.
func (s *GetChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetChat to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetChat")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetChat) {
					name = jsonFieldsNameOfGetChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetChatAdministrators) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetChatAdministrators) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfGetChatAdministrators = [1]string{
	0: "chat_id",
}

// Decode decodes GetChatAdministrators from json.
func (s *GetChatAdministrators) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetChatAdministrators to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetChatAdministrators")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetChatAdministrators) {
					name = jsonFieldsNameOfGetChatAdministrators[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetChatAdministrators) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetChatAdministrators) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetChatMember) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
}

var jsonFieldsNameOfGetChatMember = [2]string{
	0: "chat_id",
	1: "user_id",
}

// Decode decodes GetChatMember from json.
func (s *GetChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetChatMember to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetChatMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetChatMember) {
					name = jsonFieldsNameOfGetChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetChatMemberCount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetChatMemberCount) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfGetChatMemberCount = [1]string{
	0: "chat_id",
}

// Decode decodes GetChatMemberCount from json.
func (s *GetChatMemberCount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetChatMemberCount to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetChatMemberCount")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetChatMemberCount) {
					name = jsonFieldsNameOfGetChatMemberCount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetChatMemberCount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetChatMemberCount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetChatMenuButton) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetChatMenuButton) encodeFields(e *jx.Encoder) {
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetChatMenuButton = [1]string{
	0: "chat_id",
}

// Decode decodes GetChatMenuButton from json.
func (s *GetChatMenuButton) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetChatMenuButton to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetChatMenuButton")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetChatMenuButton) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetChatMenuButton) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCustomEmojiStickers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCustomEmojiStickers) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("custom_emoji_ids")
		e.ArrStart()
		for _, elem := range s.CustomEmojiIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetCustomEmojiStickers = [1]string{
	0: "custom_emoji_ids",
}

// Decode decodes GetCustomEmojiStickers from json.
func (s *GetCustomEmojiStickers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCustomEmojiStickers to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "custom_emoji_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.CustomEmojiIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CustomEmojiIds = append(s.CustomEmojiIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_emoji_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetCustomEmojiStickers")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetCustomEmojiStickers) {
					name = jsonFieldsNameOfGetCustomEmojiStickers[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCustomEmojiStickers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCustomEmojiStickers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetFile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
}

var jsonFieldsNameOfGetFile = [1]string{
	0: "file_id",
}

// Decode decodes GetFile from json.
func (s *GetFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetFile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetFile) {
					name = jsonFieldsNameOfGetFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetGameHighScores) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetGameHighScores) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetGameHighScores = [4]string{
	0: "user_id",
	1: "chat_id",
	2: "message_id",
	3: "inline_message_id",
}

// Decode decodes GetGameHighScores from json.
func (s *GetGameHighScores) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetGameHighScores to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetGameHighScores")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetGameHighScores) {
					name = jsonFieldsNameOfGetGameHighScores[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetGameHighScores) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetGameHighScores) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetMyCommands) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetMyCommands) encodeFields(e *jx.Encoder) {
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetMyCommands = [2]string{
	0: "scope",
	1: "language_code",
}

// Decode decodes GetMyCommands from json.
func (s *GetMyCommands) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetMyCommands to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetMyCommands")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetMyCommands) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetMyCommands) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetMyDefaultAdministratorRights) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetMyDefaultAdministratorRights) encodeFields(e *jx.Encoder) {
	{
		if s.ForChannels.Set {
			e.FieldStart("for_channels")
			s.ForChannels.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetMyDefaultAdministratorRights = [1]string{
	0: "for_channels",
}

// Decode decodes GetMyDefaultAdministratorRights from json.
func (s *GetMyDefaultAdministratorRights) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetMyDefaultAdministratorRights to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "for_channels":
			if err := func() error {
				s.ForChannels.Reset()
				if err := s.ForChannels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"for_channels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetMyDefaultAdministratorRights")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetMyDefaultAdministratorRights) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetMyDefaultAdministratorRights) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetMyDescription) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetMyDescription) encodeFields(e *jx.Encoder) {
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetMyDescription = [1]string{
	0: "language_code",
}

// Decode decodes GetMyDescription from json.
func (s *GetMyDescription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetMyDescription to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetMyDescription")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetMyDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetMyDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetMyName) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetMyName) encodeFields(e *jx.Encoder) {
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetMyName = [1]string{
	0: "language_code",
}

// Decode decodes GetMyName from json.
func (s *GetMyName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetMyName to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetMyName")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetMyName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetMyName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetMyShortDescription) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetMyShortDescription) encodeFields(e *jx.Encoder) {
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetMyShortDescription = [1]string{
	0: "language_code",
}

// Decode decodes GetMyShortDescription from json.
func (s *GetMyShortDescription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetMyShortDescription to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetMyShortDescription")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetMyShortDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetMyShortDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStarTransactions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStarTransactions) encodeFields(e *jx.Encoder) {
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetStarTransactions = [2]string{
	0: "offset",
	1: "limit",
}

// Decode decodes GetStarTransactions from json.
func (s *GetStarTransactions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStarTransactions to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStarTransactions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStarTransactions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStarTransactions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStickerSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStickerSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGetStickerSet = [1]string{
	0: "name",
}

// Decode decodes GetStickerSet from json.
func (s *GetStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStickerSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStickerSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStickerSet) {
					name = jsonFieldsNameOfGetStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStickerSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStickerSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUpdates) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUpdates) encodeFields(e *jx.Encoder) {
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
	{
		if s.Timeout.Set {
			e.FieldStart("timeout")
			s.Timeout.Encode(e)
		}
	}
	{
		if s.AllowedUpdates != nil {
			e.FieldStart("allowed_updates")
			e.ArrStart()
			for _, elem := range s.AllowedUpdates {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetUpdates = [4]string{
	0: "offset",
	1: "limit",
	2: "timeout",
	3: "allowed_updates",
}

// Decode decodes GetUpdates from json.
func (s *GetUpdates) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUpdates to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "timeout":
			if err := func() error {
				s.Timeout.Reset()
				if err := s.Timeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout\"")
			}
		case "allowed_updates":
			if err := func() error {
				s.AllowedUpdates = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedUpdates = append(s.AllowedUpdates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_updates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUpdates")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUpdates) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUpdates) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserChatBoosts) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserChatBoosts) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
}

var jsonFieldsNameOfGetUserChatBoosts = [2]string{
	0: "chat_id",
	1: "user_id",
}

// Decode decodes GetUserChatBoosts from json.
func (s *GetUserChatBoosts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserChatBoosts to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserChatBoosts")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserChatBoosts) {
					name = jsonFieldsNameOfGetUserChatBoosts[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserChatBoosts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserChatBoosts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserProfilePhotos) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserProfilePhotos) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetUserProfilePhotos = [3]string{
	0: "user_id",
	1: "offset",
	2: "limit",
}

// Decode decodes GetUserProfilePhotos from json.
func (s *GetUserProfilePhotos) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserProfilePhotos to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserProfilePhotos")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserProfilePhotos) {
					name = jsonFieldsNameOfGetUserProfilePhotos[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserProfilePhotos) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserProfilePhotos) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Giveaway) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Giveaway) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chats")
		e.ArrStart()
		for _, elem := range s.Chats {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("winners_selection_date")
		e.Int(s.WinnersSelectionDate)
	}
	{
		e.FieldStart("winner_count")
		e.Int(s.WinnerCount)
	}
	{
		if s.OnlyNewMembers.Set {
			e.FieldStart("only_new_members")
			s.OnlyNewMembers.Encode(e)
		}
	}
	{
		if s.HasPublicWinners.Set {
			e.FieldStart("has_public_winners")
			s.HasPublicWinners.Encode(e)
		}
	}
	{
		if s.PrizeDescription.Set {
			e.FieldStart("prize_description")
			s.PrizeDescription.Encode(e)
		}
	}
	{
		if s.CountryCodes != nil {
			e.FieldStart("country_codes")
			e.ArrStart()
			for _, elem := range s.CountryCodes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PrizeStarCount.Set {
			e.FieldStart("prize_star_count")
			s.PrizeStarCount.Encode(e)
		}
	}
	{
		if s.PremiumSubscriptionMonthCount.Set {
			e.FieldStart("premium_subscription_month_count")
			s.PremiumSubscriptionMonthCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfGiveaway = [9]string{
	0: "chats",
	1: "winners_selection_date",
	2: "winner_count",
	3: "only_new_members",
	4: "has_public_winners",
	5: "prize_description",
	6: "country_codes",
	7: "prize_star_count",
	8: "premium_subscription_month_count",
}

// Decode decodes Giveaway from json.
func (s *Giveaway) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Giveaway to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chats":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Chats = make([]Chat, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Chat
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Chats = append(s.Chats, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chats\"")
			}
		case "winners_selection_date":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WinnersSelectionDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"winners_selection_date\"")
			}
		case "winner_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WinnerCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"winner_count\"")
			}
		case "only_new_members":
			if err := func() error {
				s.OnlyNewMembers.Reset()
				if err := s.OnlyNewMembers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"only_new_members\"")
			}
		case "has_public_winners":
			if err := func() error {
				s.HasPublicWinners.Reset()
				if err := s.HasPublicWinners.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_public_winners\"")
			}
		case "prize_description":
			if err := func() error {
				s.PrizeDescription.Reset()
				if err := s.PrizeDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prize_description\"")
			}
		case "country_codes":
			if err := func() error {
				s.CountryCodes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CountryCodes = append(s.CountryCodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country_codes\"")
			}
		case "prize_star_count":
			if err := func() error {
				s.PrizeStarCount.Reset()
				if err := s.PrizeStarCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prize_star_count\"")
			}
		case "premium_subscription_month_count":
			if err := func() error {
				s.PremiumSubscriptionMonthCount.Reset()
				if err := s.PremiumSubscriptionMonthCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"premium_subscription_month_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Giveaway")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGiveaway) {
					name = jsonFieldsNameOfGiveaway[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Giveaway) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Giveaway) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GiveawayCompleted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GiveawayCompleted) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("winner_count")
		e.Int(s.WinnerCount)
	}
	{
		if s.UnclaimedPrizeCount.Set {
			e.FieldStart("unclaimed_prize_count")
			s.UnclaimedPrizeCount.Encode(e)
		}
	}
	{
		if s.GiveawayMessage != nil {
			e.FieldStart("giveaway_message")
			s.GiveawayMessage.Encode(e)
		}
	}
	{
		if s.IsStarGiveaway.Set {
			e.FieldStart("is_star_giveaway")
			s.IsStarGiveaway.Encode(e)
		}
	}
}

var jsonFieldsNameOfGiveawayCompleted = [4]string{
	0: "winner_count",
	1: "unclaimed_prize_count",
	2: "giveaway_message",
	3: "is_star_giveaway",
}

// Decode decodes GiveawayCompleted from json.
func (s *GiveawayCompleted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GiveawayCompleted to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "winner_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.WinnerCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"winner_count\"")
			}
		case "unclaimed_prize_count":
			if err := func() error {
				s.UnclaimedPrizeCount.Reset()
				if err := s.UnclaimedPrizeCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unclaimed_prize_count\"")
			}
		case "giveaway_message":
			if err := func() error {
				s.GiveawayMessage = nil
				var elem Message
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.GiveawayMessage = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"giveaway_message\"")
			}
		case "is_star_giveaway":
			if err := func() error {
				s.IsStarGiveaway.Reset()
				if err := s.IsStarGiveaway.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_star_giveaway\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GiveawayCompleted")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGiveawayCompleted) {
					name = jsonFieldsNameOfGiveawayCompleted[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GiveawayCompleted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GiveawayCompleted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GiveawayCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GiveawayCreated) encodeFields(e *jx.Encoder) {
	{
		if s.PrizeStarCount.Set {
			e.FieldStart("prize_star_count")
			s.PrizeStarCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfGiveawayCreated = [1]string{
	0: "prize_star_count",
}

// Decode decodes GiveawayCreated from json.
func (s *GiveawayCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GiveawayCreated to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "prize_star_count":
			if err := func() error {
				s.PrizeStarCount.Reset()
				if err := s.PrizeStarCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prize_star_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GiveawayCreated")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GiveawayCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GiveawayCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GiveawayWinners) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GiveawayWinners) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat")
		s.Chat.Encode(e)
	}
	{
		e.FieldStart("giveaway_message_id")
		e.Int(s.GiveawayMessageID)
	}
	{
		e.FieldStart("winners_selection_date")
		e.Int(s.WinnersSelectionDate)
	}
	{
		e.FieldStart("winner_count")
		e.Int(s.WinnerCount)
	}
	{
		e.FieldStart("winners")
		e.ArrStart()
		for _, elem := range s.Winners {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.AdditionalChatCount.Set {
			e.FieldStart("additional_chat_count")
			s.AdditionalChatCount.Encode(e)
		}
	}
	{
		if s.PrizeStarCount.Set {
			e.FieldStart("prize_star_count")
			s.PrizeStarCount.Encode(e)
		}
	}
	{
		if s.PremiumSubscriptionMonthCount.Set {
			e.FieldStart("premium_subscription_month_count")
			s.PremiumSubscriptionMonthCount.Encode(e)
		}
	}
	{
		if s.UnclaimedPrizeCount.Set {
			e.FieldStart("unclaimed_prize_count")
			s.UnclaimedPrizeCount.Encode(e)
		}
	}
	{
		if s.OnlyNewMembers.Set {
			e.FieldStart("only_new_members")
			s.OnlyNewMembers.Encode(e)
		}
	}
	{
		if s.WasRefunded.Set {
			e.FieldStart("was_refunded")
			s.WasRefunded.Encode(e)
		}
	}
	{
		if s.PrizeDescription.Set {
			e.FieldStart("prize_description")
			s.PrizeDescription.Encode(e)
		}
	}
}

var jsonFieldsNameOfGiveawayWinners = [12]string{
	0:  "chat",
	1:  "giveaway_message_id",
	2:  "winners_selection_date",
	3:  "winner_count",
	4:  "winners",
	5:  "additional_chat_count",
	6:  "prize_star_count",
	7:  "premium_subscription_month_count",
	8:  "unclaimed_prize_count",
	9:  "only_new_members",
	10: "was_refunded",
	11: "prize_description",
}

// Decode decodes GiveawayWinners from json.
func (s *GiveawayWinners) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GiveawayWinners to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Chat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat\"")
			}
		case "giveaway_message_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.GiveawayMessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"giveaway_message_id\"")
			}
		case "winners_selection_date":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WinnersSelectionDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"winners_selection_date\"")
			}
		case "winner_count":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WinnerCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"winner_count\"")
			}
		case "winners":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Winners = make([]User, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem User
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Winners = append(s.Winners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"winners\"")
			}
		case "additional_chat_count":
			if err := func() error {
				s.AdditionalChatCount.Reset()
				if err := s.AdditionalChatCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additional_chat_count\"")
			}
		case "prize_star_count":
			if err := func() error {
				s.PrizeStarCount.Reset()
				if err := s.PrizeStarCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prize_star_count\"")
			}
		case "premium_subscription_month_count":
			if err := func() error {
				s.PremiumSubscriptionMonthCount.Reset()
				if err := s.PremiumSubscriptionMonthCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"premium_subscription_month_count\"")
			}
		case "unclaimed_prize_count":
			if err := func() error {
				s.UnclaimedPrizeCount.Reset()
				if err := s.UnclaimedPrizeCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unclaimed_prize_count\"")
			}
		case "only_new_members":
			if err := func() error {
				s.OnlyNewMembers.Reset()
				if err := s.OnlyNewMembers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"only_new_members\"")
			}
		case "was_refunded":
			if err := func() error {
				s.WasRefunded.Reset()
				if err := s.WasRefunded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"was_refunded\"")
			}
		case "prize_description":
			if err := func() error {
				s.PrizeDescription.Reset()
				if err := s.PrizeDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prize_description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GiveawayWinners")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGiveawayWinners) {
					name = jsonFieldsNameOfGiveawayWinners[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GiveawayWinners) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GiveawayWinners) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HideGeneralForumTopic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HideGeneralForumTopic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfHideGeneralForumTopic = [1]string{
	0: "chat_id",
}

// Decode decodes HideGeneralForumTopic from json.
func (s *HideGeneralForumTopic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HideGeneralForumTopic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HideGeneralForumTopic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHideGeneralForumTopic) {
					name = jsonFieldsNameOfHideGeneralForumTopic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HideGeneralForumTopic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HideGeneralForumTopic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ID as json.
func (s ID) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringID:
		e.Str(s.String)
	case Int64ID:
		e.Int64(s.Int64)
	}
}

// Decode decodes ID from json.
func (s *ID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ID to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int64()
		s.Int64 = int64(v)
		if err != nil {
			return err
		}
		s.Type = Int64ID
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringID
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InaccessibleMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InaccessibleMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat")
		s.Chat.Encode(e)
	}
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
	{
		e.FieldStart("date")
		e.Int(s.Date)
	}
}

var jsonFieldsNameOfInaccessibleMessage = [3]string{
	0: "chat",
	1: "message_id",
	2: "date",
}

// Decode decodes InaccessibleMessage from json.
func (s *InaccessibleMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InaccessibleMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Chat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat\"")
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Date = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InaccessibleMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInaccessibleMessage) {
					name = jsonFieldsNameOfInaccessibleMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InaccessibleMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InaccessibleMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineKeyboardButton) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineKeyboardButton) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.CallbackData.Set {
			e.FieldStart("callback_data")
			s.CallbackData.Encode(e)
		}
	}
	{
		if s.WebApp.Set {
			e.FieldStart("web_app")
			s.WebApp.Encode(e)
		}
	}
	{
		if s.LoginURL.Set {
			e.FieldStart("login_url")
			s.LoginURL.Encode(e)
		}
	}
	{
		if s.SwitchInlineQuery.Set {
			e.FieldStart("switch_inline_query")
			s.SwitchInlineQuery.Encode(e)
		}
	}
	{
		if s.SwitchInlineQueryCurrentChat.Set {
			e.FieldStart("switch_inline_query_current_chat")
			s.SwitchInlineQueryCurrentChat.Encode(e)
		}
	}
	{
		if s.SwitchInlineQueryChosenChat.Set {
			e.FieldStart("switch_inline_query_chosen_chat")
			s.SwitchInlineQueryChosenChat.Encode(e)
		}
	}
	{
		if s.CopyText.Set {
			e.FieldStart("copy_text")
			s.CopyText.Encode(e)
		}
	}
	{
		if s.CallbackGame != nil {
			e.FieldStart("callback_game")
			s.CallbackGame.Encode(e)
		}
	}
	{
		if s.Pay.Set {
			e.FieldStart("pay")
			s.Pay.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineKeyboardButton = [11]string{
	0:  "text",
	1:  "url",
	2:  "callback_data",
	3:  "web_app",
	4:  "login_url",
	5:  "switch_inline_query",
	6:  "switch_inline_query_current_chat",
	7:  "switch_inline_query_chosen_chat",
	8:  "copy_text",
	9:  "callback_game",
	10: "pay",
}

// Decode decodes InlineKeyboardButton from json.
func (s *InlineKeyboardButton) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineKeyboardButton to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "callback_data":
			if err := func() error {
				s.CallbackData.Reset()
				if err := s.CallbackData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"callback_data\"")
			}
		case "web_app":
			if err := func() error {
				s.WebApp.Reset()
				if err := s.WebApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"web_app\"")
			}
		case "login_url":
			if err := func() error {
				s.LoginURL.Reset()
				if err := s.LoginURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login_url\"")
			}
		case "switch_inline_query":
			if err := func() error {
				s.SwitchInlineQuery.Reset()
				if err := s.SwitchInlineQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"switch_inline_query\"")
			}
		case "switch_inline_query_current_chat":
			if err := func() error {
				s.SwitchInlineQueryCurrentChat.Reset()
				if err := s.SwitchInlineQueryCurrentChat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"switch_inline_query_current_chat\"")
			}
		case "switch_inline_query_chosen_chat":
			if err := func() error {
				s.SwitchInlineQueryChosenChat.Reset()
				if err := s.SwitchInlineQueryChosenChat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"switch_inline_query_chosen_chat\"")
			}
		case "copy_text":
			if err := func() error {
				s.CopyText.Reset()
				if err := s.CopyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"copy_text\"")
			}
		case "callback_game":
			if err := func() error {
				s.CallbackGame = nil
				var elem CallbackGame
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CallbackGame = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"callback_game\"")
			}
		case "pay":
			if err := func() error {
				s.Pay.Reset()
				if err := s.Pay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pay\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineKeyboardButton")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineKeyboardButton) {
					name = jsonFieldsNameOfInlineKeyboardButton[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineKeyboardButton) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineKeyboardButton) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineKeyboardMarkup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineKeyboardMarkup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("inline_keyboard")
		e.ArrStart()
		for _, elem := range s.InlineKeyboard {
			e.ArrStart()
			for _, elem := range elem {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfInlineKeyboardMarkup = [1]string{
	0: "inline_keyboard",
}

// Decode decodes InlineKeyboardMarkup from json.
func (s *InlineKeyboardMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineKeyboardMarkup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inline_keyboard":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.InlineKeyboard = make([][]InlineKeyboardButton, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem []InlineKeyboardButton
					elem = make([]InlineKeyboardButton, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elemElem InlineKeyboardButton
						if err := elemElem.Decode(d); err != nil {
							return err
						}
						elem = append(elem, elemElem)
						return nil
					}); err != nil {
						return err
					}
					s.InlineKeyboard = append(s.InlineKeyboard, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_keyboard\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineKeyboardMarkup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineKeyboardMarkup) {
					name = jsonFieldsNameOfInlineKeyboardMarkup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineKeyboardMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineKeyboardMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("from")
		s.From.Encode(e)
	}
	{
		e.FieldStart("query")
		e.Str(s.Query)
	}
	{
		e.FieldStart("offset")
		e.Str(s.Offset)
	}
	{
		if s.ChatType.Set {
			e.FieldStart("chat_type")
			s.ChatType.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQuery = [6]string{
	0: "id",
	1: "from",
	2: "query",
	3: "offset",
	4: "chat_type",
	5: "location",
}

// Decode decodes InlineQuery from json.
func (s *InlineQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "query":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Query = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		case "offset":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Offset = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "chat_type":
			if err := func() error {
				s.ChatType.Reset()
				if err := s.ChatType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_type\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQuery) {
					name = jsonFieldsNameOfInlineQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InlineQueryChatType as json.
func (s InlineQueryChatType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InlineQueryChatType from json.
func (s *InlineQueryChatType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryChatType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InlineQueryChatType(v) {
	case InlineQueryChatTypeSender:
		*s = InlineQueryChatTypeSender
	case InlineQueryChatTypePrivate:
		*s = InlineQueryChatTypePrivate
	case InlineQueryChatTypeGroup:
		*s = InlineQueryChatTypeGroup
	case InlineQueryChatTypeSupergroup:
		*s = InlineQueryChatTypeSupergroup
	case InlineQueryChatTypeChannel:
		*s = InlineQueryChatTypeChannel
	default:
		*s = InlineQueryChatType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InlineQueryChatType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryChatType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InlineQueryResult as json.
func (s InlineQueryResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s InlineQueryResult) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineQueryResultArticleInlineQueryResult:
		e.FieldStart("type")
		e.Str("article")
		{
			s := s.InlineQueryResultArticle
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				e.FieldStart("input_message_content")
				s.InputMessageContent.Encode(e)
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.URL.Set {
					e.FieldStart("url")
					s.URL.Encode(e)
				}
			}
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				if s.ThumbnailURL.Set {
					e.FieldStart("thumbnail_url")
					s.ThumbnailURL.Encode(e)
				}
			}
			{
				if s.ThumbnailWidth.Set {
					e.FieldStart("thumbnail_width")
					s.ThumbnailWidth.Encode(e)
				}
			}
			{
				if s.ThumbnailHeight.Set {
					e.FieldStart("thumbnail_height")
					s.ThumbnailHeight.Encode(e)
				}
			}
		}
	case InlineQueryResultAudioInlineQueryResult:
		e.FieldStart("type")
		e.Str("audio")
		{
			s := s.InlineQueryResultAudio
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("audio_url")
				e.Str(s.AudioURL)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.Performer.Set {
					e.FieldStart("performer")
					s.Performer.Encode(e)
				}
			}
			{
				if s.AudioDuration.Set {
					e.FieldStart("audio_duration")
					s.AudioDuration.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultContactInlineQueryResult:
		e.FieldStart("type")
		e.Str("contact")
		{
			s := s.InlineQueryResultContact
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("phone_number")
				e.Str(s.PhoneNumber)
			}
			{
				e.FieldStart("first_name")
				e.Str(s.FirstName)
			}
			{
				if s.LastName.Set {
					e.FieldStart("last_name")
					s.LastName.Encode(e)
				}
			}
			{
				if s.Vcard.Set {
					e.FieldStart("vcard")
					s.Vcard.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
			{
				if s.ThumbnailURL.Set {
					e.FieldStart("thumbnail_url")
					s.ThumbnailURL.Encode(e)
				}
			}
			{
				if s.ThumbnailWidth.Set {
					e.FieldStart("thumbnail_width")
					s.ThumbnailWidth.Encode(e)
				}
			}
			{
				if s.ThumbnailHeight.Set {
					e.FieldStart("thumbnail_height")
					s.ThumbnailHeight.Encode(e)
				}
			}
		}
	case InlineQueryResultDocumentInlineQueryResult:
		e.FieldStart("type")
		e.Str("document")
		{
			s := s.InlineQueryResultDocument
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				e.FieldStart("document_url")
				e.Str(s.DocumentURL)
			}
			{
				e.FieldStart("mime_type")
				e.Str(s.MimeType)
			}
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
			{
				if s.ThumbnailURL.Set {
					e.FieldStart("thumbnail_url")
					s.ThumbnailURL.Encode(e)
				}
			}
			{
				if s.ThumbnailWidth.Set {
					e.FieldStart("thumbnail_width")
					s.ThumbnailWidth.Encode(e)
				}
			}
			{
				if s.ThumbnailHeight.Set {
					e.FieldStart("thumbnail_height")
					s.ThumbnailHeight.Encode(e)
				}
			}
		}
	case InlineQueryResultGameInlineQueryResult:
		e.FieldStart("type")
		e.Str("game")
		{
			s := s.InlineQueryResultGame
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("game_short_name")
				e.Str(s.GameShortName)
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
		}
	case InlineQueryResultGifInlineQueryResult:
		e.FieldStart("type")
		e.Str("gif")
		{
			s := s.InlineQueryResultGif
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("gif_url")
				e.Str(s.GIFURL)
			}
			{
				if s.GIFWidth.Set {
					e.FieldStart("gif_width")
					s.GIFWidth.Encode(e)
				}
			}
			{
				if s.GIFHeight.Set {
					e.FieldStart("gif_height")
					s.GIFHeight.Encode(e)
				}
			}
			{
				if s.GIFDuration.Set {
					e.FieldStart("gif_duration")
					s.GIFDuration.Encode(e)
				}
			}
			{
				e.FieldStart("thumbnail_url")
				e.Str(s.ThumbnailURL)
			}
			{
				if s.ThumbnailMimeType.Set {
					e.FieldStart("thumbnail_mime_type")
					s.ThumbnailMimeType.Encode(e)
				}
			}
			{
				if s.Title.Set {
					e.FieldStart("title")
					s.Title.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ShowCaptionAboveMedia.Set {
					e.FieldStart("show_caption_above_media")
					s.ShowCaptionAboveMedia.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultLocationInlineQueryResult:
		e.FieldStart("type")
		e.Str("location")
		{
			s := s.InlineQueryResultLocation
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("latitude")
				e.Float64(s.Latitude)
			}
			{
				e.FieldStart("longitude")
				e.Float64(s.Longitude)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				if s.HorizontalAccuracy.Set {
					e.FieldStart("horizontal_accuracy")
					s.HorizontalAccuracy.Encode(e)
				}
			}
			{
				if s.LivePeriod.Set {
					e.FieldStart("live_period")
					s.LivePeriod.Encode(e)
				}
			}
			{
				if s.Heading.Set {
					e.FieldStart("heading")
					s.Heading.Encode(e)
				}
			}
			{
				if s.ProximityAlertRadius.Set {
					e.FieldStart("proximity_alert_radius")
					s.ProximityAlertRadius.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
			{
				if s.ThumbnailURL.Set {
					e.FieldStart("thumbnail_url")
					s.ThumbnailURL.Encode(e)
				}
			}
			{
				if s.ThumbnailWidth.Set {
					e.FieldStart("thumbnail_width")
					s.ThumbnailWidth.Encode(e)
				}
			}
			{
				if s.ThumbnailHeight.Set {
					e.FieldStart("thumbnail_height")
					s.ThumbnailHeight.Encode(e)
				}
			}
		}
	case InlineQueryResultMpeg4GifInlineQueryResult:
		e.FieldStart("type")
		e.Str("mpeg4_gif")
		{
			s := s.InlineQueryResultMpeg4Gif
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("mpeg4_url")
				e.Str(s.Mpeg4URL)
			}
			{
				if s.Mpeg4Width.Set {
					e.FieldStart("mpeg4_width")
					s.Mpeg4Width.Encode(e)
				}
			}
			{
				if s.Mpeg4Height.Set {
					e.FieldStart("mpeg4_height")
					s.Mpeg4Height.Encode(e)
				}
			}
			{
				if s.Mpeg4Duration.Set {
					e.FieldStart("mpeg4_duration")
					s.Mpeg4Duration.Encode(e)
				}
			}
			{
				e.FieldStart("thumbnail_url")
				e.Str(s.ThumbnailURL)
			}
			{
				if s.ThumbnailMimeType.Set {
					e.FieldStart("thumbnail_mime_type")
					s.ThumbnailMimeType.Encode(e)
				}
			}
			{
				if s.Title.Set {
					e.FieldStart("title")
					s.Title.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ShowCaptionAboveMedia.Set {
					e.FieldStart("show_caption_above_media")
					s.ShowCaptionAboveMedia.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultPhotoInlineQueryResult:
		e.FieldStart("type")
		e.Str("photo")
		{
			s := s.InlineQueryResultPhoto
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("photo_url")
				e.Str(s.PhotoURL)
			}
			{
				e.FieldStart("thumbnail_url")
				e.Str(s.ThumbnailURL)
			}
			{
				if s.PhotoWidth.Set {
					e.FieldStart("photo_width")
					s.PhotoWidth.Encode(e)
				}
			}
			{
				if s.PhotoHeight.Set {
					e.FieldStart("photo_height")
					s.PhotoHeight.Encode(e)
				}
			}
			{
				if s.Title.Set {
					e.FieldStart("title")
					s.Title.Encode(e)
				}
			}
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ShowCaptionAboveMedia.Set {
					e.FieldStart("show_caption_above_media")
					s.ShowCaptionAboveMedia.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultCachedStickerInlineQueryResult:
		e.FieldStart("type")
		e.Str("sticker")
		{
			s := s.InlineQueryResultCachedSticker
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("sticker_file_id")
				e.Str(s.StickerFileID)
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultVenueInlineQueryResult:
		e.FieldStart("type")
		e.Str("venue")
		{
			s := s.InlineQueryResultVenue
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("latitude")
				e.Float64(s.Latitude)
			}
			{
				e.FieldStart("longitude")
				e.Float64(s.Longitude)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				e.FieldStart("address")
				e.Str(s.Address)
			}
			{
				if s.FoursquareID.Set {
					e.FieldStart("foursquare_id")
					s.FoursquareID.Encode(e)
				}
			}
			{
				if s.FoursquareType.Set {
					e.FieldStart("foursquare_type")
					s.FoursquareType.Encode(e)
				}
			}
			{
				if s.GooglePlaceID.Set {
					e.FieldStart("google_place_id")
					s.GooglePlaceID.Encode(e)
				}
			}
			{
				if s.GooglePlaceType.Set {
					e.FieldStart("google_place_type")
					s.GooglePlaceType.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
			{
				if s.ThumbnailURL.Set {
					e.FieldStart("thumbnail_url")
					s.ThumbnailURL.Encode(e)
				}
			}
			{
				if s.ThumbnailWidth.Set {
					e.FieldStart("thumbnail_width")
					s.ThumbnailWidth.Encode(e)
				}
			}
			{
				if s.ThumbnailHeight.Set {
					e.FieldStart("thumbnail_height")
					s.ThumbnailHeight.Encode(e)
				}
			}
		}
	case InlineQueryResultVideoInlineQueryResult:
		e.FieldStart("type")
		e.Str("video")
		{
			s := s.InlineQueryResultVideo
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("video_url")
				e.Str(s.VideoURL)
			}
			{
				e.FieldStart("mime_type")
				e.Str(s.MimeType)
			}
			{
				e.FieldStart("thumbnail_url")
				e.Str(s.ThumbnailURL)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ShowCaptionAboveMedia.Set {
					e.FieldStart("show_caption_above_media")
					s.ShowCaptionAboveMedia.Encode(e)
				}
			}
			{
				if s.VideoWidth.Set {
					e.FieldStart("video_width")
					s.VideoWidth.Encode(e)
				}
			}
			{
				if s.VideoHeight.Set {
					e.FieldStart("video_height")
					s.VideoHeight.Encode(e)
				}
			}
			{
				if s.VideoDuration.Set {
					e.FieldStart("video_duration")
					s.VideoDuration.Encode(e)
				}
			}
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	case InlineQueryResultVoiceInlineQueryResult:
		e.FieldStart("type")
		e.Str("voice")
		{
			s := s.InlineQueryResultVoice
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("voice_url")
				e.Str(s.VoiceURL)
			}
			{
				e.FieldStart("title")
				e.Str(s.Title)
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.VoiceDuration.Set {
					e.FieldStart("voice_duration")
					s.VoiceDuration.Encode(e)
				}
			}
			{
				if s.ReplyMarkup.Set {
					e.FieldStart("reply_markup")
					s.ReplyMarkup.Encode(e)
				}
			}
			{
				if s.InputMessageContent.Set {
					e.FieldStart("input_message_content")
					s.InputMessageContent.Encode(e)
				}
			}
		}
	}
}

// Decode decodes InlineQueryResult from json.
func (s *InlineQueryResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResult to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "article":
					s.Type = InlineQueryResultArticleInlineQueryResult
					found = true
				case "audio":
					s.Type = InlineQueryResultAudioInlineQueryResult
					found = true
				case "contact":
					s.Type = InlineQueryResultContactInlineQueryResult
					found = true
				case "document":
					s.Type = InlineQueryResultDocumentInlineQueryResult
					found = true
				case "game":
					s.Type = InlineQueryResultGameInlineQueryResult
					found = true
				case "gif":
					s.Type = InlineQueryResultGifInlineQueryResult
					found = true
				case "location":
					s.Type = InlineQueryResultLocationInlineQueryResult
					found = true
				case "mpeg4_gif":
					s.Type = InlineQueryResultMpeg4GifInlineQueryResult
					found = true
				case "photo":
					s.Type = InlineQueryResultPhotoInlineQueryResult
					found = true
				case "sticker":
					s.Type = InlineQueryResultCachedStickerInlineQueryResult
					found = true
				case "venue":
					s.Type = InlineQueryResultVenueInlineQueryResult
					found = true
				case "video":
					s.Type = InlineQueryResultVideoInlineQueryResult
					found = true
				case "voice":
					s.Type = InlineQueryResultVoiceInlineQueryResult
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineQueryResultCachedAudioInlineQueryResult:
		if err := s.InlineQueryResultCachedAudio.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedDocumentInlineQueryResult:
		if err := s.InlineQueryResultCachedDocument.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedGifInlineQueryResult:
		if err := s.InlineQueryResultCachedGif.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedMpeg4GifInlineQueryResult:
		if err := s.InlineQueryResultCachedMpeg4Gif.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedPhotoInlineQueryResult:
		if err := s.InlineQueryResultCachedPhoto.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedStickerInlineQueryResult:
		if err := s.InlineQueryResultCachedSticker.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedVideoInlineQueryResult:
		if err := s.InlineQueryResultCachedVideo.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedVoiceInlineQueryResult:
		if err := s.InlineQueryResultCachedVoice.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultArticleInlineQueryResult:
		if err := s.InlineQueryResultArticle.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultAudioInlineQueryResult:
		if err := s.InlineQueryResultAudio.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultContactInlineQueryResult:
		if err := s.InlineQueryResultContact.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultGameInlineQueryResult:
		if err := s.InlineQueryResultGame.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultDocumentInlineQueryResult:
		if err := s.InlineQueryResultDocument.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultGifInlineQueryResult:
		if err := s.InlineQueryResultGif.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultLocationInlineQueryResult:
		if err := s.InlineQueryResultLocation.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultMpeg4GifInlineQueryResult:
		if err := s.InlineQueryResultMpeg4Gif.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultPhotoInlineQueryResult:
		if err := s.InlineQueryResultPhoto.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultVenueInlineQueryResult:
		if err := s.InlineQueryResultVenue.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultVideoInlineQueryResult:
		if err := s.InlineQueryResultVideo.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultVoiceInlineQueryResult:
		if err := s.InlineQueryResultVoice.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InlineQueryResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultArticle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultArticle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("input_message_content")
		s.InputMessageContent.Encode(e)
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ThumbnailURL.Set {
			e.FieldStart("thumbnail_url")
			s.ThumbnailURL.Encode(e)
		}
	}
	{
		if s.ThumbnailWidth.Set {
			e.FieldStart("thumbnail_width")
			s.ThumbnailWidth.Encode(e)
		}
	}
	{
		if s.ThumbnailHeight.Set {
			e.FieldStart("thumbnail_height")
			s.ThumbnailHeight.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultArticle = [10]string{
	0: "type",
	1: "id",
	2: "title",
	3: "input_message_content",
	4: "reply_markup",
	5: "url",
	6: "description",
	7: "thumbnail_url",
	8: "thumbnail_width",
	9: "thumbnail_height",
}

// Decode decodes InlineQueryResultArticle from json.
func (s *InlineQueryResultArticle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultArticle to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "input_message_content":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "thumbnail_url":
			if err := func() error {
				s.ThumbnailURL.Reset()
				if err := s.ThumbnailURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_url\"")
			}
		case "thumbnail_width":
			if err := func() error {
				s.ThumbnailWidth.Reset()
				if err := s.ThumbnailWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_width\"")
			}
		case "thumbnail_height":
			if err := func() error {
				s.ThumbnailHeight.Reset()
				if err := s.ThumbnailHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultArticle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultArticle) {
					name = jsonFieldsNameOfInlineQueryResultArticle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultArticle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultArticle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultAudio) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultAudio) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("audio_url")
		e.Str(s.AudioURL)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Performer.Set {
			e.FieldStart("performer")
			s.Performer.Encode(e)
		}
	}
	{
		if s.AudioDuration.Set {
			e.FieldStart("audio_duration")
			s.AudioDuration.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultAudio = [11]string{
	0:  "type",
	1:  "id",
	2:  "audio_url",
	3:  "title",
	4:  "caption",
	5:  "parse_mode",
	6:  "caption_entities",
	7:  "performer",
	8:  "audio_duration",
	9:  "reply_markup",
	10: "input_message_content",
}

// Decode decodes InlineQueryResultAudio from json.
func (s *InlineQueryResultAudio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultAudio to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "audio_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AudioURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_url\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "performer":
			if err := func() error {
				s.Performer.Reset()
				if err := s.Performer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performer\"")
			}
		case "audio_duration":
			if err := func() error {
				s.AudioDuration.Reset()
				if err := s.AudioDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_duration\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultAudio")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultAudio) {
					name = jsonFieldsNameOfInlineQueryResultAudio[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultAudio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultAudio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultCachedAudio) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultCachedAudio) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("audio_file_id")
		e.Str(s.AudioFileID)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultCachedAudio = [8]string{
	0: "type",
	1: "id",
	2: "audio_file_id",
	3: "caption",
	4: "parse_mode",
	5: "caption_entities",
	6: "reply_markup",
	7: "input_message_content",
}

// Decode decodes InlineQueryResultCachedAudio from json.
func (s *InlineQueryResultCachedAudio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultCachedAudio to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "audio_file_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AudioFileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_file_id\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultCachedAudio")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedAudio) {
					name = jsonFieldsNameOfInlineQueryResultCachedAudio[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultCachedAudio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultCachedAudio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultCachedDocument) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultCachedDocument) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("document_file_id")
		e.Str(s.DocumentFileID)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultCachedDocument = [10]string{
	0: "type",
	1: "id",
	2: "title",
	3: "document_file_id",
	4: "description",
	5: "caption",
	6: "parse_mode",
	7: "caption_entities",
	8: "reply_markup",
	9: "input_message_content",
}

// Decode decodes InlineQueryResultCachedDocument from json.
func (s *InlineQueryResultCachedDocument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultCachedDocument to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "document_file_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.DocumentFileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document_file_id\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultCachedDocument")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedDocument) {
					name = jsonFieldsNameOfInlineQueryResultCachedDocument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultCachedDocument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultCachedDocument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultCachedGif) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultCachedGif) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("gif_file_id")
		e.Str(s.GIFFileID)
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultCachedGif = [10]string{
	0: "type",
	1: "id",
	2: "gif_file_id",
	3: "title",
	4: "caption",
	5: "parse_mode",
	6: "caption_entities",
	7: "show_caption_above_media",
	8: "reply_markup",
	9: "input_message_content",
}

// Decode decodes InlineQueryResultCachedGif from json.
func (s *InlineQueryResultCachedGif) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultCachedGif to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "gif_file_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GIFFileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gif_file_id\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultCachedGif")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedGif) {
					name = jsonFieldsNameOfInlineQueryResultCachedGif[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultCachedGif) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultCachedGif) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultCachedMpeg4Gif) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultCachedMpeg4Gif) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("mpeg4_file_id")
		e.Str(s.Mpeg4FileID)
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultCachedMpeg4Gif = [10]string{
	0: "type",
	1: "id",
	2: "mpeg4_file_id",
	3: "title",
	4: "caption",
	5: "parse_mode",
	6: "caption_entities",
	7: "show_caption_above_media",
	8: "reply_markup",
	9: "input_message_content",
}

// Decode decodes InlineQueryResultCachedMpeg4Gif from json.
func (s *InlineQueryResultCachedMpeg4Gif) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultCachedMpeg4Gif to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "mpeg4_file_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Mpeg4FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mpeg4_file_id\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultCachedMpeg4Gif")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedMpeg4Gif) {
					name = jsonFieldsNameOfInlineQueryResultCachedMpeg4Gif[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultCachedMpeg4Gif) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultCachedMpeg4Gif) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultCachedPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultCachedPhoto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("photo_file_id")
		e.Str(s.PhotoFileID)
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultCachedPhoto = [11]string{
	0:  "type",
	1:  "id",
	2:  "photo_file_id",
	3:  "title",
	4:  "description",
	5:  "caption",
	6:  "parse_mode",
	7:  "caption_entities",
	8:  "show_caption_above_media",
	9:  "reply_markup",
	10: "input_message_content",
}

// Decode decodes InlineQueryResultCachedPhoto from json.
func (s *InlineQueryResultCachedPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultCachedPhoto to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "photo_file_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PhotoFileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_file_id\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultCachedPhoto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedPhoto) {
					name = jsonFieldsNameOfInlineQueryResultCachedPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultCachedPhoto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultCachedPhoto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultCachedSticker) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultCachedSticker) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("sticker_file_id")
		e.Str(s.StickerFileID)
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultCachedSticker = [5]string{
	0: "type",
	1: "id",
	2: "sticker_file_id",
	3: "reply_markup",
	4: "input_message_content",
}

// Decode decodes InlineQueryResultCachedSticker from json.
func (s *InlineQueryResultCachedSticker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultCachedSticker to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "sticker_file_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StickerFileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker_file_id\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultCachedSticker")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedSticker) {
					name = jsonFieldsNameOfInlineQueryResultCachedSticker[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultCachedSticker) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultCachedSticker) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultCachedVideo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultCachedVideo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("video_file_id")
		e.Str(s.VideoFileID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultCachedVideo = [11]string{
	0:  "type",
	1:  "id",
	2:  "video_file_id",
	3:  "title",
	4:  "description",
	5:  "caption",
	6:  "parse_mode",
	7:  "caption_entities",
	8:  "show_caption_above_media",
	9:  "reply_markup",
	10: "input_message_content",
}

// Decode decodes InlineQueryResultCachedVideo from json.
func (s *InlineQueryResultCachedVideo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultCachedVideo to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "video_file_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VideoFileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_file_id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultCachedVideo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedVideo) {
					name = jsonFieldsNameOfInlineQueryResultCachedVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultCachedVideo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultCachedVideo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultCachedVoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultCachedVoice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("voice_file_id")
		e.Str(s.VoiceFileID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultCachedVoice = [9]string{
	0: "type",
	1: "id",
	2: "voice_file_id",
	3: "title",
	4: "caption",
	5: "parse_mode",
	6: "caption_entities",
	7: "reply_markup",
	8: "input_message_content",
}

// Decode decodes InlineQueryResultCachedVoice from json.
func (s *InlineQueryResultCachedVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultCachedVoice to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "voice_file_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VoiceFileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_file_id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultCachedVoice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedVoice) {
					name = jsonFieldsNameOfInlineQueryResultCachedVoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultCachedVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultCachedVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultContact) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultContact) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("first_name")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.FieldStart("last_name")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Vcard.Set {
			e.FieldStart("vcard")
			s.Vcard.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
	{
		if s.ThumbnailURL.Set {
			e.FieldStart("thumbnail_url")
			s.ThumbnailURL.Encode(e)
		}
	}
	{
		if s.ThumbnailWidth.Set {
			e.FieldStart("thumbnail_width")
			s.ThumbnailWidth.Encode(e)
		}
	}
	{
		if s.ThumbnailHeight.Set {
			e.FieldStart("thumbnail_height")
			s.ThumbnailHeight.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultContact = [11]string{
	0:  "type",
	1:  "id",
	2:  "phone_number",
	3:  "first_name",
	4:  "last_name",
	5:  "vcard",
	6:  "reply_markup",
	7:  "input_message_content",
	8:  "thumbnail_url",
	9:  "thumbnail_width",
	10: "thumbnail_height",
}

// Decode decodes InlineQueryResultContact from json.
func (s *InlineQueryResultContact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultContact to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "phone_number":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FirstName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_name\"")
			}
		case "vcard":
			if err := func() error {
				s.Vcard.Reset()
				if err := s.Vcard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcard\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		case "thumbnail_url":
			if err := func() error {
				s.ThumbnailURL.Reset()
				if err := s.ThumbnailURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_url\"")
			}
		case "thumbnail_width":
			if err := func() error {
				s.ThumbnailWidth.Reset()
				if err := s.ThumbnailWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_width\"")
			}
		case "thumbnail_height":
			if err := func() error {
				s.ThumbnailHeight.Reset()
				if err := s.ThumbnailHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultContact")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultContact) {
					name = jsonFieldsNameOfInlineQueryResultContact[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultContact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultContact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultDocument) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultDocument) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("document_url")
		e.Str(s.DocumentURL)
	}
	{
		e.FieldStart("mime_type")
		e.Str(s.MimeType)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
	{
		if s.ThumbnailURL.Set {
			e.FieldStart("thumbnail_url")
			s.ThumbnailURL.Encode(e)
		}
	}
	{
		if s.ThumbnailWidth.Set {
			e.FieldStart("thumbnail_width")
			s.ThumbnailWidth.Encode(e)
		}
	}
	{
		if s.ThumbnailHeight.Set {
			e.FieldStart("thumbnail_height")
			s.ThumbnailHeight.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultDocument = [14]string{
	0:  "type",
	1:  "id",
	2:  "title",
	3:  "caption",
	4:  "parse_mode",
	5:  "caption_entities",
	6:  "document_url",
	7:  "mime_type",
	8:  "description",
	9:  "reply_markup",
	10: "input_message_content",
	11: "thumbnail_url",
	12: "thumbnail_width",
	13: "thumbnail_height",
}

// Decode decodes InlineQueryResultDocument from json.
func (s *InlineQueryResultDocument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultDocument to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "document_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DocumentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document_url\"")
			}
		case "mime_type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.MimeType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		case "thumbnail_url":
			if err := func() error {
				s.ThumbnailURL.Reset()
				if err := s.ThumbnailURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_url\"")
			}
		case "thumbnail_width":
			if err := func() error {
				s.ThumbnailWidth.Reset()
				if err := s.ThumbnailWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_width\"")
			}
		case "thumbnail_height":
			if err := func() error {
				s.ThumbnailHeight.Reset()
				if err := s.ThumbnailHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultDocument")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultDocument) {
					name = jsonFieldsNameOfInlineQueryResultDocument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultDocument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultDocument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultGame) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultGame) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("game_short_name")
		e.Str(s.GameShortName)
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultGame = [4]string{
	0: "type",
	1: "id",
	2: "game_short_name",
	3: "reply_markup",
}

// Decode decodes InlineQueryResultGame from json.
func (s *InlineQueryResultGame) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultGame to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "game_short_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GameShortName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_short_name\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultGame")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultGame) {
					name = jsonFieldsNameOfInlineQueryResultGame[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultGame) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultGame) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultGif) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultGif) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("gif_url")
		e.Str(s.GIFURL)
	}
	{
		if s.GIFWidth.Set {
			e.FieldStart("gif_width")
			s.GIFWidth.Encode(e)
		}
	}
	{
		if s.GIFHeight.Set {
			e.FieldStart("gif_height")
			s.GIFHeight.Encode(e)
		}
	}
	{
		if s.GIFDuration.Set {
			e.FieldStart("gif_duration")
			s.GIFDuration.Encode(e)
		}
	}
	{
		e.FieldStart("thumbnail_url")
		e.Str(s.ThumbnailURL)
	}
	{
		if s.ThumbnailMimeType.Set {
			e.FieldStart("thumbnail_mime_type")
			s.ThumbnailMimeType.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultGif = [15]string{
	0:  "type",
	1:  "id",
	2:  "gif_url",
	3:  "gif_width",
	4:  "gif_height",
	5:  "gif_duration",
	6:  "thumbnail_url",
	7:  "thumbnail_mime_type",
	8:  "title",
	9:  "caption",
	10: "parse_mode",
	11: "caption_entities",
	12: "show_caption_above_media",
	13: "reply_markup",
	14: "input_message_content",
}

// Decode decodes InlineQueryResultGif from json.
func (s *InlineQueryResultGif) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultGif to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "gif_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GIFURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gif_url\"")
			}
		case "gif_width":
			if err := func() error {
				s.GIFWidth.Reset()
				if err := s.GIFWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gif_width\"")
			}
		case "gif_height":
			if err := func() error {
				s.GIFHeight.Reset()
				if err := s.GIFHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gif_height\"")
			}
		case "gif_duration":
			if err := func() error {
				s.GIFDuration.Reset()
				if err := s.GIFDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gif_duration\"")
			}
		case "thumbnail_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ThumbnailURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_url\"")
			}
		case "thumbnail_mime_type":
			if err := func() error {
				s.ThumbnailMimeType.Reset()
				if err := s.ThumbnailMimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_mime_type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultGif")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultGif) {
					name = jsonFieldsNameOfInlineQueryResultGif[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultGif) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultGif) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultLocation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.HorizontalAccuracy.Set {
			e.FieldStart("horizontal_accuracy")
			s.HorizontalAccuracy.Encode(e)
		}
	}
	{
		if s.LivePeriod.Set {
			e.FieldStart("live_period")
			s.LivePeriod.Encode(e)
		}
	}
	{
		if s.Heading.Set {
			e.FieldStart("heading")
			s.Heading.Encode(e)
		}
	}
	{
		if s.ProximityAlertRadius.Set {
			e.FieldStart("proximity_alert_radius")
			s.ProximityAlertRadius.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
	{
		if s.ThumbnailURL.Set {
			e.FieldStart("thumbnail_url")
			s.ThumbnailURL.Encode(e)
		}
	}
	{
		if s.ThumbnailWidth.Set {
			e.FieldStart("thumbnail_width")
			s.ThumbnailWidth.Encode(e)
		}
	}
	{
		if s.ThumbnailHeight.Set {
			e.FieldStart("thumbnail_height")
			s.ThumbnailHeight.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultLocation = [14]string{
	0:  "type",
	1:  "id",
	2:  "latitude",
	3:  "longitude",
	4:  "title",
	5:  "horizontal_accuracy",
	6:  "live_period",
	7:  "heading",
	8:  "proximity_alert_radius",
	9:  "reply_markup",
	10: "input_message_content",
	11: "thumbnail_url",
	12: "thumbnail_width",
	13: "thumbnail_height",
}

// Decode decodes InlineQueryResultLocation from json.
func (s *InlineQueryResultLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultLocation to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "horizontal_accuracy":
			if err := func() error {
				s.HorizontalAccuracy.Reset()
				if err := s.HorizontalAccuracy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"horizontal_accuracy\"")
			}
		case "live_period":
			if err := func() error {
				s.LivePeriod.Reset()
				if err := s.LivePeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"live_period\"")
			}
		case "heading":
			if err := func() error {
				s.Heading.Reset()
				if err := s.Heading.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heading\"")
			}
		case "proximity_alert_radius":
			if err := func() error {
				s.ProximityAlertRadius.Reset()
				if err := s.ProximityAlertRadius.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proximity_alert_radius\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		case "thumbnail_url":
			if err := func() error {
				s.ThumbnailURL.Reset()
				if err := s.ThumbnailURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_url\"")
			}
		case "thumbnail_width":
			if err := func() error {
				s.ThumbnailWidth.Reset()
				if err := s.ThumbnailWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_width\"")
			}
		case "thumbnail_height":
			if err := func() error {
				s.ThumbnailHeight.Reset()
				if err := s.ThumbnailHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultLocation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultLocation) {
					name = jsonFieldsNameOfInlineQueryResultLocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultMpeg4Gif) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultMpeg4Gif) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("mpeg4_url")
		e.Str(s.Mpeg4URL)
	}
	{
		if s.Mpeg4Width.Set {
			e.FieldStart("mpeg4_width")
			s.Mpeg4Width.Encode(e)
		}
	}
	{
		if s.Mpeg4Height.Set {
			e.FieldStart("mpeg4_height")
			s.Mpeg4Height.Encode(e)
		}
	}
	{
		if s.Mpeg4Duration.Set {
			e.FieldStart("mpeg4_duration")
			s.Mpeg4Duration.Encode(e)
		}
	}
	{
		e.FieldStart("thumbnail_url")
		e.Str(s.ThumbnailURL)
	}
	{
		if s.ThumbnailMimeType.Set {
			e.FieldStart("thumbnail_mime_type")
			s.ThumbnailMimeType.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultMpeg4Gif = [15]string{
	0:  "type",
	1:  "id",
	2:  "mpeg4_url",
	3:  "mpeg4_width",
	4:  "mpeg4_height",
	5:  "mpeg4_duration",
	6:  "thumbnail_url",
	7:  "thumbnail_mime_type",
	8:  "title",
	9:  "caption",
	10: "parse_mode",
	11: "caption_entities",
	12: "show_caption_above_media",
	13: "reply_markup",
	14: "input_message_content",
}

// Decode decodes InlineQueryResultMpeg4Gif from json.
func (s *InlineQueryResultMpeg4Gif) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultMpeg4Gif to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "mpeg4_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Mpeg4URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mpeg4_url\"")
			}
		case "mpeg4_width":
			if err := func() error {
				s.Mpeg4Width.Reset()
				if err := s.Mpeg4Width.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mpeg4_width\"")
			}
		case "mpeg4_height":
			if err := func() error {
				s.Mpeg4Height.Reset()
				if err := s.Mpeg4Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mpeg4_height\"")
			}
		case "mpeg4_duration":
			if err := func() error {
				s.Mpeg4Duration.Reset()
				if err := s.Mpeg4Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mpeg4_duration\"")
			}
		case "thumbnail_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ThumbnailURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_url\"")
			}
		case "thumbnail_mime_type":
			if err := func() error {
				s.ThumbnailMimeType.Reset()
				if err := s.ThumbnailMimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_mime_type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultMpeg4Gif")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultMpeg4Gif) {
					name = jsonFieldsNameOfInlineQueryResultMpeg4Gif[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultMpeg4Gif) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultMpeg4Gif) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultPhoto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("photo_url")
		e.Str(s.PhotoURL)
	}
	{
		e.FieldStart("thumbnail_url")
		e.Str(s.ThumbnailURL)
	}
	{
		if s.PhotoWidth.Set {
			e.FieldStart("photo_width")
			s.PhotoWidth.Encode(e)
		}
	}
	{
		if s.PhotoHeight.Set {
			e.FieldStart("photo_height")
			s.PhotoHeight.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultPhoto = [14]string{
	0:  "type",
	1:  "id",
	2:  "photo_url",
	3:  "thumbnail_url",
	4:  "photo_width",
	5:  "photo_height",
	6:  "title",
	7:  "description",
	8:  "caption",
	9:  "parse_mode",
	10: "caption_entities",
	11: "show_caption_above_media",
	12: "reply_markup",
	13: "input_message_content",
}

// Decode decodes InlineQueryResultPhoto from json.
func (s *InlineQueryResultPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultPhoto to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "photo_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PhotoURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_url\"")
			}
		case "thumbnail_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ThumbnailURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_url\"")
			}
		case "photo_width":
			if err := func() error {
				s.PhotoWidth.Reset()
				if err := s.PhotoWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_width\"")
			}
		case "photo_height":
			if err := func() error {
				s.PhotoHeight.Reset()
				if err := s.PhotoHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_height\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultPhoto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultPhoto) {
					name = jsonFieldsNameOfInlineQueryResultPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultPhoto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultPhoto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultVenue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultVenue) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		if s.FoursquareID.Set {
			e.FieldStart("foursquare_id")
			s.FoursquareID.Encode(e)
		}
	}
	{
		if s.FoursquareType.Set {
			e.FieldStart("foursquare_type")
			s.FoursquareType.Encode(e)
		}
	}
	{
		if s.GooglePlaceID.Set {
			e.FieldStart("google_place_id")
			s.GooglePlaceID.Encode(e)
		}
	}
	{
		if s.GooglePlaceType.Set {
			e.FieldStart("google_place_type")
			s.GooglePlaceType.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
	{
		if s.ThumbnailURL.Set {
			e.FieldStart("thumbnail_url")
			s.ThumbnailURL.Encode(e)
		}
	}
	{
		if s.ThumbnailWidth.Set {
			e.FieldStart("thumbnail_width")
			s.ThumbnailWidth.Encode(e)
		}
	}
	{
		if s.ThumbnailHeight.Set {
			e.FieldStart("thumbnail_height")
			s.ThumbnailHeight.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultVenue = [15]string{
	0:  "type",
	1:  "id",
	2:  "latitude",
	3:  "longitude",
	4:  "title",
	5:  "address",
	6:  "foursquare_id",
	7:  "foursquare_type",
	8:  "google_place_id",
	9:  "google_place_type",
	10: "reply_markup",
	11: "input_message_content",
	12: "thumbnail_url",
	13: "thumbnail_width",
	14: "thumbnail_height",
}

// Decode decodes InlineQueryResultVenue from json.
func (s *InlineQueryResultVenue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultVenue to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "foursquare_id":
			if err := func() error {
				s.FoursquareID.Reset()
				if err := s.FoursquareID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foursquare_id\"")
			}
		case "foursquare_type":
			if err := func() error {
				s.FoursquareType.Reset()
				if err := s.FoursquareType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foursquare_type\"")
			}
		case "google_place_id":
			if err := func() error {
				s.GooglePlaceID.Reset()
				if err := s.GooglePlaceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_place_id\"")
			}
		case "google_place_type":
			if err := func() error {
				s.GooglePlaceType.Reset()
				if err := s.GooglePlaceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_place_type\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		case "thumbnail_url":
			if err := func() error {
				s.ThumbnailURL.Reset()
				if err := s.ThumbnailURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_url\"")
			}
		case "thumbnail_width":
			if err := func() error {
				s.ThumbnailWidth.Reset()
				if err := s.ThumbnailWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_width\"")
			}
		case "thumbnail_height":
			if err := func() error {
				s.ThumbnailHeight.Reset()
				if err := s.ThumbnailHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultVenue")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultVenue) {
					name = jsonFieldsNameOfInlineQueryResultVenue[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultVenue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultVenue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultVideo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultVideo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("video_url")
		e.Str(s.VideoURL)
	}
	{
		e.FieldStart("mime_type")
		e.Str(s.MimeType)
	}
	{
		e.FieldStart("thumbnail_url")
		e.Str(s.ThumbnailURL)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.VideoWidth.Set {
			e.FieldStart("video_width")
			s.VideoWidth.Encode(e)
		}
	}
	{
		if s.VideoHeight.Set {
			e.FieldStart("video_height")
			s.VideoHeight.Encode(e)
		}
	}
	{
		if s.VideoDuration.Set {
			e.FieldStart("video_duration")
			s.VideoDuration.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultVideo = [16]string{
	0:  "type",
	1:  "id",
	2:  "video_url",
	3:  "mime_type",
	4:  "thumbnail_url",
	5:  "title",
	6:  "caption",
	7:  "parse_mode",
	8:  "caption_entities",
	9:  "show_caption_above_media",
	10: "video_width",
	11: "video_height",
	12: "video_duration",
	13: "description",
	14: "reply_markup",
	15: "input_message_content",
}

// Decode decodes InlineQueryResultVideo from json.
func (s *InlineQueryResultVideo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultVideo to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "video_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VideoURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_url\"")
			}
		case "mime_type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.MimeType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "thumbnail_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ThumbnailURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail_url\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "video_width":
			if err := func() error {
				s.VideoWidth.Reset()
				if err := s.VideoWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_width\"")
			}
		case "video_height":
			if err := func() error {
				s.VideoHeight.Reset()
				if err := s.VideoHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_height\"")
			}
		case "video_duration":
			if err := func() error {
				s.VideoDuration.Reset()
				if err := s.VideoDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_duration\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultVideo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultVideo) {
					name = jsonFieldsNameOfInlineQueryResultVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultVideo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultVideo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultVoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultVoice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("voice_url")
		e.Str(s.VoiceURL)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VoiceDuration.Set {
			e.FieldStart("voice_duration")
			s.VoiceDuration.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.FieldStart("input_message_content")
			s.InputMessageContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultVoice = [10]string{
	0: "type",
	1: "id",
	2: "voice_url",
	3: "title",
	4: "caption",
	5: "parse_mode",
	6: "caption_entities",
	7: "voice_duration",
	8: "reply_markup",
	9: "input_message_content",
}

// Decode decodes InlineQueryResultVoice from json.
func (s *InlineQueryResultVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultVoice to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "voice_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VoiceURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_url\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "voice_duration":
			if err := func() error {
				s.VoiceDuration.Reset()
				if err := s.VoiceDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_duration\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "input_message_content":
			if err := func() error {
				s.InputMessageContent.Reset()
				if err := s.InputMessageContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_message_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultVoice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultVoice) {
					name = jsonFieldsNameOfInlineQueryResultVoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InlineQueryResultsButton) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InlineQueryResultsButton) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.WebApp.Set {
			e.FieldStart("web_app")
			s.WebApp.Encode(e)
		}
	}
	{
		if s.StartParameter.Set {
			e.FieldStart("start_parameter")
			s.StartParameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfInlineQueryResultsButton = [3]string{
	0: "text",
	1: "web_app",
	2: "start_parameter",
}

// Decode decodes InlineQueryResultsButton from json.
func (s *InlineQueryResultsButton) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InlineQueryResultsButton to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "web_app":
			if err := func() error {
				s.WebApp.Reset()
				if err := s.WebApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"web_app\"")
			}
		case "start_parameter":
			if err := func() error {
				s.StartParameter.Reset()
				if err := s.StartParameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InlineQueryResultsButton")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultsButton) {
					name = jsonFieldsNameOfInlineQueryResultsButton[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InlineQueryResultsButton) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InlineQueryResultsButton) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputContactMessageContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputContactMessageContent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("first_name")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.FieldStart("last_name")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Vcard.Set {
			e.FieldStart("vcard")
			s.Vcard.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputContactMessageContent = [4]string{
	0: "phone_number",
	1: "first_name",
	2: "last_name",
	3: "vcard",
}

// Decode decodes InputContactMessageContent from json.
func (s *InputContactMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputContactMessageContent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phone_number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FirstName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_name\"")
			}
		case "vcard":
			if err := func() error {
				s.Vcard.Reset()
				if err := s.Vcard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcard\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputContactMessageContent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputContactMessageContent) {
					name = jsonFieldsNameOfInputContactMessageContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputContactMessageContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputContactMessageContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputInvoiceMessageContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputInvoiceMessageContent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("payload")
		e.Str(s.Payload)
	}
	{
		if s.ProviderToken.Set {
			e.FieldStart("provider_token")
			s.ProviderToken.Encode(e)
		}
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("prices")
		e.ArrStart()
		for _, elem := range s.Prices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.MaxTipAmount.Set {
			e.FieldStart("max_tip_amount")
			s.MaxTipAmount.Encode(e)
		}
	}
	{
		if s.SuggestedTipAmounts != nil {
			e.FieldStart("suggested_tip_amounts")
			e.ArrStart()
			for _, elem := range s.SuggestedTipAmounts {
				e.Int64(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ProviderData.Set {
			e.FieldStart("provider_data")
			s.ProviderData.Encode(e)
		}
	}
	{
		if s.PhotoURL.Set {
			e.FieldStart("photo_url")
			s.PhotoURL.Encode(e)
		}
	}
	{
		if s.PhotoSize.Set {
			e.FieldStart("photo_size")
			s.PhotoSize.Encode(e)
		}
	}
	{
		if s.PhotoWidth.Set {
			e.FieldStart("photo_width")
			s.PhotoWidth.Encode(e)
		}
	}
	{
		if s.PhotoHeight.Set {
			e.FieldStart("photo_height")
			s.PhotoHeight.Encode(e)
		}
	}
	{
		if s.NeedName.Set {
			e.FieldStart("need_name")
			s.NeedName.Encode(e)
		}
	}
	{
		if s.NeedPhoneNumber.Set {
			e.FieldStart("need_phone_number")
			s.NeedPhoneNumber.Encode(e)
		}
	}
	{
		if s.NeedEmail.Set {
			e.FieldStart("need_email")
			s.NeedEmail.Encode(e)
		}
	}
	{
		if s.NeedShippingAddress.Set {
			e.FieldStart("need_shipping_address")
			s.NeedShippingAddress.Encode(e)
		}
	}
	{
		if s.SendPhoneNumberToProvider.Set {
			e.FieldStart("send_phone_number_to_provider")
			s.SendPhoneNumberToProvider.Encode(e)
		}
	}
	{
		if s.SendEmailToProvider.Set {
			e.FieldStart("send_email_to_provider")
			s.SendEmailToProvider.Encode(e)
		}
	}
	{
		if s.IsFlexible.Set {
			e.FieldStart("is_flexible")
			s.IsFlexible.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputInvoiceMessageContent = [20]string{
	0:  "title",
	1:  "description",
	2:  "payload",
	3:  "provider_token",
	4:  "currency",
	5:  "prices",
	6:  "max_tip_amount",
	7:  "suggested_tip_amounts",
	8:  "provider_data",
	9:  "photo_url",
	10: "photo_size",
	11: "photo_width",
	12: "photo_height",
	13: "need_name",
	14: "need_phone_number",
	15: "need_email",
	16: "need_shipping_address",
	17: "send_phone_number_to_provider",
	18: "send_email_to_provider",
	19: "is_flexible",
}

// Decode decodes InputInvoiceMessageContent from json.
func (s *InputInvoiceMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputInvoiceMessageContent to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Payload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "provider_token":
			if err := func() error {
				s.ProviderToken.Reset()
				if err := s.ProviderToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_token\"")
			}
		case "currency":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "prices":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Prices = make([]LabeledPrice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LabeledPrice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Prices = append(s.Prices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prices\"")
			}
		case "max_tip_amount":
			if err := func() error {
				s.MaxTipAmount.Reset()
				if err := s.MaxTipAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_tip_amount\"")
			}
		case "suggested_tip_amounts":
			if err := func() error {
				s.SuggestedTipAmounts = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int64
					v, err := d.Int64()
					elem = int64(v)
					if err != nil {
						return err
					}
					s.SuggestedTipAmounts = append(s.SuggestedTipAmounts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suggested_tip_amounts\"")
			}
		case "provider_data":
			if err := func() error {
				s.ProviderData.Reset()
				if err := s.ProviderData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_data\"")
			}
		case "photo_url":
			if err := func() error {
				s.PhotoURL.Reset()
				if err := s.PhotoURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_url\"")
			}
		case "photo_size":
			if err := func() error {
				s.PhotoSize.Reset()
				if err := s.PhotoSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_size\"")
			}
		case "photo_width":
			if err := func() error {
				s.PhotoWidth.Reset()
				if err := s.PhotoWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_width\"")
			}
		case "photo_height":
			if err := func() error {
				s.PhotoHeight.Reset()
				if err := s.PhotoHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_height\"")
			}
		case "need_name":
			if err := func() error {
				s.NeedName.Reset()
				if err := s.NeedName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_name\"")
			}
		case "need_phone_number":
			if err := func() error {
				s.NeedPhoneNumber.Reset()
				if err := s.NeedPhoneNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_phone_number\"")
			}
		case "need_email":
			if err := func() error {
				s.NeedEmail.Reset()
				if err := s.NeedEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_email\"")
			}
		case "need_shipping_address":
			if err := func() error {
				s.NeedShippingAddress.Reset()
				if err := s.NeedShippingAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_shipping_address\"")
			}
		case "send_phone_number_to_provider":
			if err := func() error {
				s.SendPhoneNumberToProvider.Reset()
				if err := s.SendPhoneNumberToProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"send_phone_number_to_provider\"")
			}
		case "send_email_to_provider":
			if err := func() error {
				s.SendEmailToProvider.Reset()
				if err := s.SendEmailToProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"send_email_to_provider\"")
			}
		case "is_flexible":
			if err := func() error {
				s.IsFlexible.Reset()
				if err := s.IsFlexible.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_flexible\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputInvoiceMessageContent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00110111,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputInvoiceMessageContent) {
					name = jsonFieldsNameOfInputInvoiceMessageContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputInvoiceMessageContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputInvoiceMessageContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputLocationMessageContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputLocationMessageContent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		if s.HorizontalAccuracy.Set {
			e.FieldStart("horizontal_accuracy")
			s.HorizontalAccuracy.Encode(e)
		}
	}
	{
		if s.LivePeriod.Set {
			e.FieldStart("live_period")
			s.LivePeriod.Encode(e)
		}
	}
	{
		if s.Heading.Set {
			e.FieldStart("heading")
			s.Heading.Encode(e)
		}
	}
	{
		if s.ProximityAlertRadius.Set {
			e.FieldStart("proximity_alert_radius")
			s.ProximityAlertRadius.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputLocationMessageContent = [6]string{
	0: "latitude",
	1: "longitude",
	2: "horizontal_accuracy",
	3: "live_period",
	4: "heading",
	5: "proximity_alert_radius",
}

// Decode decodes InputLocationMessageContent from json.
func (s *InputLocationMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputLocationMessageContent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "latitude":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "horizontal_accuracy":
			if err := func() error {
				s.HorizontalAccuracy.Reset()
				if err := s.HorizontalAccuracy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"horizontal_accuracy\"")
			}
		case "live_period":
			if err := func() error {
				s.LivePeriod.Reset()
				if err := s.LivePeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"live_period\"")
			}
		case "heading":
			if err := func() error {
				s.Heading.Reset()
				if err := s.Heading.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heading\"")
			}
		case "proximity_alert_radius":
			if err := func() error {
				s.ProximityAlertRadius.Reset()
				if err := s.ProximityAlertRadius.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proximity_alert_radius\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputLocationMessageContent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputLocationMessageContent) {
					name = jsonFieldsNameOfInputLocationMessageContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputLocationMessageContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputLocationMessageContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InputMedia as json.
func (s InputMedia) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s InputMedia) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InputMediaAnimationInputMedia:
		e.FieldStart("type")
		e.Str("animation")
		{
			s := s.InputMediaAnimation
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Thumbnail.Set {
					e.FieldStart("thumbnail")
					s.Thumbnail.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ShowCaptionAboveMedia.Set {
					e.FieldStart("show_caption_above_media")
					s.ShowCaptionAboveMedia.Encode(e)
				}
			}
			{
				if s.Width.Set {
					e.FieldStart("width")
					s.Width.Encode(e)
				}
			}
			{
				if s.Height.Set {
					e.FieldStart("height")
					s.Height.Encode(e)
				}
			}
			{
				if s.Duration.Set {
					e.FieldStart("duration")
					s.Duration.Encode(e)
				}
			}
			{
				if s.HasSpoiler.Set {
					e.FieldStart("has_spoiler")
					s.HasSpoiler.Encode(e)
				}
			}
		}
	case InputMediaAudioInputMedia:
		e.FieldStart("type")
		e.Str("audio")
		{
			s := s.InputMediaAudio
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Thumbnail.Set {
					e.FieldStart("thumbnail")
					s.Thumbnail.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.Duration.Set {
					e.FieldStart("duration")
					s.Duration.Encode(e)
				}
			}
			{
				if s.Performer.Set {
					e.FieldStart("performer")
					s.Performer.Encode(e)
				}
			}
			{
				if s.Title.Set {
					e.FieldStart("title")
					s.Title.Encode(e)
				}
			}
		}
	case InputMediaDocumentInputMedia:
		e.FieldStart("type")
		e.Str("document")
		{
			s := s.InputMediaDocument
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Thumbnail.Set {
					e.FieldStart("thumbnail")
					s.Thumbnail.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.DisableContentTypeDetection.Set {
					e.FieldStart("disable_content_type_detection")
					s.DisableContentTypeDetection.Encode(e)
				}
			}
		}
	case InputMediaPhotoInputMedia:
		e.FieldStart("type")
		e.Str("photo")
		{
			s := s.InputMediaPhoto
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ShowCaptionAboveMedia.Set {
					e.FieldStart("show_caption_above_media")
					s.ShowCaptionAboveMedia.Encode(e)
				}
			}
			{
				if s.HasSpoiler.Set {
					e.FieldStart("has_spoiler")
					s.HasSpoiler.Encode(e)
				}
			}
		}
	case InputMediaVideoInputMedia:
		e.FieldStart("type")
		e.Str("video")
		{
			s := s.InputMediaVideo
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Thumbnail.Set {
					e.FieldStart("thumbnail")
					s.Thumbnail.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ShowCaptionAboveMedia.Set {
					e.FieldStart("show_caption_above_media")
					s.ShowCaptionAboveMedia.Encode(e)
				}
			}
			{
				if s.Width.Set {
					e.FieldStart("width")
					s.Width.Encode(e)
				}
			}
			{
				if s.Height.Set {
					e.FieldStart("height")
					s.Height.Encode(e)
				}
			}
			{
				if s.Duration.Set {
					e.FieldStart("duration")
					s.Duration.Encode(e)
				}
			}
			{
				if s.SupportsStreaming.Set {
					e.FieldStart("supports_streaming")
					s.SupportsStreaming.Encode(e)
				}
			}
			{
				if s.HasSpoiler.Set {
					e.FieldStart("has_spoiler")
					s.HasSpoiler.Encode(e)
				}
			}
		}
	}
}

// Decode decodes InputMedia from json.
func (s *InputMedia) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputMedia to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "animation":
					s.Type = InputMediaAnimationInputMedia
					found = true
				case "audio":
					s.Type = InputMediaAudioInputMedia
					found = true
				case "document":
					s.Type = InputMediaDocumentInputMedia
					found = true
				case "photo":
					s.Type = InputMediaPhotoInputMedia
					found = true
				case "video":
					s.Type = InputMediaVideoInputMedia
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InputMediaAnimationInputMedia:
		if err := s.InputMediaAnimation.Decode(d); err != nil {
			return err
		}
	case InputMediaDocumentInputMedia:
		if err := s.InputMediaDocument.Decode(d); err != nil {
			return err
		}
	case InputMediaAudioInputMedia:
		if err := s.InputMediaAudio.Decode(d); err != nil {
			return err
		}
	case InputMediaPhotoInputMedia:
		if err := s.InputMediaPhoto.Decode(d); err != nil {
			return err
		}
	case InputMediaVideoInputMedia:
		if err := s.InputMediaVideo.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InputMedia) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputMedia) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputMediaAnimation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputMediaAnimation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("media")
		e.Str(s.Media)
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.Width.Set {
			e.FieldStart("width")
			s.Width.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.HasSpoiler.Set {
			e.FieldStart("has_spoiler")
			s.HasSpoiler.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputMediaAnimation = [11]string{
	0:  "type",
	1:  "media",
	2:  "thumbnail",
	3:  "caption",
	4:  "parse_mode",
	5:  "caption_entities",
	6:  "show_caption_above_media",
	7:  "width",
	8:  "height",
	9:  "duration",
	10: "has_spoiler",
}

// Decode decodes InputMediaAnimation from json.
func (s *InputMediaAnimation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputMediaAnimation to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Media = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "width":
			if err := func() error {
				s.Width.Reset()
				if err := s.Width.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "has_spoiler":
			if err := func() error {
				s.HasSpoiler.Reset()
				if err := s.HasSpoiler.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_spoiler\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputMediaAnimation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputMediaAnimation) {
					name = jsonFieldsNameOfInputMediaAnimation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputMediaAnimation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputMediaAnimation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputMediaAudio) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputMediaAudio) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("media")
		e.Str(s.Media)
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Performer.Set {
			e.FieldStart("performer")
			s.Performer.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputMediaAudio = [9]string{
	0: "type",
	1: "media",
	2: "thumbnail",
	3: "caption",
	4: "parse_mode",
	5: "caption_entities",
	6: "duration",
	7: "performer",
	8: "title",
}

// Decode decodes InputMediaAudio from json.
func (s *InputMediaAudio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputMediaAudio to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Media = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "performer":
			if err := func() error {
				s.Performer.Reset()
				if err := s.Performer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performer\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputMediaAudio")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputMediaAudio) {
					name = jsonFieldsNameOfInputMediaAudio[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputMediaAudio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputMediaAudio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputMediaDocument) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputMediaDocument) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("media")
		e.Str(s.Media)
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableContentTypeDetection.Set {
			e.FieldStart("disable_content_type_detection")
			s.DisableContentTypeDetection.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputMediaDocument = [7]string{
	0: "type",
	1: "media",
	2: "thumbnail",
	3: "caption",
	4: "parse_mode",
	5: "caption_entities",
	6: "disable_content_type_detection",
}

// Decode decodes InputMediaDocument from json.
func (s *InputMediaDocument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputMediaDocument to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Media = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "disable_content_type_detection":
			if err := func() error {
				s.DisableContentTypeDetection.Reset()
				if err := s.DisableContentTypeDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_content_type_detection\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputMediaDocument")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputMediaDocument) {
					name = jsonFieldsNameOfInputMediaDocument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputMediaDocument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputMediaDocument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputMediaPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputMediaPhoto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("media")
		e.Str(s.Media)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.HasSpoiler.Set {
			e.FieldStart("has_spoiler")
			s.HasSpoiler.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputMediaPhoto = [7]string{
	0: "type",
	1: "media",
	2: "caption",
	3: "parse_mode",
	4: "caption_entities",
	5: "show_caption_above_media",
	6: "has_spoiler",
}

// Decode decodes InputMediaPhoto from json.
func (s *InputMediaPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputMediaPhoto to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Media = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "has_spoiler":
			if err := func() error {
				s.HasSpoiler.Reset()
				if err := s.HasSpoiler.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_spoiler\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputMediaPhoto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputMediaPhoto) {
					name = jsonFieldsNameOfInputMediaPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputMediaPhoto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputMediaPhoto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputMediaVideo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputMediaVideo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("media")
		e.Str(s.Media)
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.Width.Set {
			e.FieldStart("width")
			s.Width.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.SupportsStreaming.Set {
			e.FieldStart("supports_streaming")
			s.SupportsStreaming.Encode(e)
		}
	}
	{
		if s.HasSpoiler.Set {
			e.FieldStart("has_spoiler")
			s.HasSpoiler.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputMediaVideo = [12]string{
	0:  "type",
	1:  "media",
	2:  "thumbnail",
	3:  "caption",
	4:  "parse_mode",
	5:  "caption_entities",
	6:  "show_caption_above_media",
	7:  "width",
	8:  "height",
	9:  "duration",
	10: "supports_streaming",
	11: "has_spoiler",
}

// Decode decodes InputMediaVideo from json.
func (s *InputMediaVideo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputMediaVideo to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Media = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "width":
			if err := func() error {
				s.Width.Reset()
				if err := s.Width.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "supports_streaming":
			if err := func() error {
				s.SupportsStreaming.Reset()
				if err := s.SupportsStreaming.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supports_streaming\"")
			}
		case "has_spoiler":
			if err := func() error {
				s.HasSpoiler.Reset()
				if err := s.HasSpoiler.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_spoiler\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputMediaVideo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputMediaVideo) {
					name = jsonFieldsNameOfInputMediaVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputMediaVideo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputMediaVideo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InputMessageContent as json.
func (s InputMessageContent) Encode(e *jx.Encoder) {
	switch s.Type {
	case InputTextMessageContentInputMessageContent:
		s.InputTextMessageContent.Encode(e)
	case InputLocationMessageContentInputMessageContent:
		s.InputLocationMessageContent.Encode(e)
	case InputVenueMessageContentInputMessageContent:
		s.InputVenueMessageContent.Encode(e)
	case InputContactMessageContentInputMessageContent:
		s.InputContactMessageContent.Encode(e)
	case InputInvoiceMessageContentInputMessageContent:
		s.InputInvoiceMessageContent.Encode(e)
	}
}

func (s InputMessageContent) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InputTextMessageContentInputMessageContent:
		s.InputTextMessageContent.encodeFields(e)
	case InputLocationMessageContentInputMessageContent:
		s.InputLocationMessageContent.encodeFields(e)
	case InputVenueMessageContentInputMessageContent:
		s.InputVenueMessageContent.encodeFields(e)
	case InputContactMessageContentInputMessageContent:
		s.InputContactMessageContent.encodeFields(e)
	case InputInvoiceMessageContentInputMessageContent:
		s.InputInvoiceMessageContent.encodeFields(e)
	}
}

// Decode decodes InputMessageContent from json.
func (s *InputMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputMessageContent to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "message_text":
				match := InputTextMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "parse_mode":
				match := InputTextMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "entities":
				match := InputTextMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "link_preview_options":
				match := InputTextMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "horizontal_accuracy":
				match := InputLocationMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "live_period":
				match := InputLocationMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "heading":
				match := InputLocationMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "proximity_alert_radius":
				match := InputLocationMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "address":
				match := InputVenueMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "foursquare_id":
				match := InputVenueMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "foursquare_type":
				match := InputVenueMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "google_place_id":
				match := InputVenueMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "google_place_type":
				match := InputVenueMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "phone_number":
				match := InputContactMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "first_name":
				match := InputContactMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "last_name":
				match := InputContactMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "vcard":
				match := InputContactMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "description":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "payload":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "provider_token":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "currency":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "prices":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "max_tip_amount":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "suggested_tip_amounts":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "provider_data":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "photo_url":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "photo_size":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "photo_width":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "photo_height":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "need_name":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "need_phone_number":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "need_email":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "need_shipping_address":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "send_phone_number_to_provider":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "send_email_to_provider":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "is_flexible":
				match := InputInvoiceMessageContentInputMessageContent
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InputTextMessageContentInputMessageContent:
		if err := s.InputTextMessageContent.Decode(d); err != nil {
			return err
		}
	case InputLocationMessageContentInputMessageContent:
		if err := s.InputLocationMessageContent.Decode(d); err != nil {
			return err
		}
	case InputVenueMessageContentInputMessageContent:
		if err := s.InputVenueMessageContent.Decode(d); err != nil {
			return err
		}
	case InputContactMessageContentInputMessageContent:
		if err := s.InputContactMessageContent.Decode(d); err != nil {
			return err
		}
	case InputInvoiceMessageContentInputMessageContent:
		if err := s.InputInvoiceMessageContent.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InputMessageContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputMessageContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InputPaidMedia as json.
func (s InputPaidMedia) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s InputPaidMedia) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InputPaidMediaPhotoInputPaidMedia:
		e.FieldStart("type")
		e.Str("photo")
		{
			s := s.InputPaidMediaPhoto
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
		}
	case InputPaidMediaVideoInputPaidMedia:
		e.FieldStart("type")
		e.Str("video")
		{
			s := s.InputPaidMediaVideo
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Thumbnail.Set {
					e.FieldStart("thumbnail")
					s.Thumbnail.Encode(e)
				}
			}
			{
				if s.Width.Set {
					e.FieldStart("width")
					s.Width.Encode(e)
				}
			}
			{
				if s.Height.Set {
					e.FieldStart("height")
					s.Height.Encode(e)
				}
			}
			{
				if s.Duration.Set {
					e.FieldStart("duration")
					s.Duration.Encode(e)
				}
			}
			{
				if s.SupportsStreaming.Set {
					e.FieldStart("supports_streaming")
					s.SupportsStreaming.Encode(e)
				}
			}
		}
	}
}

// Decode decodes InputPaidMedia from json.
func (s *InputPaidMedia) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputPaidMedia to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "photo":
					s.Type = InputPaidMediaPhotoInputPaidMedia
					found = true
				case "video":
					s.Type = InputPaidMediaVideoInputPaidMedia
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InputPaidMediaPhotoInputPaidMedia:
		if err := s.InputPaidMediaPhoto.Decode(d); err != nil {
			return err
		}
	case InputPaidMediaVideoInputPaidMedia:
		if err := s.InputPaidMediaVideo.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InputPaidMedia) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputPaidMedia) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputPaidMediaPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputPaidMediaPhoto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("media")
		e.Str(s.Media)
	}
}

var jsonFieldsNameOfInputPaidMediaPhoto = [2]string{
	0: "type",
	1: "media",
}

// Decode decodes InputPaidMediaPhoto from json.
func (s *InputPaidMediaPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputPaidMediaPhoto to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Media = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputPaidMediaPhoto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputPaidMediaPhoto) {
					name = jsonFieldsNameOfInputPaidMediaPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputPaidMediaPhoto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputPaidMediaPhoto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputPaidMediaVideo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputPaidMediaVideo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("media")
		e.Str(s.Media)
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
	{
		if s.Width.Set {
			e.FieldStart("width")
			s.Width.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.SupportsStreaming.Set {
			e.FieldStart("supports_streaming")
			s.SupportsStreaming.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputPaidMediaVideo = [7]string{
	0: "type",
	1: "media",
	2: "thumbnail",
	3: "width",
	4: "height",
	5: "duration",
	6: "supports_streaming",
}

// Decode decodes InputPaidMediaVideo from json.
func (s *InputPaidMediaVideo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputPaidMediaVideo to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Media = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "width":
			if err := func() error {
				s.Width.Reset()
				if err := s.Width.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "supports_streaming":
			if err := func() error {
				s.SupportsStreaming.Reset()
				if err := s.SupportsStreaming.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supports_streaming\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputPaidMediaVideo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputPaidMediaVideo) {
					name = jsonFieldsNameOfInputPaidMediaVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputPaidMediaVideo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputPaidMediaVideo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputPollOption) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputPollOption) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.TextParseMode.Set {
			e.FieldStart("text_parse_mode")
			s.TextParseMode.Encode(e)
		}
	}
	{
		if s.TextEntities != nil {
			e.FieldStart("text_entities")
			e.ArrStart()
			for _, elem := range s.TextEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInputPollOption = [3]string{
	0: "text",
	1: "text_parse_mode",
	2: "text_entities",
}

// Decode decodes InputPollOption from json.
func (s *InputPollOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputPollOption to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "text_parse_mode":
			if err := func() error {
				s.TextParseMode.Reset()
				if err := s.TextParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_parse_mode\"")
			}
		case "text_entities":
			if err := func() error {
				s.TextEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TextEntities = append(s.TextEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_entities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputPollOption")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputPollOption) {
					name = jsonFieldsNameOfInputPollOption[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputPollOption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputPollOption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputSticker) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputSticker) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sticker")
		e.Str(s.Sticker)
	}
	{
		e.FieldStart("format")
		e.Str(s.Format)
	}
	{
		e.FieldStart("emoji_list")
		e.ArrStart()
		for _, elem := range s.EmojiList {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.MaskPosition.Set {
			e.FieldStart("mask_position")
			s.MaskPosition.Encode(e)
		}
	}
	{
		if s.Keywords != nil {
			e.FieldStart("keywords")
			e.ArrStart()
			for _, elem := range s.Keywords {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInputSticker = [5]string{
	0: "sticker",
	1: "format",
	2: "emoji_list",
	3: "mask_position",
	4: "keywords",
}

// Decode decodes InputSticker from json.
func (s *InputSticker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputSticker to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sticker":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sticker = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		case "format":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Format = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "emoji_list":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.EmojiList = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.EmojiList = append(s.EmojiList, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emoji_list\"")
			}
		case "mask_position":
			if err := func() error {
				s.MaskPosition.Reset()
				if err := s.MaskPosition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mask_position\"")
			}
		case "keywords":
			if err := func() error {
				s.Keywords = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Keywords = append(s.Keywords, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keywords\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputSticker")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputSticker) {
					name = jsonFieldsNameOfInputSticker[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputSticker) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputSticker) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputTextMessageContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputTextMessageContent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message_text")
		e.Str(s.MessageText)
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.Entities != nil {
			e.FieldStart("entities")
			e.ArrStart()
			for _, elem := range s.Entities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LinkPreviewOptions.Set {
			e.FieldStart("link_preview_options")
			s.LinkPreviewOptions.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputTextMessageContent = [4]string{
	0: "message_text",
	1: "parse_mode",
	2: "entities",
	3: "link_preview_options",
}

// Decode decodes InputTextMessageContent from json.
func (s *InputTextMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputTextMessageContent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message_text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MessageText = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_text\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "entities":
			if err := func() error {
				s.Entities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entities = append(s.Entities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entities\"")
			}
		case "link_preview_options":
			if err := func() error {
				s.LinkPreviewOptions.Reset()
				if err := s.LinkPreviewOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_preview_options\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputTextMessageContent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputTextMessageContent) {
					name = jsonFieldsNameOfInputTextMessageContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputTextMessageContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputTextMessageContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InputVenueMessageContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InputVenueMessageContent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		if s.FoursquareID.Set {
			e.FieldStart("foursquare_id")
			s.FoursquareID.Encode(e)
		}
	}
	{
		if s.FoursquareType.Set {
			e.FieldStart("foursquare_type")
			s.FoursquareType.Encode(e)
		}
	}
	{
		if s.GooglePlaceID.Set {
			e.FieldStart("google_place_id")
			s.GooglePlaceID.Encode(e)
		}
	}
	{
		if s.GooglePlaceType.Set {
			e.FieldStart("google_place_type")
			s.GooglePlaceType.Encode(e)
		}
	}
}

var jsonFieldsNameOfInputVenueMessageContent = [8]string{
	0: "latitude",
	1: "longitude",
	2: "title",
	3: "address",
	4: "foursquare_id",
	5: "foursquare_type",
	6: "google_place_id",
	7: "google_place_type",
}

// Decode decodes InputVenueMessageContent from json.
func (s *InputVenueMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InputVenueMessageContent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "latitude":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "foursquare_id":
			if err := func() error {
				s.FoursquareID.Reset()
				if err := s.FoursquareID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foursquare_id\"")
			}
		case "foursquare_type":
			if err := func() error {
				s.FoursquareType.Reset()
				if err := s.FoursquareType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foursquare_type\"")
			}
		case "google_place_id":
			if err := func() error {
				s.GooglePlaceID.Reset()
				if err := s.GooglePlaceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_place_id\"")
			}
		case "google_place_type":
			if err := func() error {
				s.GooglePlaceType.Reset()
				if err := s.GooglePlaceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_place_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InputVenueMessageContent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputVenueMessageContent) {
					name = jsonFieldsNameOfInputVenueMessageContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InputVenueMessageContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InputVenueMessageContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Invoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Invoice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("start_parameter")
		e.Str(s.StartParameter)
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("total_amount")
		e.Int(s.TotalAmount)
	}
}

var jsonFieldsNameOfInvoice = [5]string{
	0: "title",
	1: "description",
	2: "start_parameter",
	3: "currency",
	4: "total_amount",
}

// Decode decodes Invoice from json.
func (s *Invoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Invoice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "start_parameter":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StartParameter = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_parameter\"")
			}
		case "currency":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "total_amount":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TotalAmount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Invoice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoice) {
					name = jsonFieldsNameOfInvoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Invoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Invoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes KeyboardButton as json.
func (s KeyboardButton) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringKeyboardButton:
		e.Str(s.String)
	case KeyboardButtonObjectKeyboardButton:
		s.KeyboardButtonObject.Encode(e)
	}
}

// Decode decodes KeyboardButton from json.
func (s *KeyboardButton) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeyboardButton to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.KeyboardButtonObject.Decode(d); err != nil {
			return err
		}
		s.Type = KeyboardButtonObjectKeyboardButton
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringKeyboardButton
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s KeyboardButton) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeyboardButton) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KeyboardButtonObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KeyboardButtonObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.RequestUsers.Set {
			e.FieldStart("request_users")
			s.RequestUsers.Encode(e)
		}
	}
	{
		if s.RequestChat.Set {
			e.FieldStart("request_chat")
			s.RequestChat.Encode(e)
		}
	}
	{
		if s.RequestContact.Set {
			e.FieldStart("request_contact")
			s.RequestContact.Encode(e)
		}
	}
	{
		if s.RequestLocation.Set {
			e.FieldStart("request_location")
			s.RequestLocation.Encode(e)
		}
	}
	{
		if s.RequestPoll.Set {
			e.FieldStart("request_poll")
			s.RequestPoll.Encode(e)
		}
	}
	{
		if s.WebApp.Set {
			e.FieldStart("web_app")
			s.WebApp.Encode(e)
		}
	}
}

var jsonFieldsNameOfKeyboardButtonObject = [7]string{
	0: "text",
	1: "request_users",
	2: "request_chat",
	3: "request_contact",
	4: "request_location",
	5: "request_poll",
	6: "web_app",
}

// Decode decodes KeyboardButtonObject from json.
func (s *KeyboardButtonObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeyboardButtonObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "request_users":
			if err := func() error {
				s.RequestUsers.Reset()
				if err := s.RequestUsers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_users\"")
			}
		case "request_chat":
			if err := func() error {
				s.RequestChat.Reset()
				if err := s.RequestChat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_chat\"")
			}
		case "request_contact":
			if err := func() error {
				s.RequestContact.Reset()
				if err := s.RequestContact.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_contact\"")
			}
		case "request_location":
			if err := func() error {
				s.RequestLocation.Reset()
				if err := s.RequestLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_location\"")
			}
		case "request_poll":
			if err := func() error {
				s.RequestPoll.Reset()
				if err := s.RequestPoll.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_poll\"")
			}
		case "web_app":
			if err := func() error {
				s.WebApp.Reset()
				if err := s.WebApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"web_app\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KeyboardButtonObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfKeyboardButtonObject) {
					name = jsonFieldsNameOfKeyboardButtonObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KeyboardButtonObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeyboardButtonObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KeyboardButtonPollType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KeyboardButtonPollType) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfKeyboardButtonPollType = [1]string{
	0: "type",
}

// Decode decodes KeyboardButtonPollType from json.
func (s *KeyboardButtonPollType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeyboardButtonPollType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KeyboardButtonPollType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KeyboardButtonPollType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeyboardButtonPollType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KeyboardButtonRequestChat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KeyboardButtonRequestChat) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("request_id")
		e.Int(s.RequestID)
	}
	{
		e.FieldStart("chat_is_channel")
		e.Bool(s.ChatIsChannel)
	}
	{
		if s.ChatIsForum.Set {
			e.FieldStart("chat_is_forum")
			s.ChatIsForum.Encode(e)
		}
	}
	{
		if s.ChatHasUsername.Set {
			e.FieldStart("chat_has_username")
			s.ChatHasUsername.Encode(e)
		}
	}
	{
		if s.ChatIsCreated.Set {
			e.FieldStart("chat_is_created")
			s.ChatIsCreated.Encode(e)
		}
	}
	{
		if s.UserAdministratorRights.Set {
			e.FieldStart("user_administrator_rights")
			s.UserAdministratorRights.Encode(e)
		}
	}
	{
		if s.BotAdministratorRights.Set {
			e.FieldStart("bot_administrator_rights")
			s.BotAdministratorRights.Encode(e)
		}
	}
	{
		if s.BotIsMember.Set {
			e.FieldStart("bot_is_member")
			s.BotIsMember.Encode(e)
		}
	}
	{
		if s.RequestTitle.Set {
			e.FieldStart("request_title")
			s.RequestTitle.Encode(e)
		}
	}
	{
		if s.RequestUsername.Set {
			e.FieldStart("request_username")
			s.RequestUsername.Encode(e)
		}
	}
	{
		if s.RequestPhoto.Set {
			e.FieldStart("request_photo")
			s.RequestPhoto.Encode(e)
		}
	}
}

var jsonFieldsNameOfKeyboardButtonRequestChat = [11]string{
	0:  "request_id",
	1:  "chat_is_channel",
	2:  "chat_is_forum",
	3:  "chat_has_username",
	4:  "chat_is_created",
	5:  "user_administrator_rights",
	6:  "bot_administrator_rights",
	7:  "bot_is_member",
	8:  "request_title",
	9:  "request_username",
	10: "request_photo",
}

// Decode decodes KeyboardButtonRequestChat from json.
func (s *KeyboardButtonRequestChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeyboardButtonRequestChat to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "request_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.RequestID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		case "chat_is_channel":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.ChatIsChannel = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_is_channel\"")
			}
		case "chat_is_forum":
			if err := func() error {
				s.ChatIsForum.Reset()
				if err := s.ChatIsForum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_is_forum\"")
			}
		case "chat_has_username":
			if err := func() error {
				s.ChatHasUsername.Reset()
				if err := s.ChatHasUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_has_username\"")
			}
		case "chat_is_created":
			if err := func() error {
				s.ChatIsCreated.Reset()
				if err := s.ChatIsCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_is_created\"")
			}
		case "user_administrator_rights":
			if err := func() error {
				s.UserAdministratorRights.Reset()
				if err := s.UserAdministratorRights.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_administrator_rights\"")
			}
		case "bot_administrator_rights":
			if err := func() error {
				s.BotAdministratorRights.Reset()
				if err := s.BotAdministratorRights.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bot_administrator_rights\"")
			}
		case "bot_is_member":
			if err := func() error {
				s.BotIsMember.Reset()
				if err := s.BotIsMember.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bot_is_member\"")
			}
		case "request_title":
			if err := func() error {
				s.RequestTitle.Reset()
				if err := s.RequestTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_title\"")
			}
		case "request_username":
			if err := func() error {
				s.RequestUsername.Reset()
				if err := s.RequestUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_username\"")
			}
		case "request_photo":
			if err := func() error {
				s.RequestPhoto.Reset()
				if err := s.RequestPhoto.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_photo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KeyboardButtonRequestChat")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfKeyboardButtonRequestChat) {
					name = jsonFieldsNameOfKeyboardButtonRequestChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KeyboardButtonRequestChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeyboardButtonRequestChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KeyboardButtonRequestUsers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KeyboardButtonRequestUsers) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("request_id")
		e.Int(s.RequestID)
	}
	{
		if s.UserIsBot.Set {
			e.FieldStart("user_is_bot")
			s.UserIsBot.Encode(e)
		}
	}
	{
		if s.UserIsPremium.Set {
			e.FieldStart("user_is_premium")
			s.UserIsPremium.Encode(e)
		}
	}
	{
		if s.MaxQuantity.Set {
			e.FieldStart("max_quantity")
			s.MaxQuantity.Encode(e)
		}
	}
	{
		if s.RequestName.Set {
			e.FieldStart("request_name")
			s.RequestName.Encode(e)
		}
	}
	{
		if s.RequestUsername.Set {
			e.FieldStart("request_username")
			s.RequestUsername.Encode(e)
		}
	}
	{
		if s.RequestPhoto.Set {
			e.FieldStart("request_photo")
			s.RequestPhoto.Encode(e)
		}
	}
}

var jsonFieldsNameOfKeyboardButtonRequestUsers = [7]string{
	0: "request_id",
	1: "user_is_bot",
	2: "user_is_premium",
	3: "max_quantity",
	4: "request_name",
	5: "request_username",
	6: "request_photo",
}

// Decode decodes KeyboardButtonRequestUsers from json.
func (s *KeyboardButtonRequestUsers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeyboardButtonRequestUsers to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "request_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.RequestID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		case "user_is_bot":
			if err := func() error {
				s.UserIsBot.Reset()
				if err := s.UserIsBot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_is_bot\"")
			}
		case "user_is_premium":
			if err := func() error {
				s.UserIsPremium.Reset()
				if err := s.UserIsPremium.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_is_premium\"")
			}
		case "max_quantity":
			if err := func() error {
				s.MaxQuantity.Reset()
				if err := s.MaxQuantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_quantity\"")
			}
		case "request_name":
			if err := func() error {
				s.RequestName.Reset()
				if err := s.RequestName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_name\"")
			}
		case "request_username":
			if err := func() error {
				s.RequestUsername.Reset()
				if err := s.RequestUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_username\"")
			}
		case "request_photo":
			if err := func() error {
				s.RequestPhoto.Reset()
				if err := s.RequestPhoto.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_photo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KeyboardButtonRequestUsers")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfKeyboardButtonRequestUsers) {
					name = jsonFieldsNameOfKeyboardButtonRequestUsers[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KeyboardButtonRequestUsers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeyboardButtonRequestUsers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LabeledPrice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LabeledPrice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("label")
		e.Str(s.Label)
	}
	{
		e.FieldStart("amount")
		e.Int(s.Amount)
	}
}

var jsonFieldsNameOfLabeledPrice = [2]string{
	0: "label",
	1: "amount",
}

// Decode decodes LabeledPrice from json.
func (s *LabeledPrice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LabeledPrice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Amount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LabeledPrice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLabeledPrice) {
					name = jsonFieldsNameOfLabeledPrice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LabeledPrice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LabeledPrice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeaveChat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeaveChat) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfLeaveChat = [1]string{
	0: "chat_id",
}

// Decode decodes LeaveChat from json.
func (s *LeaveChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaveChat to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeaveChat")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeaveChat) {
					name = jsonFieldsNameOfLeaveChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaveChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaveChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LinkPreviewOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LinkPreviewOptions) encodeFields(e *jx.Encoder) {
	{
		if s.IsDisabled.Set {
			e.FieldStart("is_disabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.PreferSmallMedia.Set {
			e.FieldStart("prefer_small_media")
			s.PreferSmallMedia.Encode(e)
		}
	}
	{
		if s.PreferLargeMedia.Set {
			e.FieldStart("prefer_large_media")
			s.PreferLargeMedia.Encode(e)
		}
	}
	{
		if s.ShowAboveText.Set {
			e.FieldStart("show_above_text")
			s.ShowAboveText.Encode(e)
		}
	}
}

var jsonFieldsNameOfLinkPreviewOptions = [5]string{
	0: "is_disabled",
	1: "url",
	2: "prefer_small_media",
	3: "prefer_large_media",
	4: "show_above_text",
}

// Decode decodes LinkPreviewOptions from json.
func (s *LinkPreviewOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LinkPreviewOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_disabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_disabled\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "prefer_small_media":
			if err := func() error {
				s.PreferSmallMedia.Reset()
				if err := s.PreferSmallMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prefer_small_media\"")
			}
		case "prefer_large_media":
			if err := func() error {
				s.PreferLargeMedia.Reset()
				if err := s.PreferLargeMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prefer_large_media\"")
			}
		case "show_above_text":
			if err := func() error {
				s.ShowAboveText.Reset()
				if err := s.ShowAboveText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_above_text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LinkPreviewOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LinkPreviewOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LinkPreviewOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Location) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Location) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		if s.HorizontalAccuracy.Set {
			e.FieldStart("horizontal_accuracy")
			s.HorizontalAccuracy.Encode(e)
		}
	}
	{
		if s.LivePeriod.Set {
			e.FieldStart("live_period")
			s.LivePeriod.Encode(e)
		}
	}
	{
		if s.Heading.Set {
			e.FieldStart("heading")
			s.Heading.Encode(e)
		}
	}
	{
		if s.ProximityAlertRadius.Set {
			e.FieldStart("proximity_alert_radius")
			s.ProximityAlertRadius.Encode(e)
		}
	}
}

var jsonFieldsNameOfLocation = [6]string{
	0: "latitude",
	1: "longitude",
	2: "horizontal_accuracy",
	3: "live_period",
	4: "heading",
	5: "proximity_alert_radius",
}

// Decode decodes Location from json.
func (s *Location) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Location to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "latitude":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "horizontal_accuracy":
			if err := func() error {
				s.HorizontalAccuracy.Reset()
				if err := s.HorizontalAccuracy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"horizontal_accuracy\"")
			}
		case "live_period":
			if err := func() error {
				s.LivePeriod.Reset()
				if err := s.LivePeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"live_period\"")
			}
		case "heading":
			if err := func() error {
				s.Heading.Reset()
				if err := s.Heading.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heading\"")
			}
		case "proximity_alert_radius":
			if err := func() error {
				s.ProximityAlertRadius.Reset()
				if err := s.ProximityAlertRadius.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proximity_alert_radius\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Location")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLocation) {
					name = jsonFieldsNameOfLocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Location) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Location) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginUrl) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginUrl) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		if s.ForwardText.Set {
			e.FieldStart("forward_text")
			s.ForwardText.Encode(e)
		}
	}
	{
		if s.BotUsername.Set {
			e.FieldStart("bot_username")
			s.BotUsername.Encode(e)
		}
	}
	{
		if s.RequestWriteAccess.Set {
			e.FieldStart("request_write_access")
			s.RequestWriteAccess.Encode(e)
		}
	}
}

var jsonFieldsNameOfLoginUrl = [4]string{
	0: "url",
	1: "forward_text",
	2: "bot_username",
	3: "request_write_access",
}

// Decode decodes LoginUrl from json.
func (s *LoginUrl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginUrl to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "forward_text":
			if err := func() error {
				s.ForwardText.Reset()
				if err := s.ForwardText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forward_text\"")
			}
		case "bot_username":
			if err := func() error {
				s.BotUsername.Reset()
				if err := s.BotUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bot_username\"")
			}
		case "request_write_access":
			if err := func() error {
				s.RequestWriteAccess.Reset()
				if err := s.RequestWriteAccess.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_write_access\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginUrl")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginUrl) {
					name = jsonFieldsNameOfLoginUrl[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginUrl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginUrl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MaskPosition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MaskPosition) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("point")
		e.Str(s.Point)
	}
	{
		e.FieldStart("x_shift")
		e.Float64(s.XShift)
	}
	{
		e.FieldStart("y_shift")
		e.Float64(s.YShift)
	}
	{
		e.FieldStart("scale")
		e.Float64(s.Scale)
	}
}

var jsonFieldsNameOfMaskPosition = [4]string{
	0: "point",
	1: "x_shift",
	2: "y_shift",
	3: "scale",
}

// Decode decodes MaskPosition from json.
func (s *MaskPosition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MaskPosition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "point":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Point = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"point\"")
			}
		case "x_shift":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.XShift = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x_shift\"")
			}
		case "y_shift":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.YShift = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y_shift\"")
			}
		case "scale":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Scale = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scale\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MaskPosition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMaskPosition) {
					name = jsonFieldsNameOfMaskPosition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MaskPosition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MaskPosition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MaybeInaccessibleMessage as json.
func (s MaybeInaccessibleMessage) Encode(e *jx.Encoder) {
	switch s.Type {
	case MessageMaybeInaccessibleMessage:
		s.Message.Encode(e)
	case InaccessibleMessageMaybeInaccessibleMessage:
		s.InaccessibleMessage.Encode(e)
	}
}

func (s MaybeInaccessibleMessage) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case MessageMaybeInaccessibleMessage:
		s.Message.encodeFields(e)
	case InaccessibleMessageMaybeInaccessibleMessage:
		s.InaccessibleMessage.encodeFields(e)
	}
}

// Decode decodes MaybeInaccessibleMessage from json.
func (s *MaybeInaccessibleMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MaybeInaccessibleMessage to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "message_thread_id":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "from":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "sender_chat":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "sender_boost_count":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "sender_business_bot":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "business_connection_id":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "forward_origin":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "is_topic_message":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "is_automatic_forward":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "reply_to_message":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "external_reply":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "quote":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "reply_to_story":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "via_bot":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "edit_date":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "has_protected_content":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "is_from_offline":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "media_group_id":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "author_signature":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "text":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "entities":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "link_preview_options":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "effect_id":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "animation":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "audio":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "document":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "paid_media":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "photo":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "sticker":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "story":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "video":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "video_note":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "voice":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "caption":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "caption_entities":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "show_caption_above_media":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "has_media_spoiler":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "contact":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "dice":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "game":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "poll":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "venue":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "location":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "new_chat_members":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "left_chat_member":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "new_chat_title":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "new_chat_photo":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "delete_chat_photo":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "group_chat_created":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "supergroup_chat_created":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "channel_chat_created":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "message_auto_delete_timer_changed":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "migrate_to_chat_id":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "migrate_from_chat_id":
				match := MessageMaybeInaccessibleMessage
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		s.Type = InaccessibleMessageMaybeInaccessibleMessage
	}
	switch s.Type {
	case MessageMaybeInaccessibleMessage:
		if err := s.Message.Decode(d); err != nil {
			return err
		}
	case InaccessibleMessageMaybeInaccessibleMessage:
		if err := s.InaccessibleMessage.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MaybeInaccessibleMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MaybeInaccessibleMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MenuButton as json.
func (s MenuButton) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s MenuButton) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case MenuButtonCommandsMenuButton:
		e.FieldStart("type")
		e.Str("commands")
	case MenuButtonDefaultMenuButton:
		e.FieldStart("type")
		e.Str("default")
	case MenuButtonWebAppMenuButton:
		e.FieldStart("type")
		e.Str("web_app")
		{
			s := s.MenuButtonWebApp
			{
				e.FieldStart("text")
				e.Str(s.Text)
			}
			{
				e.FieldStart("web_app")
				s.WebApp.Encode(e)
			}
		}
	}
}

// Decode decodes MenuButton from json.
func (s *MenuButton) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MenuButton to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "commands":
					s.Type = MenuButtonCommandsMenuButton
					found = true
				case "default":
					s.Type = MenuButtonDefaultMenuButton
					found = true
				case "web_app":
					s.Type = MenuButtonWebAppMenuButton
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case MenuButtonCommandsMenuButton:
		if err := s.MenuButtonCommands.Decode(d); err != nil {
			return err
		}
	case MenuButtonWebAppMenuButton:
		if err := s.MenuButtonWebApp.Decode(d); err != nil {
			return err
		}
	case MenuButtonDefaultMenuButton:
		if err := s.MenuButtonDefault.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MenuButton) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MenuButton) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MenuButtonCommands) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MenuButtonCommands) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfMenuButtonCommands = [1]string{
	0: "type",
}

// Decode decodes MenuButtonCommands from json.
func (s *MenuButtonCommands) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MenuButtonCommands to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MenuButtonCommands")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMenuButtonCommands) {
					name = jsonFieldsNameOfMenuButtonCommands[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MenuButtonCommands) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MenuButtonCommands) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MenuButtonDefault) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MenuButtonDefault) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfMenuButtonDefault = [1]string{
	0: "type",
}

// Decode decodes MenuButtonDefault from json.
func (s *MenuButtonDefault) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MenuButtonDefault to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MenuButtonDefault")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMenuButtonDefault) {
					name = jsonFieldsNameOfMenuButtonDefault[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MenuButtonDefault) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MenuButtonDefault) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MenuButtonWebApp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MenuButtonWebApp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		e.FieldStart("web_app")
		s.WebApp.Encode(e)
	}
}

var jsonFieldsNameOfMenuButtonWebApp = [3]string{
	0: "type",
	1: "text",
	2: "web_app",
}

// Decode decodes MenuButtonWebApp from json.
func (s *MenuButtonWebApp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MenuButtonWebApp to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "web_app":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.WebApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"web_app\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MenuButtonWebApp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMenuButtonWebApp) {
					name = jsonFieldsNameOfMenuButtonWebApp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MenuButtonWebApp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MenuButtonWebApp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Message) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Message) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e)
		}
	}
	{
		if s.SenderChat.Set {
			e.FieldStart("sender_chat")
			s.SenderChat.Encode(e)
		}
	}
	{
		if s.SenderBoostCount.Set {
			e.FieldStart("sender_boost_count")
			s.SenderBoostCount.Encode(e)
		}
	}
	{
		if s.SenderBusinessBot.Set {
			e.FieldStart("sender_business_bot")
			s.SenderBusinessBot.Encode(e)
		}
	}
	{
		e.FieldStart("date")
		e.Int(s.Date)
	}
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat")
		s.Chat.Encode(e)
	}
	{
		if s.ForwardOrigin.Set {
			e.FieldStart("forward_origin")
			s.ForwardOrigin.Encode(e)
		}
	}
	{
		if s.IsTopicMessage.Set {
			e.FieldStart("is_topic_message")
			s.IsTopicMessage.Encode(e)
		}
	}
	{
		if s.IsAutomaticForward.Set {
			e.FieldStart("is_automatic_forward")
			s.IsAutomaticForward.Encode(e)
		}
	}
	{
		if s.ReplyToMessage != nil {
			e.FieldStart("reply_to_message")
			s.ReplyToMessage.Encode(e)
		}
	}
	{
		if s.ExternalReply.Set {
			e.FieldStart("external_reply")
			s.ExternalReply.Encode(e)
		}
	}
	{
		if s.Quote.Set {
			e.FieldStart("quote")
			s.Quote.Encode(e)
		}
	}
	{
		if s.ReplyToStory.Set {
			e.FieldStart("reply_to_story")
			s.ReplyToStory.Encode(e)
		}
	}
	{
		if s.ViaBot.Set {
			e.FieldStart("via_bot")
			s.ViaBot.Encode(e)
		}
	}
	{
		if s.EditDate.Set {
			e.FieldStart("edit_date")
			s.EditDate.Encode(e)
		}
	}
	{
		if s.HasProtectedContent.Set {
			e.FieldStart("has_protected_content")
			s.HasProtectedContent.Encode(e)
		}
	}
	{
		if s.IsFromOffline.Set {
			e.FieldStart("is_from_offline")
			s.IsFromOffline.Encode(e)
		}
	}
	{
		if s.MediaGroupID.Set {
			e.FieldStart("media_group_id")
			s.MediaGroupID.Encode(e)
		}
	}
	{
		if s.AuthorSignature.Set {
			e.FieldStart("author_signature")
			s.AuthorSignature.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.Entities != nil {
			e.FieldStart("entities")
			e.ArrStart()
			for _, elem := range s.Entities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LinkPreviewOptions.Set {
			e.FieldStart("link_preview_options")
			s.LinkPreviewOptions.Encode(e)
		}
	}
	{
		if s.EffectID.Set {
			e.FieldStart("effect_id")
			s.EffectID.Encode(e)
		}
	}
	{
		if s.Animation.Set {
			e.FieldStart("animation")
			s.Animation.Encode(e)
		}
	}
	{
		if s.Audio.Set {
			e.FieldStart("audio")
			s.Audio.Encode(e)
		}
	}
	{
		if s.Document.Set {
			e.FieldStart("document")
			s.Document.Encode(e)
		}
	}
	{
		if s.PaidMedia.Set {
			e.FieldStart("paid_media")
			s.PaidMedia.Encode(e)
		}
	}
	{
		if s.Photo != nil {
			e.FieldStart("photo")
			e.ArrStart()
			for _, elem := range s.Photo {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Sticker.Set {
			e.FieldStart("sticker")
			s.Sticker.Encode(e)
		}
	}
	{
		if s.Story.Set {
			e.FieldStart("story")
			s.Story.Encode(e)
		}
	}
	{
		if s.Video.Set {
			e.FieldStart("video")
			s.Video.Encode(e)
		}
	}
	{
		if s.VideoNote.Set {
			e.FieldStart("video_note")
			s.VideoNote.Encode(e)
		}
	}
	{
		if s.Voice.Set {
			e.FieldStart("voice")
			s.Voice.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.HasMediaSpoiler.Set {
			e.FieldStart("has_media_spoiler")
			s.HasMediaSpoiler.Encode(e)
		}
	}
	{
		if s.Contact.Set {
			e.FieldStart("contact")
			s.Contact.Encode(e)
		}
	}
	{
		if s.Dice.Set {
			e.FieldStart("dice")
			s.Dice.Encode(e)
		}
	}
	{
		if s.Game.Set {
			e.FieldStart("game")
			s.Game.Encode(e)
		}
	}
	{
		if s.Poll.Set {
			e.FieldStart("poll")
			s.Poll.Encode(e)
		}
	}
	{
		if s.Venue.Set {
			e.FieldStart("venue")
			s.Venue.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.NewChatMembers != nil {
			e.FieldStart("new_chat_members")
			e.ArrStart()
			for _, elem := range s.NewChatMembers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LeftChatMember.Set {
			e.FieldStart("left_chat_member")
			s.LeftChatMember.Encode(e)
		}
	}
	{
		if s.NewChatTitle.Set {
			e.FieldStart("new_chat_title")
			s.NewChatTitle.Encode(e)
		}
	}
	{
		if s.NewChatPhoto != nil {
			e.FieldStart("new_chat_photo")
			e.ArrStart()
			for _, elem := range s.NewChatPhoto {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DeleteChatPhoto.Set {
			e.FieldStart("delete_chat_photo")
			s.DeleteChatPhoto.Encode(e)
		}
	}
	{
		if s.GroupChatCreated.Set {
			e.FieldStart("group_chat_created")
			s.GroupChatCreated.Encode(e)
		}
	}
	{
		if s.SupergroupChatCreated.Set {
			e.FieldStart("supergroup_chat_created")
			s.SupergroupChatCreated.Encode(e)
		}
	}
	{
		if s.ChannelChatCreated.Set {
			e.FieldStart("channel_chat_created")
			s.ChannelChatCreated.Encode(e)
		}
	}
	{
		if s.MessageAutoDeleteTimerChanged.Set {
			e.FieldStart("message_auto_delete_timer_changed")
			s.MessageAutoDeleteTimerChanged.Encode(e)
		}
	}
	{
		if s.MigrateToChatID.Set {
			e.FieldStart("migrate_to_chat_id")
			s.MigrateToChatID.Encode(e)
		}
	}
	{
		if s.MigrateFromChatID.Set {
			e.FieldStart("migrate_from_chat_id")
			s.MigrateFromChatID.Encode(e)
		}
	}
	{
		if s.PinnedMessage != nil {
			e.FieldStart("pinned_message")
			s.PinnedMessage.Encode(e)
		}
	}
	{
		if s.Invoice.Set {
			e.FieldStart("invoice")
			s.Invoice.Encode(e)
		}
	}
	{
		if s.SuccessfulPayment.Set {
			e.FieldStart("successful_payment")
			s.SuccessfulPayment.Encode(e)
		}
	}
	{
		if s.RefundedPayment.Set {
			e.FieldStart("refunded_payment")
			s.RefundedPayment.Encode(e)
		}
	}
	{
		if s.UsersShared.Set {
			e.FieldStart("users_shared")
			s.UsersShared.Encode(e)
		}
	}
	{
		if s.ChatShared.Set {
			e.FieldStart("chat_shared")
			s.ChatShared.Encode(e)
		}
	}
	{
		if s.ConnectedWebsite.Set {
			e.FieldStart("connected_website")
			s.ConnectedWebsite.Encode(e)
		}
	}
	{
		if s.WriteAccessAllowed.Set {
			e.FieldStart("write_access_allowed")
			s.WriteAccessAllowed.Encode(e)
		}
	}
	{
		if s.PassportData.Set {
			e.FieldStart("passport_data")
			s.PassportData.Encode(e)
		}
	}
	{
		if s.ProximityAlertTriggered.Set {
			e.FieldStart("proximity_alert_triggered")
			s.ProximityAlertTriggered.Encode(e)
		}
	}
	{
		if s.BoostAdded.Set {
			e.FieldStart("boost_added")
			s.BoostAdded.Encode(e)
		}
	}
	{
		if s.ChatBackgroundSet.Set {
			e.FieldStart("chat_background_set")
			s.ChatBackgroundSet.Encode(e)
		}
	}
	{
		if s.ForumTopicCreated.Set {
			e.FieldStart("forum_topic_created")
			s.ForumTopicCreated.Encode(e)
		}
	}
	{
		if s.ForumTopicEdited.Set {
			e.FieldStart("forum_topic_edited")
			s.ForumTopicEdited.Encode(e)
		}
	}
	{
		if s.ForumTopicClosed != nil {
			e.FieldStart("forum_topic_closed")
			s.ForumTopicClosed.Encode(e)
		}
	}
	{
		if s.ForumTopicReopened != nil {
			e.FieldStart("forum_topic_reopened")
			s.ForumTopicReopened.Encode(e)
		}
	}
	{
		if s.GeneralForumTopicHidden != nil {
			e.FieldStart("general_forum_topic_hidden")
			s.GeneralForumTopicHidden.Encode(e)
		}
	}
	{
		if s.GeneralForumTopicUnhidden != nil {
			e.FieldStart("general_forum_topic_unhidden")
			s.GeneralForumTopicUnhidden.Encode(e)
		}
	}
	{
		if s.GiveawayCreated.Set {
			e.FieldStart("giveaway_created")
			s.GiveawayCreated.Encode(e)
		}
	}
	{
		if s.Giveaway.Set {
			e.FieldStart("giveaway")
			s.Giveaway.Encode(e)
		}
	}
	{
		if s.GiveawayWinners.Set {
			e.FieldStart("giveaway_winners")
			s.GiveawayWinners.Encode(e)
		}
	}
	{
		if s.GiveawayCompleted.Set {
			e.FieldStart("giveaway_completed")
			s.GiveawayCompleted.Encode(e)
		}
	}
	{
		if s.VideoChatScheduled.Set {
			e.FieldStart("video_chat_scheduled")
			s.VideoChatScheduled.Encode(e)
		}
	}
	{
		if s.VideoChatStarted != nil {
			e.FieldStart("video_chat_started")
			s.VideoChatStarted.Encode(e)
		}
	}
	{
		if s.VideoChatEnded.Set {
			e.FieldStart("video_chat_ended")
			s.VideoChatEnded.Encode(e)
		}
	}
	{
		if s.VideoChatParticipantsInvited.Set {
			e.FieldStart("video_chat_participants_invited")
			s.VideoChatParticipantsInvited.Encode(e)
		}
	}
	{
		if s.WebAppData.Set {
			e.FieldStart("web_app_data")
			s.WebAppData.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.NewChatMember.Set {
			e.FieldStart("new_chat_member")
			s.NewChatMember.Encode(e)
		}
	}
	{
		if s.NewChatParticipant.Set {
			e.FieldStart("new_chat_participant")
			s.NewChatParticipant.Encode(e)
		}
	}
	{
		if s.LeftChatParticipant.Set {
			e.FieldStart("left_chat_participant")
			s.LeftChatParticipant.Encode(e)
		}
	}
}

var jsonFieldsNameOfMessage = [88]string{
	0:  "message_id",
	1:  "message_thread_id",
	2:  "from",
	3:  "sender_chat",
	4:  "sender_boost_count",
	5:  "sender_business_bot",
	6:  "date",
	7:  "business_connection_id",
	8:  "chat",
	9:  "forward_origin",
	10: "is_topic_message",
	11: "is_automatic_forward",
	12: "reply_to_message",
	13: "external_reply",
	14: "quote",
	15: "reply_to_story",
	16: "via_bot",
	17: "edit_date",
	18: "has_protected_content",
	19: "is_from_offline",
	20: "media_group_id",
	21: "author_signature",
	22: "text",
	23: "entities",
	24: "link_preview_options",
	25: "effect_id",
	26: "animation",
	27: "audio",
	28: "document",
	29: "paid_media",
	30: "photo",
	31: "sticker",
	32: "story",
	33: "video",
	34: "video_note",
	35: "voice",
	36: "caption",
	37: "caption_entities",
	38: "show_caption_above_media",
	39: "has_media_spoiler",
	40: "contact",
	41: "dice",
	42: "game",
	43: "poll",
	44: "venue",
	45: "location",
	46: "new_chat_members",
	47: "left_chat_member",
	48: "new_chat_title",
	49: "new_chat_photo",
	50: "delete_chat_photo",
	51: "group_chat_created",
	52: "supergroup_chat_created",
	53: "channel_chat_created",
	54: "message_auto_delete_timer_changed",
	55: "migrate_to_chat_id",
	56: "migrate_from_chat_id",
	57: "pinned_message",
	58: "invoice",
	59: "successful_payment",
	60: "refunded_payment",
	61: "users_shared",
	62: "chat_shared",
	63: "connected_website",
	64: "write_access_allowed",
	65: "passport_data",
	66: "proximity_alert_triggered",
	67: "boost_added",
	68: "chat_background_set",
	69: "forum_topic_created",
	70: "forum_topic_edited",
	71: "forum_topic_closed",
	72: "forum_topic_reopened",
	73: "general_forum_topic_hidden",
	74: "general_forum_topic_unhidden",
	75: "giveaway_created",
	76: "giveaway",
	77: "giveaway_winners",
	78: "giveaway_completed",
	79: "video_chat_scheduled",
	80: "video_chat_started",
	81: "video_chat_ended",
	82: "video_chat_participants_invited",
	83: "web_app_data",
	84: "reply_markup",
	85: "new_chat_member",
	86: "new_chat_participant",
	87: "left_chat_participant",
}

// Decode decodes Message from json.
func (s *Message) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Message to nil")
	}
	var requiredBitSet [11]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "sender_chat":
			if err := func() error {
				s.SenderChat.Reset()
				if err := s.SenderChat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sender_chat\"")
			}
		case "sender_boost_count":
			if err := func() error {
				s.SenderBoostCount.Reset()
				if err := s.SenderBoostCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sender_boost_count\"")
			}
		case "sender_business_bot":
			if err := func() error {
				s.SenderBusinessBot.Reset()
				if err := s.SenderBusinessBot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sender_business_bot\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Date = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Chat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat\"")
			}
		case "forward_origin":
			if err := func() error {
				s.ForwardOrigin.Reset()
				if err := s.ForwardOrigin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forward_origin\"")
			}
		case "is_topic_message":
			if err := func() error {
				s.IsTopicMessage.Reset()
				if err := s.IsTopicMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_topic_message\"")
			}
		case "is_automatic_forward":
			if err := func() error {
				s.IsAutomaticForward.Reset()
				if err := s.IsAutomaticForward.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_automatic_forward\"")
			}
		case "reply_to_message":
			if err := func() error {
				s.ReplyToMessage = nil
				var elem Message
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ReplyToMessage = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_message\"")
			}
		case "external_reply":
			if err := func() error {
				s.ExternalReply.Reset()
				if err := s.ExternalReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_reply\"")
			}
		case "quote":
			if err := func() error {
				s.Quote.Reset()
				if err := s.Quote.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quote\"")
			}
		case "reply_to_story":
			if err := func() error {
				s.ReplyToStory.Reset()
				if err := s.ReplyToStory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to_story\"")
			}
		case "via_bot":
			if err := func() error {
				s.ViaBot.Reset()
				if err := s.ViaBot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"via_bot\"")
			}
		case "edit_date":
			if err := func() error {
				s.EditDate.Reset()
				if err := s.EditDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edit_date\"")
			}
		case "has_protected_content":
			if err := func() error {
				s.HasProtectedContent.Reset()
				if err := s.HasProtectedContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_protected_content\"")
			}
		case "is_from_offline":
			if err := func() error {
				s.IsFromOffline.Reset()
				if err := s.IsFromOffline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_from_offline\"")
			}
		case "media_group_id":
			if err := func() error {
				s.MediaGroupID.Reset()
				if err := s.MediaGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_group_id\"")
			}
		case "author_signature":
			if err := func() error {
				s.AuthorSignature.Reset()
				if err := s.AuthorSignature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_signature\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "entities":
			if err := func() error {
				s.Entities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entities = append(s.Entities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entities\"")
			}
		case "link_preview_options":
			if err := func() error {
				s.LinkPreviewOptions.Reset()
				if err := s.LinkPreviewOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_preview_options\"")
			}
		case "effect_id":
			if err := func() error {
				s.EffectID.Reset()
				if err := s.EffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect_id\"")
			}
		case "animation":
			if err := func() error {
				s.Animation.Reset()
				if err := s.Animation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"animation\"")
			}
		case "audio":
			if err := func() error {
				s.Audio.Reset()
				if err := s.Audio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio\"")
			}
		case "document":
			if err := func() error {
				s.Document.Reset()
				if err := s.Document.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document\"")
			}
		case "paid_media":
			if err := func() error {
				s.PaidMedia.Reset()
				if err := s.PaidMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paid_media\"")
			}
		case "photo":
			if err := func() error {
				s.Photo = make([]PhotoSize, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PhotoSize
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Photo = append(s.Photo, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo\"")
			}
		case "sticker":
			if err := func() error {
				s.Sticker.Reset()
				if err := s.Sticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		case "story":
			if err := func() error {
				s.Story.Reset()
				if err := s.Story.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"story\"")
			}
		case "video":
			if err := func() error {
				s.Video.Reset()
				if err := s.Video.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video\"")
			}
		case "video_note":
			if err := func() error {
				s.VideoNote.Reset()
				if err := s.VideoNote.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_note\"")
			}
		case "voice":
			if err := func() error {
				s.Voice.Reset()
				if err := s.Voice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "has_media_spoiler":
			if err := func() error {
				s.HasMediaSpoiler.Reset()
				if err := s.HasMediaSpoiler.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_media_spoiler\"")
			}
		case "contact":
			if err := func() error {
				s.Contact.Reset()
				if err := s.Contact.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contact\"")
			}
		case "dice":
			if err := func() error {
				s.Dice.Reset()
				if err := s.Dice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dice\"")
			}
		case "game":
			if err := func() error {
				s.Game.Reset()
				if err := s.Game.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game\"")
			}
		case "poll":
			if err := func() error {
				s.Poll.Reset()
				if err := s.Poll.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"poll\"")
			}
		case "venue":
			if err := func() error {
				s.Venue.Reset()
				if err := s.Venue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"venue\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "new_chat_members":
			if err := func() error {
				s.NewChatMembers = make([]User, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem User
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NewChatMembers = append(s.NewChatMembers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_chat_members\"")
			}
		case "left_chat_member":
			if err := func() error {
				s.LeftChatMember.Reset()
				if err := s.LeftChatMember.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"left_chat_member\"")
			}
		case "new_chat_title":
			if err := func() error {
				s.NewChatTitle.Reset()
				if err := s.NewChatTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_chat_title\"")
			}
		case "new_chat_photo":
			if err := func() error {
				s.NewChatPhoto = make([]PhotoSize, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PhotoSize
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NewChatPhoto = append(s.NewChatPhoto, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_chat_photo\"")
			}
		case "delete_chat_photo":
			if err := func() error {
				s.DeleteChatPhoto.Reset()
				if err := s.DeleteChatPhoto.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_chat_photo\"")
			}
		case "group_chat_created":
			if err := func() error {
				s.GroupChatCreated.Reset()
				if err := s.GroupChatCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_chat_created\"")
			}
		case "supergroup_chat_created":
			if err := func() error {
				s.SupergroupChatCreated.Reset()
				if err := s.SupergroupChatCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supergroup_chat_created\"")
			}
		case "channel_chat_created":
			if err := func() error {
				s.ChannelChatCreated.Reset()
				if err := s.ChannelChatCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel_chat_created\"")
			}
		case "message_auto_delete_timer_changed":
			if err := func() error {
				s.MessageAutoDeleteTimerChanged.Reset()
				if err := s.MessageAutoDeleteTimerChanged.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_auto_delete_timer_changed\"")
			}
		case "migrate_to_chat_id":
			if err := func() error {
				s.MigrateToChatID.Reset()
				if err := s.MigrateToChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"migrate_to_chat_id\"")
			}
		case "migrate_from_chat_id":
			if err := func() error {
				s.MigrateFromChatID.Reset()
				if err := s.MigrateFromChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"migrate_from_chat_id\"")
			}
		case "pinned_message":
			if err := func() error {
				s.PinnedMessage = nil
				var elem MaybeInaccessibleMessage
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PinnedMessage = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pinned_message\"")
			}
		case "invoice":
			if err := func() error {
				s.Invoice.Reset()
				if err := s.Invoice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoice\"")
			}
		case "successful_payment":
			if err := func() error {
				s.SuccessfulPayment.Reset()
				if err := s.SuccessfulPayment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successful_payment\"")
			}
		case "refunded_payment":
			if err := func() error {
				s.RefundedPayment.Reset()
				if err := s.RefundedPayment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refunded_payment\"")
			}
		case "users_shared":
			if err := func() error {
				s.UsersShared.Reset()
				if err := s.UsersShared.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users_shared\"")
			}
		case "chat_shared":
			if err := func() error {
				s.ChatShared.Reset()
				if err := s.ChatShared.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_shared\"")
			}
		case "connected_website":
			if err := func() error {
				s.ConnectedWebsite.Reset()
				if err := s.ConnectedWebsite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connected_website\"")
			}
		case "write_access_allowed":
			if err := func() error {
				s.WriteAccessAllowed.Reset()
				if err := s.WriteAccessAllowed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"write_access_allowed\"")
			}
		case "passport_data":
			if err := func() error {
				s.PassportData.Reset()
				if err := s.PassportData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passport_data\"")
			}
		case "proximity_alert_triggered":
			if err := func() error {
				s.ProximityAlertTriggered.Reset()
				if err := s.ProximityAlertTriggered.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proximity_alert_triggered\"")
			}
		case "boost_added":
			if err := func() error {
				s.BoostAdded.Reset()
				if err := s.BoostAdded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boost_added\"")
			}
		case "chat_background_set":
			if err := func() error {
				s.ChatBackgroundSet.Reset()
				if err := s.ChatBackgroundSet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_background_set\"")
			}
		case "forum_topic_created":
			if err := func() error {
				s.ForumTopicCreated.Reset()
				if err := s.ForumTopicCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forum_topic_created\"")
			}
		case "forum_topic_edited":
			if err := func() error {
				s.ForumTopicEdited.Reset()
				if err := s.ForumTopicEdited.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forum_topic_edited\"")
			}
		case "forum_topic_closed":
			if err := func() error {
				s.ForumTopicClosed = nil
				var elem ForumTopicClosed
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ForumTopicClosed = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forum_topic_closed\"")
			}
		case "forum_topic_reopened":
			if err := func() error {
				s.ForumTopicReopened = nil
				var elem ForumTopicReopened
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ForumTopicReopened = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forum_topic_reopened\"")
			}
		case "general_forum_topic_hidden":
			if err := func() error {
				s.GeneralForumTopicHidden = nil
				var elem GeneralForumTopicHidden
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.GeneralForumTopicHidden = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"general_forum_topic_hidden\"")
			}
		case "general_forum_topic_unhidden":
			if err := func() error {
				s.GeneralForumTopicUnhidden = nil
				var elem GeneralForumTopicUnhidden
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.GeneralForumTopicUnhidden = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"general_forum_topic_unhidden\"")
			}
		case "giveaway_created":
			if err := func() error {
				s.GiveawayCreated.Reset()
				if err := s.GiveawayCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"giveaway_created\"")
			}
		case "giveaway":
			if err := func() error {
				s.Giveaway.Reset()
				if err := s.Giveaway.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"giveaway\"")
			}
		case "giveaway_winners":
			if err := func() error {
				s.GiveawayWinners.Reset()
				if err := s.GiveawayWinners.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"giveaway_winners\"")
			}
		case "giveaway_completed":
			if err := func() error {
				s.GiveawayCompleted.Reset()
				if err := s.GiveawayCompleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"giveaway_completed\"")
			}
		case "video_chat_scheduled":
			if err := func() error {
				s.VideoChatScheduled.Reset()
				if err := s.VideoChatScheduled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_chat_scheduled\"")
			}
		case "video_chat_started":
			if err := func() error {
				s.VideoChatStarted = nil
				var elem VideoChatStarted
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.VideoChatStarted = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_chat_started\"")
			}
		case "video_chat_ended":
			if err := func() error {
				s.VideoChatEnded.Reset()
				if err := s.VideoChatEnded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_chat_ended\"")
			}
		case "video_chat_participants_invited":
			if err := func() error {
				s.VideoChatParticipantsInvited.Reset()
				if err := s.VideoChatParticipantsInvited.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_chat_participants_invited\"")
			}
		case "web_app_data":
			if err := func() error {
				s.WebAppData.Reset()
				if err := s.WebAppData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"web_app_data\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		case "new_chat_member":
			if err := func() error {
				s.NewChatMember.Reset()
				if err := s.NewChatMember.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_chat_member\"")
			}
		case "new_chat_participant":
			if err := func() error {
				s.NewChatParticipant.Reset()
				if err := s.NewChatParticipant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_chat_participant\"")
			}
		case "left_chat_participant":
			if err := func() error {
				s.LeftChatParticipant.Reset()
				if err := s.LeftChatParticipant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"left_chat_participant\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Message")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [11]uint8{
		0b01000001,
		0b00000001,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessage) {
					name = jsonFieldsNameOfMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Message) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Message) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageAutoDeleteTimerChanged) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageAutoDeleteTimerChanged) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message_auto_delete_time")
		e.Int(s.MessageAutoDeleteTime)
	}
}

var jsonFieldsNameOfMessageAutoDeleteTimerChanged = [1]string{
	0: "message_auto_delete_time",
}

// Decode decodes MessageAutoDeleteTimerChanged from json.
func (s *MessageAutoDeleteTimerChanged) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageAutoDeleteTimerChanged to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message_auto_delete_time":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MessageAutoDeleteTime = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_auto_delete_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageAutoDeleteTimerChanged")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageAutoDeleteTimerChanged) {
					name = jsonFieldsNameOfMessageAutoDeleteTimerChanged[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageAutoDeleteTimerChanged) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageAutoDeleteTimerChanged) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageEntity) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("offset")
		e.Int(s.Offset)
	}
	{
		e.FieldStart("length")
		e.Int(s.Length)
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.CustomEmojiID.Set {
			e.FieldStart("custom_emoji_id")
			s.CustomEmojiID.Encode(e)
		}
	}
}

var jsonFieldsNameOfMessageEntity = [7]string{
	0: "type",
	1: "offset",
	2: "length",
	3: "url",
	4: "user",
	5: "language",
	6: "custom_emoji_id",
}

// Decode decodes MessageEntity from json.
func (s *MessageEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageEntity to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "offset":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Offset = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "length":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Length = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"length\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "custom_emoji_id":
			if err := func() error {
				s.CustomEmojiID.Reset()
				if err := s.CustomEmojiID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_emoji_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageEntity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageEntity) {
					name = jsonFieldsNameOfMessageEntity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageEntityType as json.
func (s MessageEntityType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MessageEntityType from json.
func (s *MessageEntityType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageEntityType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MessageEntityType(v) {
	case MessageEntityTypeMention:
		*s = MessageEntityTypeMention
	case MessageEntityTypeHashtag:
		*s = MessageEntityTypeHashtag
	case MessageEntityTypeCashtag:
		*s = MessageEntityTypeCashtag
	case MessageEntityTypeBotCommand:
		*s = MessageEntityTypeBotCommand
	case MessageEntityTypeURL:
		*s = MessageEntityTypeURL
	case MessageEntityTypeEmail:
		*s = MessageEntityTypeEmail
	case MessageEntityTypePhoneNumber:
		*s = MessageEntityTypePhoneNumber
	case MessageEntityTypeBold:
		*s = MessageEntityTypeBold
	case MessageEntityTypeItalic:
		*s = MessageEntityTypeItalic
	case MessageEntityTypeUnderline:
		*s = MessageEntityTypeUnderline
	case MessageEntityTypeStrikethrough:
		*s = MessageEntityTypeStrikethrough
	case MessageEntityTypeSpoiler:
		*s = MessageEntityTypeSpoiler
	case MessageEntityTypeBlockquote:
		*s = MessageEntityTypeBlockquote
	case MessageEntityTypeExpandableBlockquote:
		*s = MessageEntityTypeExpandableBlockquote
	case MessageEntityTypeCode:
		*s = MessageEntityTypeCode
	case MessageEntityTypePre:
		*s = MessageEntityTypePre
	case MessageEntityTypeTextLink:
		*s = MessageEntityTypeTextLink
	case MessageEntityTypeTextMention:
		*s = MessageEntityTypeTextMention
	case MessageEntityTypeCustomEmoji:
		*s = MessageEntityTypeCustomEmoji
	default:
		*s = MessageEntityType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MessageEntityType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageEntityType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageId) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageId) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
}

var jsonFieldsNameOfMessageId = [1]string{
	0: "message_id",
}

// Decode decodes MessageId from json.
func (s *MessageId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageId to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageId")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageId) {
					name = jsonFieldsNameOfMessageId[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageOrigin as json.
func (s MessageOrigin) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s MessageOrigin) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case MessageOriginChannelMessageOrigin:
		e.FieldStart("type")
		e.Str("MessageOriginChannel")
		{
			s := s.MessageOriginChannel
			{
				e.FieldStart("date")
				e.Int(s.Date)
			}
			{
				e.FieldStart("chat")
				s.Chat.Encode(e)
			}
			{
				e.FieldStart("message_id")
				e.Int(s.MessageID)
			}
			{
				if s.AuthorSignature.Set {
					e.FieldStart("author_signature")
					s.AuthorSignature.Encode(e)
				}
			}
		}
	case MessageOriginChatMessageOrigin:
		e.FieldStart("type")
		e.Str("MessageOriginChat")
		{
			s := s.MessageOriginChat
			{
				e.FieldStart("date")
				e.Int(s.Date)
			}
			{
				e.FieldStart("sender_chat")
				s.SenderChat.Encode(e)
			}
			{
				if s.AuthorSignature.Set {
					e.FieldStart("author_signature")
					s.AuthorSignature.Encode(e)
				}
			}
		}
	case MessageOriginHiddenUserMessageOrigin:
		e.FieldStart("type")
		e.Str("MessageOriginHiddenUser")
		{
			s := s.MessageOriginHiddenUser
			{
				e.FieldStart("date")
				e.Int(s.Date)
			}
			{
				e.FieldStart("sender_user_name")
				e.Str(s.SenderUserName)
			}
		}
	case MessageOriginUserMessageOrigin:
		e.FieldStart("type")
		e.Str("MessageOriginUser")
		{
			s := s.MessageOriginUser
			{
				e.FieldStart("date")
				e.Int(s.Date)
			}
			{
				e.FieldStart("sender_user")
				s.SenderUser.Encode(e)
			}
		}
	}
}

// Decode decodes MessageOrigin from json.
func (s *MessageOrigin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageOrigin to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "MessageOriginChannel":
					s.Type = MessageOriginChannelMessageOrigin
					found = true
				case "MessageOriginChat":
					s.Type = MessageOriginChatMessageOrigin
					found = true
				case "MessageOriginHiddenUser":
					s.Type = MessageOriginHiddenUserMessageOrigin
					found = true
				case "MessageOriginUser":
					s.Type = MessageOriginUserMessageOrigin
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case MessageOriginUserMessageOrigin:
		if err := s.MessageOriginUser.Decode(d); err != nil {
			return err
		}
	case MessageOriginHiddenUserMessageOrigin:
		if err := s.MessageOriginHiddenUser.Decode(d); err != nil {
			return err
		}
	case MessageOriginChatMessageOrigin:
		if err := s.MessageOriginChat.Decode(d); err != nil {
			return err
		}
	case MessageOriginChannelMessageOrigin:
		if err := s.MessageOriginChannel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MessageOrigin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageOrigin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageOriginChannel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageOriginChannel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("date")
		e.Int(s.Date)
	}
	{
		e.FieldStart("chat")
		s.Chat.Encode(e)
	}
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
	{
		if s.AuthorSignature.Set {
			e.FieldStart("author_signature")
			s.AuthorSignature.Encode(e)
		}
	}
}

var jsonFieldsNameOfMessageOriginChannel = [5]string{
	0: "type",
	1: "date",
	2: "chat",
	3: "message_id",
	4: "author_signature",
}

// Decode decodes MessageOriginChannel from json.
func (s *MessageOriginChannel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageOriginChannel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Date = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "chat":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Chat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat\"")
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "author_signature":
			if err := func() error {
				s.AuthorSignature.Reset()
				if err := s.AuthorSignature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_signature\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageOriginChannel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageOriginChannel) {
					name = jsonFieldsNameOfMessageOriginChannel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageOriginChannel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageOriginChannel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageOriginChat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageOriginChat) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("date")
		e.Int(s.Date)
	}
	{
		e.FieldStart("sender_chat")
		s.SenderChat.Encode(e)
	}
	{
		if s.AuthorSignature.Set {
			e.FieldStart("author_signature")
			s.AuthorSignature.Encode(e)
		}
	}
}

var jsonFieldsNameOfMessageOriginChat = [4]string{
	0: "type",
	1: "date",
	2: "sender_chat",
	3: "author_signature",
}

// Decode decodes MessageOriginChat from json.
func (s *MessageOriginChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageOriginChat to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Date = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "sender_chat":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.SenderChat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sender_chat\"")
			}
		case "author_signature":
			if err := func() error {
				s.AuthorSignature.Reset()
				if err := s.AuthorSignature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_signature\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageOriginChat")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageOriginChat) {
					name = jsonFieldsNameOfMessageOriginChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageOriginChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageOriginChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageOriginHiddenUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageOriginHiddenUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("date")
		e.Int(s.Date)
	}
	{
		e.FieldStart("sender_user_name")
		e.Str(s.SenderUserName)
	}
}

var jsonFieldsNameOfMessageOriginHiddenUser = [3]string{
	0: "type",
	1: "date",
	2: "sender_user_name",
}

// Decode decodes MessageOriginHiddenUser from json.
func (s *MessageOriginHiddenUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageOriginHiddenUser to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Date = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "sender_user_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SenderUserName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sender_user_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageOriginHiddenUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageOriginHiddenUser) {
					name = jsonFieldsNameOfMessageOriginHiddenUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageOriginHiddenUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageOriginHiddenUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageOriginUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageOriginUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("date")
		e.Int(s.Date)
	}
	{
		e.FieldStart("sender_user")
		s.SenderUser.Encode(e)
	}
}

var jsonFieldsNameOfMessageOriginUser = [3]string{
	0: "type",
	1: "date",
	2: "sender_user",
}

// Decode decodes MessageOriginUser from json.
func (s *MessageOriginUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageOriginUser to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Date = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "sender_user":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.SenderUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sender_user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageOriginUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageOriginUser) {
					name = jsonFieldsNameOfMessageOriginUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageOriginUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageOriginUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageReactionCountUpdated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageReactionCountUpdated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat")
		s.Chat.Encode(e)
	}
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
	{
		e.FieldStart("date")
		e.Int(s.Date)
	}
	{
		e.FieldStart("reactions")
		e.ArrStart()
		for _, elem := range s.Reactions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMessageReactionCountUpdated = [4]string{
	0: "chat",
	1: "message_id",
	2: "date",
	3: "reactions",
}

// Decode decodes MessageReactionCountUpdated from json.
func (s *MessageReactionCountUpdated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageReactionCountUpdated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Chat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat\"")
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Date = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "reactions":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Reactions = make([]ReactionCount, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReactionCount
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Reactions = append(s.Reactions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageReactionCountUpdated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageReactionCountUpdated) {
					name = jsonFieldsNameOfMessageReactionCountUpdated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageReactionCountUpdated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageReactionCountUpdated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageReactionUpdated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageReactionUpdated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat")
		s.Chat.Encode(e)
	}
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.ActorChat.Set {
			e.FieldStart("actor_chat")
			s.ActorChat.Encode(e)
		}
	}
	{
		e.FieldStart("date")
		e.Int(s.Date)
	}
	{
		e.FieldStart("old_reaction")
		e.ArrStart()
		for _, elem := range s.OldReaction {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("new_reaction")
		e.ArrStart()
		for _, elem := range s.NewReaction {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMessageReactionUpdated = [7]string{
	0: "chat",
	1: "message_id",
	2: "user",
	3: "actor_chat",
	4: "date",
	5: "old_reaction",
	6: "new_reaction",
}

// Decode decodes MessageReactionUpdated from json.
func (s *MessageReactionUpdated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageReactionUpdated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Chat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat\"")
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "actor_chat":
			if err := func() error {
				s.ActorChat.Reset()
				if err := s.ActorChat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actor_chat\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Date = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "old_reaction":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.OldReaction = make([]ReactionType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReactionType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.OldReaction = append(s.OldReaction, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_reaction\"")
			}
		case "new_reaction":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.NewReaction = make([]ReactionType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReactionType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NewReaction = append(s.NewReaction, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_reaction\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageReactionUpdated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageReactionUpdated) {
					name = jsonFieldsNameOfMessageReactionUpdated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageReactionUpdated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageReactionUpdated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Animation as json.
func (o OptAnimation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Animation from json.
func (o *OptAnimation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnimation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnimation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnimation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Audio as json.
func (o OptAudio) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Audio from json.
func (o *OptAudio) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAudio to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAudio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAudio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BotCommandScope as json.
func (o OptBotCommandScope) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BotCommandScope from json.
func (o *OptBotCommandScope) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBotCommandScope to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBotCommandScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBotCommandScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BusinessConnection as json.
func (o OptBusinessConnection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BusinessConnection from json.
func (o *OptBusinessConnection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBusinessConnection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBusinessConnection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBusinessConnection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BusinessMessagesDeleted as json.
func (o OptBusinessMessagesDeleted) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BusinessMessagesDeleted from json.
func (o *OptBusinessMessagesDeleted) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBusinessMessagesDeleted to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBusinessMessagesDeleted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBusinessMessagesDeleted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallbackQuery as json.
func (o OptCallbackQuery) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallbackQuery from json.
func (o *OptCallbackQuery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallbackQuery to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallbackQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallbackQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Chat as json.
func (o OptChat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Chat from json.
func (o *OptChat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChat to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatAdministratorRights as json.
func (o OptChatAdministratorRights) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatAdministratorRights from json.
func (o *OptChatAdministratorRights) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatAdministratorRights to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatAdministratorRights) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatAdministratorRights) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatBackground as json.
func (o OptChatBackground) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatBackground from json.
func (o *OptChatBackground) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatBackground to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatBackground) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatBackground) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatBoostAdded as json.
func (o OptChatBoostAdded) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatBoostAdded from json.
func (o *OptChatBoostAdded) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatBoostAdded to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatBoostAdded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatBoostAdded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatBoostRemoved as json.
func (o OptChatBoostRemoved) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatBoostRemoved from json.
func (o *OptChatBoostRemoved) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatBoostRemoved to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatBoostRemoved) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatBoostRemoved) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatBoostUpdated as json.
func (o OptChatBoostUpdated) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatBoostUpdated from json.
func (o *OptChatBoostUpdated) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatBoostUpdated to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatBoostUpdated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatBoostUpdated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatInviteLink as json.
func (o OptChatInviteLink) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatInviteLink from json.
func (o *OptChatInviteLink) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatInviteLink to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatInviteLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatInviteLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatJoinRequest as json.
func (o OptChatJoinRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatJoinRequest from json.
func (o *OptChatJoinRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatJoinRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatJoinRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatJoinRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatMember as json.
func (o OptChatMember) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatMember from json.
func (o *OptChatMember) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatMember to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatMemberUpdated as json.
func (o OptChatMemberUpdated) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatMemberUpdated from json.
func (o *OptChatMemberUpdated) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatMemberUpdated to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatMemberUpdated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatMemberUpdated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatShared as json.
func (o OptChatShared) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatShared from json.
func (o *OptChatShared) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatShared to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatShared) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatShared) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChosenInlineResult as json.
func (o OptChosenInlineResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChosenInlineResult from json.
func (o *OptChosenInlineResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChosenInlineResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChosenInlineResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChosenInlineResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Contact as json.
func (o OptContact) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Contact from json.
func (o *OptContact) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContact to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CopyTextButton as json.
func (o OptCopyTextButton) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CopyTextButton from json.
func (o *OptCopyTextButton) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCopyTextButton to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCopyTextButton) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCopyTextButton) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteMyCommands as json.
func (o OptDeleteMyCommands) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeleteMyCommands from json.
func (o *OptDeleteMyCommands) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeleteMyCommands to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDeleteMyCommands) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDeleteMyCommands) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteWebhook as json.
func (o OptDeleteWebhook) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeleteWebhook from json.
func (o *OptDeleteWebhook) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeleteWebhook to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDeleteWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDeleteWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Dice as json.
func (o OptDice) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Dice from json.
func (o *OptDice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDice to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Document as json.
func (o OptDocument) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Document from json.
func (o *OptDocument) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDocument to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDocument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDocument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExternalReplyInfo as json.
func (o OptExternalReplyInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExternalReplyInfo from json.
func (o *OptExternalReplyInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExternalReplyInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExternalReplyInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExternalReplyInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes File as json.
func (o OptFile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes File from json.
func (o *OptFile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ForumTopicCreated as json.
func (o OptForumTopicCreated) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ForumTopicCreated from json.
func (o *OptForumTopicCreated) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptForumTopicCreated to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptForumTopicCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptForumTopicCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ForumTopicEdited as json.
func (o OptForumTopicEdited) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ForumTopicEdited from json.
func (o *OptForumTopicEdited) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptForumTopicEdited to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptForumTopicEdited) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptForumTopicEdited) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Game as json.
func (o OptGame) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Game from json.
func (o *OptGame) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGame to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGame) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGame) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetChatMenuButton as json.
func (o OptGetChatMenuButton) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetChatMenuButton from json.
func (o *OptGetChatMenuButton) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetChatMenuButton to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetChatMenuButton) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetChatMenuButton) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetMyCommands as json.
func (o OptGetMyCommands) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetMyCommands from json.
func (o *OptGetMyCommands) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetMyCommands to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetMyCommands) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetMyCommands) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetMyDefaultAdministratorRights as json.
func (o OptGetMyDefaultAdministratorRights) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetMyDefaultAdministratorRights from json.
func (o *OptGetMyDefaultAdministratorRights) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetMyDefaultAdministratorRights to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetMyDefaultAdministratorRights) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetMyDefaultAdministratorRights) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetMyDescription as json.
func (o OptGetMyDescription) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetMyDescription from json.
func (o *OptGetMyDescription) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetMyDescription to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetMyDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetMyDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetMyName as json.
func (o OptGetMyName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetMyName from json.
func (o *OptGetMyName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetMyName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetMyName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetMyName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetMyShortDescription as json.
func (o OptGetMyShortDescription) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetMyShortDescription from json.
func (o *OptGetMyShortDescription) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetMyShortDescription to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetMyShortDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetMyShortDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetStarTransactions as json.
func (o OptGetStarTransactions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetStarTransactions from json.
func (o *OptGetStarTransactions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetStarTransactions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetStarTransactions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetStarTransactions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUpdates as json.
func (o OptGetUpdates) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetUpdates from json.
func (o *OptGetUpdates) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUpdates to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUpdates) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUpdates) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Giveaway as json.
func (o OptGiveaway) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Giveaway from json.
func (o *OptGiveaway) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGiveaway to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGiveaway) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGiveaway) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GiveawayCompleted as json.
func (o OptGiveawayCompleted) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GiveawayCompleted from json.
func (o *OptGiveawayCompleted) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGiveawayCompleted to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGiveawayCompleted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGiveawayCompleted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GiveawayCreated as json.
func (o OptGiveawayCreated) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GiveawayCreated from json.
func (o *OptGiveawayCreated) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGiveawayCreated to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGiveawayCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGiveawayCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GiveawayWinners as json.
func (o OptGiveawayWinners) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GiveawayWinners from json.
func (o *OptGiveawayWinners) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGiveawayWinners to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGiveawayWinners) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGiveawayWinners) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ID as json.
func (o OptID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ID from json.
func (o *OptID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InlineKeyboardMarkup as json.
func (o OptInlineKeyboardMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InlineKeyboardMarkup from json.
func (o *OptInlineKeyboardMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInlineKeyboardMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInlineKeyboardMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInlineKeyboardMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InlineQuery as json.
func (o OptInlineQuery) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InlineQuery from json.
func (o *OptInlineQuery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInlineQuery to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInlineQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInlineQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InlineQueryChatType as json.
func (o OptInlineQueryChatType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InlineQueryChatType from json.
func (o *OptInlineQueryChatType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInlineQueryChatType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInlineQueryChatType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInlineQueryChatType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InlineQueryResultsButton as json.
func (o OptInlineQueryResultsButton) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InlineQueryResultsButton from json.
func (o *OptInlineQueryResultsButton) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInlineQueryResultsButton to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInlineQueryResultsButton) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInlineQueryResultsButton) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InputMessageContent as json.
func (o OptInputMessageContent) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InputMessageContent from json.
func (o *OptInputMessageContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInputMessageContent to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInputMessageContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInputMessageContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Invoice as json.
func (o OptInvoice) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Invoice from json.
func (o *OptInvoice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInvoice to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInvoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInvoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes KeyboardButtonPollType as json.
func (o OptKeyboardButtonPollType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes KeyboardButtonPollType from json.
func (o *OptKeyboardButtonPollType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptKeyboardButtonPollType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptKeyboardButtonPollType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptKeyboardButtonPollType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes KeyboardButtonRequestChat as json.
func (o OptKeyboardButtonRequestChat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes KeyboardButtonRequestChat from json.
func (o *OptKeyboardButtonRequestChat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptKeyboardButtonRequestChat to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptKeyboardButtonRequestChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptKeyboardButtonRequestChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes KeyboardButtonRequestUsers as json.
func (o OptKeyboardButtonRequestUsers) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes KeyboardButtonRequestUsers from json.
func (o *OptKeyboardButtonRequestUsers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptKeyboardButtonRequestUsers to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptKeyboardButtonRequestUsers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptKeyboardButtonRequestUsers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LinkPreviewOptions as json.
func (o OptLinkPreviewOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LinkPreviewOptions from json.
func (o *OptLinkPreviewOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLinkPreviewOptions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLinkPreviewOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLinkPreviewOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Location as json.
func (o OptLocation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Location from json.
func (o *OptLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLocation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LoginUrl as json.
func (o OptLoginUrl) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LoginUrl from json.
func (o *OptLoginUrl) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLoginUrl to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLoginUrl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLoginUrl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MaskPosition as json.
func (o OptMaskPosition) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MaskPosition from json.
func (o *OptMaskPosition) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMaskPosition to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMaskPosition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMaskPosition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MaybeInaccessibleMessage as json.
func (o OptMaybeInaccessibleMessage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MaybeInaccessibleMessage from json.
func (o *OptMaybeInaccessibleMessage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMaybeInaccessibleMessage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMaybeInaccessibleMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMaybeInaccessibleMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MenuButton as json.
func (o OptMenuButton) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MenuButton from json.
func (o *OptMenuButton) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMenuButton to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMenuButton) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMenuButton) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Message as json.
func (o OptMessage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Message from json.
func (o *OptMessage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMessage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageAutoDeleteTimerChanged as json.
func (o OptMessageAutoDeleteTimerChanged) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MessageAutoDeleteTimerChanged from json.
func (o *OptMessageAutoDeleteTimerChanged) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMessageAutoDeleteTimerChanged to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMessageAutoDeleteTimerChanged) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMessageAutoDeleteTimerChanged) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageId as json.
func (o OptMessageId) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MessageId from json.
func (o *OptMessageId) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMessageId to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMessageId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMessageId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageOrigin as json.
func (o OptMessageOrigin) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MessageOrigin from json.
func (o *OptMessageOrigin) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMessageOrigin to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMessageOrigin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMessageOrigin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageReactionCountUpdated as json.
func (o OptMessageReactionCountUpdated) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MessageReactionCountUpdated from json.
func (o *OptMessageReactionCountUpdated) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMessageReactionCountUpdated to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMessageReactionCountUpdated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMessageReactionCountUpdated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageReactionUpdated as json.
func (o OptMessageReactionUpdated) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MessageReactionUpdated from json.
func (o *OptMessageReactionUpdated) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMessageReactionUpdated to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMessageReactionUpdated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMessageReactionUpdated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrderInfo as json.
func (o OptOrderInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrderInfo from json.
func (o *OptOrderInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrderInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrderInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrderInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PaidMediaInfo as json.
func (o OptPaidMediaInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PaidMediaInfo from json.
func (o *OptPaidMediaInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPaidMediaInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPaidMediaInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPaidMediaInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PaidMediaPurchased as json.
func (o OptPaidMediaPurchased) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PaidMediaPurchased from json.
func (o *OptPaidMediaPurchased) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPaidMediaPurchased to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPaidMediaPurchased) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPaidMediaPurchased) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportData as json.
func (o OptPassportData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PassportData from json.
func (o *OptPassportData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPassportData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPassportData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPassportData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportFile as json.
func (o OptPassportFile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PassportFile from json.
func (o *OptPassportFile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPassportFile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPassportFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPassportFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PhotoSize as json.
func (o OptPhotoSize) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PhotoSize from json.
func (o *OptPhotoSize) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPhotoSize to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPhotoSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPhotoSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Poll as json.
func (o OptPoll) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Poll from json.
func (o *OptPoll) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoll to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoll) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoll) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PollAnswer as json.
func (o OptPollAnswer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PollAnswer from json.
func (o *OptPollAnswer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPollAnswer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPollAnswer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPollAnswer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PreCheckoutQuery as json.
func (o OptPreCheckoutQuery) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PreCheckoutQuery from json.
func (o *OptPreCheckoutQuery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPreCheckoutQuery to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPreCheckoutQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPreCheckoutQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProximityAlertTriggered as json.
func (o OptProximityAlertTriggered) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProximityAlertTriggered from json.
func (o *OptProximityAlertTriggered) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProximityAlertTriggered to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProximityAlertTriggered) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProximityAlertTriggered) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RefundedPayment as json.
func (o OptRefundedPayment) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RefundedPayment from json.
func (o *OptRefundedPayment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRefundedPayment to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRefundedPayment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRefundedPayment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReplyParameters as json.
func (o OptReplyParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReplyParameters from json.
func (o *OptReplyParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReplyParameters to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReplyParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReplyParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResponseParameters as json.
func (o OptResponseParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResponseParameters from json.
func (o *OptResponseParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResponseParameters to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResponseParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResponseParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResultMessageOrBooleanResult as json.
func (o OptResultMessageOrBooleanResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResultMessageOrBooleanResult from json.
func (o *OptResultMessageOrBooleanResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResultMessageOrBooleanResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResultMessageOrBooleanResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResultMessageOrBooleanResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendReplyMarkup as json.
func (o OptSendReplyMarkup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendReplyMarkup from json.
func (o *OptSendReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendReplyMarkup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetChatMenuButton as json.
func (o OptSetChatMenuButton) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SetChatMenuButton from json.
func (o *OptSetChatMenuButton) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSetChatMenuButton to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSetChatMenuButton) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSetChatMenuButton) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetMyDefaultAdministratorRights as json.
func (o OptSetMyDefaultAdministratorRights) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SetMyDefaultAdministratorRights from json.
func (o *OptSetMyDefaultAdministratorRights) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSetMyDefaultAdministratorRights to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSetMyDefaultAdministratorRights) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSetMyDefaultAdministratorRights) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetMyDescription as json.
func (o OptSetMyDescription) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SetMyDescription from json.
func (o *OptSetMyDescription) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSetMyDescription to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSetMyDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSetMyDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetMyName as json.
func (o OptSetMyName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SetMyName from json.
func (o *OptSetMyName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSetMyName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSetMyName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSetMyName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetMyShortDescription as json.
func (o OptSetMyShortDescription) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SetMyShortDescription from json.
func (o *OptSetMyShortDescription) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSetMyShortDescription to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSetMyShortDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSetMyShortDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ShippingAddress as json.
func (o OptShippingAddress) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ShippingAddress from json.
func (o *OptShippingAddress) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptShippingAddress to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptShippingAddress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptShippingAddress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ShippingQuery as json.
func (o OptShippingQuery) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ShippingQuery from json.
func (o *OptShippingQuery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptShippingQuery to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptShippingQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptShippingQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Sticker as json.
func (o OptSticker) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Sticker from json.
func (o *OptSticker) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSticker to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSticker) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSticker) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StickerSet as json.
func (o OptStickerSet) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes StickerSet from json.
func (o *OptStickerSet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStickerSet to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStickerSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStickerSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Story as json.
func (o OptStory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Story from json.
func (o *OptStory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessfulPayment as json.
func (o OptSuccessfulPayment) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessfulPayment from json.
func (o *OptSuccessfulPayment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessfulPayment to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessfulPayment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessfulPayment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SwitchInlineQueryChosenChat as json.
func (o OptSwitchInlineQueryChosenChat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SwitchInlineQueryChosenChat from json.
func (o *OptSwitchInlineQueryChosenChat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSwitchInlineQueryChosenChat to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSwitchInlineQueryChosenChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSwitchInlineQueryChosenChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TextQuote as json.
func (o OptTextQuote) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TextQuote from json.
func (o *OptTextQuote) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTextQuote to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTextQuote) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTextQuote) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes User as json.
func (o OptUser) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes User from json.
func (o *OptUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUser to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserProfilePhotos as json.
func (o OptUserProfilePhotos) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserProfilePhotos from json.
func (o *OptUserProfilePhotos) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserProfilePhotos to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserProfilePhotos) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserProfilePhotos) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersShared as json.
func (o OptUsersShared) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UsersShared from json.
func (o *OptUsersShared) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUsersShared to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUsersShared) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUsersShared) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Venue as json.
func (o OptVenue) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Venue from json.
func (o *OptVenue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVenue to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVenue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVenue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Video as json.
func (o OptVideo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Video from json.
func (o *OptVideo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVideo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVideo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVideo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VideoChatEnded as json.
func (o OptVideoChatEnded) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VideoChatEnded from json.
func (o *OptVideoChatEnded) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVideoChatEnded to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVideoChatEnded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVideoChatEnded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VideoChatParticipantsInvited as json.
func (o OptVideoChatParticipantsInvited) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VideoChatParticipantsInvited from json.
func (o *OptVideoChatParticipantsInvited) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVideoChatParticipantsInvited to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVideoChatParticipantsInvited) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVideoChatParticipantsInvited) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VideoChatScheduled as json.
func (o OptVideoChatScheduled) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VideoChatScheduled from json.
func (o *OptVideoChatScheduled) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVideoChatScheduled to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVideoChatScheduled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVideoChatScheduled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VideoNote as json.
func (o OptVideoNote) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VideoNote from json.
func (o *OptVideoNote) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVideoNote to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVideoNote) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVideoNote) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Voice as json.
func (o OptVoice) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Voice from json.
func (o *OptVoice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVoice to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebAppData as json.
func (o OptWebAppData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebAppData from json.
func (o *OptWebAppData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebAppData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebAppData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebAppData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebAppInfo as json.
func (o OptWebAppInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebAppInfo from json.
func (o *OptWebAppInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebAppInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebAppInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebAppInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookInfo as json.
func (o OptWebhookInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookInfo from json.
func (o *OptWebhookInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WriteAccessAllowed as json.
func (o OptWriteAccessAllowed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WriteAccessAllowed from json.
func (o *OptWriteAccessAllowed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWriteAccessAllowed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWriteAccessAllowed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWriteAccessAllowed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrderInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrderInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.PhoneNumber.Set {
			e.FieldStart("phone_number")
			s.PhoneNumber.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.ShippingAddress.Set {
			e.FieldStart("shipping_address")
			s.ShippingAddress.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrderInfo = [4]string{
	0: "name",
	1: "phone_number",
	2: "email",
	3: "shipping_address",
}

// Decode decodes OrderInfo from json.
func (s *OrderInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "phone_number":
			if err := func() error {
				s.PhoneNumber.Reset()
				if err := s.PhoneNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "shipping_address":
			if err := func() error {
				s.ShippingAddress.Reset()
				if err := s.ShippingAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shipping_address\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrderInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrderInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PaidMedia as json.
func (s PaidMedia) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s PaidMedia) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case PaidMediaPhotoPaidMedia:
		e.FieldStart("type")
		e.Str("PaidMediaPhoto")
		{
			s := s.PaidMediaPhoto
			{
				e.FieldStart("photo")
				e.ArrStart()
				for _, elem := range s.Photo {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case PaidMediaPreviewPaidMedia:
		e.FieldStart("type")
		e.Str("PaidMediaPreview")
		{
			s := s.PaidMediaPreview
			{
				if s.Width.Set {
					e.FieldStart("width")
					s.Width.Encode(e)
				}
			}
			{
				if s.Height.Set {
					e.FieldStart("height")
					s.Height.Encode(e)
				}
			}
			{
				if s.Duration.Set {
					e.FieldStart("duration")
					s.Duration.Encode(e)
				}
			}
		}
	case PaidMediaVideoPaidMedia:
		e.FieldStart("type")
		e.Str("PaidMediaVideo")
		{
			s := s.PaidMediaVideo
			{
				e.FieldStart("video")
				s.Video.Encode(e)
			}
		}
	}
}

// Decode decodes PaidMedia from json.
func (s *PaidMedia) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaidMedia to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "PaidMediaPhoto":
					s.Type = PaidMediaPhotoPaidMedia
					found = true
				case "PaidMediaPreview":
					s.Type = PaidMediaPreviewPaidMedia
					found = true
				case "PaidMediaVideo":
					s.Type = PaidMediaVideoPaidMedia
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PaidMediaPreviewPaidMedia:
		if err := s.PaidMediaPreview.Decode(d); err != nil {
			return err
		}
	case PaidMediaPhotoPaidMedia:
		if err := s.PaidMediaPhoto.Decode(d); err != nil {
			return err
		}
	case PaidMediaVideoPaidMedia:
		if err := s.PaidMediaVideo.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PaidMedia) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaidMedia) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaidMediaInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaidMediaInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("star_count")
		e.Int(s.StarCount)
	}
	{
		e.FieldStart("paid_media")
		e.ArrStart()
		for _, elem := range s.PaidMedia {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPaidMediaInfo = [2]string{
	0: "star_count",
	1: "paid_media",
}

// Decode decodes PaidMediaInfo from json.
func (s *PaidMediaInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaidMediaInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "star_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.StarCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"star_count\"")
			}
		case "paid_media":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.PaidMedia = make([]PaidMedia, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PaidMedia
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PaidMedia = append(s.PaidMedia, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paid_media\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaidMediaInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPaidMediaInfo) {
					name = jsonFieldsNameOfPaidMediaInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaidMediaInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaidMediaInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaidMediaPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaidMediaPhoto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("photo")
		e.ArrStart()
		for _, elem := range s.Photo {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPaidMediaPhoto = [2]string{
	0: "type",
	1: "photo",
}

// Decode decodes PaidMediaPhoto from json.
func (s *PaidMediaPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaidMediaPhoto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "photo":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Photo = make([]PhotoSize, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PhotoSize
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Photo = append(s.Photo, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaidMediaPhoto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPaidMediaPhoto) {
					name = jsonFieldsNameOfPaidMediaPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaidMediaPhoto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaidMediaPhoto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaidMediaPreview) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaidMediaPreview) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.Width.Set {
			e.FieldStart("width")
			s.Width.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
}

var jsonFieldsNameOfPaidMediaPreview = [4]string{
	0: "type",
	1: "width",
	2: "height",
	3: "duration",
}

// Decode decodes PaidMediaPreview from json.
func (s *PaidMediaPreview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaidMediaPreview to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "width":
			if err := func() error {
				s.Width.Reset()
				if err := s.Width.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaidMediaPreview")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPaidMediaPreview) {
					name = jsonFieldsNameOfPaidMediaPreview[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaidMediaPreview) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaidMediaPreview) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaidMediaPurchased) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaidMediaPurchased) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("from")
		s.From.Encode(e)
	}
	{
		e.FieldStart("paid_media_payload")
		e.Str(s.PaidMediaPayload)
	}
}

var jsonFieldsNameOfPaidMediaPurchased = [2]string{
	0: "from",
	1: "paid_media_payload",
}

// Decode decodes PaidMediaPurchased from json.
func (s *PaidMediaPurchased) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaidMediaPurchased to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "paid_media_payload":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PaidMediaPayload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paid_media_payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaidMediaPurchased")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPaidMediaPurchased) {
					name = jsonFieldsNameOfPaidMediaPurchased[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaidMediaPurchased) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaidMediaPurchased) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaidMediaVideo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaidMediaVideo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("video")
		s.Video.Encode(e)
	}
}

var jsonFieldsNameOfPaidMediaVideo = [2]string{
	0: "type",
	1: "video",
}

// Decode decodes PaidMediaVideo from json.
func (s *PaidMediaVideo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaidMediaVideo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "video":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Video.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaidMediaVideo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPaidMediaVideo) {
					name = jsonFieldsNameOfPaidMediaVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaidMediaVideo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaidMediaVideo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("credentials")
		s.Credentials.Encode(e)
	}
}

var jsonFieldsNameOfPassportData = [2]string{
	0: "data",
	1: "credentials",
}

// Decode decodes PassportData from json.
func (s *PassportData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]EncryptedPassportElement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EncryptedPassportElement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "credentials":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Credentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentials\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportData) {
					name = jsonFieldsNameOfPassportData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementError as json.
func (s PassportElementError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s PassportElementError) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case PassportElementErrorDataFieldPassportElementError:
		e.FieldStart("type")
		e.Str("data")
		{
			s := s.PassportElementErrorDataField
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("field_name")
				e.Str(s.FieldName)
			}
			{
				e.FieldStart("data_hash")
				e.Str(s.DataHash)
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	case PassportElementErrorFilePassportElementError:
		e.FieldStart("type")
		e.Str("file")
		{
			s := s.PassportElementErrorFile
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("file_hash")
				e.Str(s.FileHash)
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	case PassportElementErrorFilesPassportElementError:
		e.FieldStart("type")
		e.Str("files")
		{
			s := s.PassportElementErrorFiles
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("file_hashes")
				e.ArrStart()
				for _, elem := range s.FileHashes {
					e.Str(elem)
				}
				e.ArrEnd()
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	case PassportElementErrorFrontSidePassportElementError:
		e.FieldStart("type")
		e.Str("front_side")
		{
			s := s.PassportElementErrorFrontSide
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("file_hash")
				e.Str(s.FileHash)
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	case PassportElementErrorReverseSidePassportElementError:
		e.FieldStart("type")
		e.Str("reverse_side")
		{
			s := s.PassportElementErrorReverseSide
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("file_hash")
				e.Str(s.FileHash)
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	case PassportElementErrorSelfiePassportElementError:
		e.FieldStart("type")
		e.Str("selfie")
		{
			s := s.PassportElementErrorSelfie
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("file_hash")
				e.Str(s.FileHash)
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	case PassportElementErrorTranslationFilePassportElementError:
		e.FieldStart("type")
		e.Str("translation_file")
		{
			s := s.PassportElementErrorTranslationFile
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("file_hash")
				e.Str(s.FileHash)
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	case PassportElementErrorTranslationFilesPassportElementError:
		e.FieldStart("type")
		e.Str("translation_files")
		{
			s := s.PassportElementErrorTranslationFiles
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("file_hashes")
				e.ArrStart()
				for _, elem := range s.FileHashes {
					e.Str(elem)
				}
				e.ArrEnd()
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	case PassportElementErrorUnspecifiedPassportElementError:
		e.FieldStart("type")
		e.Str("unspecified")
		{
			s := s.PassportElementErrorUnspecified
			{
				e.FieldStart("source")
				e.Str(s.Source)
			}
			{
				e.FieldStart("element_hash")
				e.Str(s.ElementHash)
			}
			{
				e.FieldStart("message")
				e.Str(s.Message)
			}
		}
	}
}

// Decode decodes PassportElementError from json.
func (s *PassportElementError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementError to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "data":
					s.Type = PassportElementErrorDataFieldPassportElementError
					found = true
				case "file":
					s.Type = PassportElementErrorFilePassportElementError
					found = true
				case "files":
					s.Type = PassportElementErrorFilesPassportElementError
					found = true
				case "front_side":
					s.Type = PassportElementErrorFrontSidePassportElementError
					found = true
				case "reverse_side":
					s.Type = PassportElementErrorReverseSidePassportElementError
					found = true
				case "selfie":
					s.Type = PassportElementErrorSelfiePassportElementError
					found = true
				case "translation_file":
					s.Type = PassportElementErrorTranslationFilePassportElementError
					found = true
				case "translation_files":
					s.Type = PassportElementErrorTranslationFilesPassportElementError
					found = true
				case "unspecified":
					s.Type = PassportElementErrorUnspecifiedPassportElementError
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PassportElementErrorDataFieldPassportElementError:
		if err := s.PassportElementErrorDataField.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorFrontSidePassportElementError:
		if err := s.PassportElementErrorFrontSide.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorReverseSidePassportElementError:
		if err := s.PassportElementErrorReverseSide.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorSelfiePassportElementError:
		if err := s.PassportElementErrorSelfie.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorFilePassportElementError:
		if err := s.PassportElementErrorFile.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorFilesPassportElementError:
		if err := s.PassportElementErrorFiles.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorTranslationFilePassportElementError:
		if err := s.PassportElementErrorTranslationFile.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorTranslationFilesPassportElementError:
		if err := s.PassportElementErrorTranslationFiles.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorUnspecifiedPassportElementError:
		if err := s.PassportElementErrorUnspecified.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorDataField) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorDataField) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("field_name")
		e.Str(s.FieldName)
	}
	{
		e.FieldStart("data_hash")
		e.Str(s.DataHash)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorDataField = [5]string{
	0: "source",
	1: "type",
	2: "field_name",
	3: "data_hash",
	4: "message",
}

// Decode decodes PassportElementErrorDataField from json.
func (s *PassportElementErrorDataField) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorDataField to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "field_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FieldName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"field_name\"")
			}
		case "data_hash":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.DataHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_hash\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorDataField")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorDataField) {
					name = jsonFieldsNameOfPassportElementErrorDataField[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorDataField) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorDataField) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementErrorDataFieldType as json.
func (s PassportElementErrorDataFieldType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorDataFieldType from json.
func (s *PassportElementErrorDataFieldType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorDataFieldType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorDataFieldType(v) {
	case PassportElementErrorDataFieldTypePersonalDetails:
		*s = PassportElementErrorDataFieldTypePersonalDetails
	case PassportElementErrorDataFieldTypePassport:
		*s = PassportElementErrorDataFieldTypePassport
	case PassportElementErrorDataFieldTypeDriverLicense:
		*s = PassportElementErrorDataFieldTypeDriverLicense
	case PassportElementErrorDataFieldTypeIdentityCard:
		*s = PassportElementErrorDataFieldTypeIdentityCard
	case PassportElementErrorDataFieldTypeInternalPassport:
		*s = PassportElementErrorDataFieldTypeInternalPassport
	case PassportElementErrorDataFieldTypeAddress:
		*s = PassportElementErrorDataFieldTypeAddress
	default:
		*s = PassportElementErrorDataFieldType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementErrorDataFieldType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorDataFieldType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorFile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("file_hash")
		e.Str(s.FileHash)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorFile = [4]string{
	0: "source",
	1: "type",
	2: "file_hash",
	3: "message",
}

// Decode decodes PassportElementErrorFile from json.
func (s *PassportElementErrorFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorFile to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "file_hash":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FileHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_hash\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorFile) {
					name = jsonFieldsNameOfPassportElementErrorFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementErrorFileType as json.
func (s PassportElementErrorFileType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorFileType from json.
func (s *PassportElementErrorFileType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorFileType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorFileType(v) {
	case PassportElementErrorFileTypeUtilityBill:
		*s = PassportElementErrorFileTypeUtilityBill
	case PassportElementErrorFileTypeBankStatement:
		*s = PassportElementErrorFileTypeBankStatement
	case PassportElementErrorFileTypeRentalAgreement:
		*s = PassportElementErrorFileTypeRentalAgreement
	case PassportElementErrorFileTypePassportRegistration:
		*s = PassportElementErrorFileTypePassportRegistration
	case PassportElementErrorFileTypeTemporaryRegistration:
		*s = PassportElementErrorFileTypeTemporaryRegistration
	default:
		*s = PassportElementErrorFileType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementErrorFileType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorFileType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorFiles) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorFiles) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("file_hashes")
		e.ArrStart()
		for _, elem := range s.FileHashes {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorFiles = [4]string{
	0: "source",
	1: "type",
	2: "file_hashes",
	3: "message",
}

// Decode decodes PassportElementErrorFiles from json.
func (s *PassportElementErrorFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorFiles to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "file_hashes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.FileHashes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FileHashes = append(s.FileHashes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_hashes\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorFiles")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorFiles) {
					name = jsonFieldsNameOfPassportElementErrorFiles[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorFiles) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorFiles) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementErrorFilesType as json.
func (s PassportElementErrorFilesType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorFilesType from json.
func (s *PassportElementErrorFilesType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorFilesType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorFilesType(v) {
	case PassportElementErrorFilesTypeUtilityBill:
		*s = PassportElementErrorFilesTypeUtilityBill
	case PassportElementErrorFilesTypeBankStatement:
		*s = PassportElementErrorFilesTypeBankStatement
	case PassportElementErrorFilesTypeRentalAgreement:
		*s = PassportElementErrorFilesTypeRentalAgreement
	case PassportElementErrorFilesTypePassportRegistration:
		*s = PassportElementErrorFilesTypePassportRegistration
	case PassportElementErrorFilesTypeTemporaryRegistration:
		*s = PassportElementErrorFilesTypeTemporaryRegistration
	default:
		*s = PassportElementErrorFilesType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementErrorFilesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorFilesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorFrontSide) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorFrontSide) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("file_hash")
		e.Str(s.FileHash)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorFrontSide = [4]string{
	0: "source",
	1: "type",
	2: "file_hash",
	3: "message",
}

// Decode decodes PassportElementErrorFrontSide from json.
func (s *PassportElementErrorFrontSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorFrontSide to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "file_hash":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FileHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_hash\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorFrontSide")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorFrontSide) {
					name = jsonFieldsNameOfPassportElementErrorFrontSide[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorFrontSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorFrontSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementErrorFrontSideType as json.
func (s PassportElementErrorFrontSideType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorFrontSideType from json.
func (s *PassportElementErrorFrontSideType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorFrontSideType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorFrontSideType(v) {
	case PassportElementErrorFrontSideTypePassport:
		*s = PassportElementErrorFrontSideTypePassport
	case PassportElementErrorFrontSideTypeDriverLicense:
		*s = PassportElementErrorFrontSideTypeDriverLicense
	case PassportElementErrorFrontSideTypeIdentityCard:
		*s = PassportElementErrorFrontSideTypeIdentityCard
	case PassportElementErrorFrontSideTypeInternalPassport:
		*s = PassportElementErrorFrontSideTypeInternalPassport
	default:
		*s = PassportElementErrorFrontSideType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementErrorFrontSideType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorFrontSideType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorReverseSide) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorReverseSide) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("file_hash")
		e.Str(s.FileHash)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorReverseSide = [4]string{
	0: "source",
	1: "type",
	2: "file_hash",
	3: "message",
}

// Decode decodes PassportElementErrorReverseSide from json.
func (s *PassportElementErrorReverseSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorReverseSide to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "file_hash":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FileHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_hash\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorReverseSide")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorReverseSide) {
					name = jsonFieldsNameOfPassportElementErrorReverseSide[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorReverseSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorReverseSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementErrorReverseSideType as json.
func (s PassportElementErrorReverseSideType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorReverseSideType from json.
func (s *PassportElementErrorReverseSideType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorReverseSideType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorReverseSideType(v) {
	case PassportElementErrorReverseSideTypeDriverLicense:
		*s = PassportElementErrorReverseSideTypeDriverLicense
	case PassportElementErrorReverseSideTypeIdentityCard:
		*s = PassportElementErrorReverseSideTypeIdentityCard
	default:
		*s = PassportElementErrorReverseSideType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementErrorReverseSideType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorReverseSideType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorSelfie) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorSelfie) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("file_hash")
		e.Str(s.FileHash)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorSelfie = [4]string{
	0: "source",
	1: "type",
	2: "file_hash",
	3: "message",
}

// Decode decodes PassportElementErrorSelfie from json.
func (s *PassportElementErrorSelfie) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorSelfie to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "file_hash":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FileHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_hash\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorSelfie")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorSelfie) {
					name = jsonFieldsNameOfPassportElementErrorSelfie[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorSelfie) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorSelfie) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementErrorSelfieType as json.
func (s PassportElementErrorSelfieType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorSelfieType from json.
func (s *PassportElementErrorSelfieType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorSelfieType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorSelfieType(v) {
	case PassportElementErrorSelfieTypePassport:
		*s = PassportElementErrorSelfieTypePassport
	case PassportElementErrorSelfieTypeDriverLicense:
		*s = PassportElementErrorSelfieTypeDriverLicense
	case PassportElementErrorSelfieTypeIdentityCard:
		*s = PassportElementErrorSelfieTypeIdentityCard
	case PassportElementErrorSelfieTypeInternalPassport:
		*s = PassportElementErrorSelfieTypeInternalPassport
	default:
		*s = PassportElementErrorSelfieType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementErrorSelfieType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorSelfieType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorTranslationFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorTranslationFile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("file_hash")
		e.Str(s.FileHash)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorTranslationFile = [4]string{
	0: "source",
	1: "type",
	2: "file_hash",
	3: "message",
}

// Decode decodes PassportElementErrorTranslationFile from json.
func (s *PassportElementErrorTranslationFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorTranslationFile to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "file_hash":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FileHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_hash\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorTranslationFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorTranslationFile) {
					name = jsonFieldsNameOfPassportElementErrorTranslationFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorTranslationFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorTranslationFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementErrorTranslationFileType as json.
func (s PassportElementErrorTranslationFileType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorTranslationFileType from json.
func (s *PassportElementErrorTranslationFileType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorTranslationFileType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorTranslationFileType(v) {
	case PassportElementErrorTranslationFileTypePassport:
		*s = PassportElementErrorTranslationFileTypePassport
	case PassportElementErrorTranslationFileTypeDriverLicense:
		*s = PassportElementErrorTranslationFileTypeDriverLicense
	case PassportElementErrorTranslationFileTypeIdentityCard:
		*s = PassportElementErrorTranslationFileTypeIdentityCard
	case PassportElementErrorTranslationFileTypeInternalPassport:
		*s = PassportElementErrorTranslationFileTypeInternalPassport
	case PassportElementErrorTranslationFileTypeUtilityBill:
		*s = PassportElementErrorTranslationFileTypeUtilityBill
	case PassportElementErrorTranslationFileTypeBankStatement:
		*s = PassportElementErrorTranslationFileTypeBankStatement
	case PassportElementErrorTranslationFileTypeRentalAgreement:
		*s = PassportElementErrorTranslationFileTypeRentalAgreement
	case PassportElementErrorTranslationFileTypePassportRegistration:
		*s = PassportElementErrorTranslationFileTypePassportRegistration
	case PassportElementErrorTranslationFileTypeTemporaryRegistration:
		*s = PassportElementErrorTranslationFileTypeTemporaryRegistration
	default:
		*s = PassportElementErrorTranslationFileType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementErrorTranslationFileType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorTranslationFileType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorTranslationFiles) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorTranslationFiles) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("file_hashes")
		e.ArrStart()
		for _, elem := range s.FileHashes {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorTranslationFiles = [4]string{
	0: "source",
	1: "type",
	2: "file_hashes",
	3: "message",
}

// Decode decodes PassportElementErrorTranslationFiles from json.
func (s *PassportElementErrorTranslationFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorTranslationFiles to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "file_hashes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.FileHashes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FileHashes = append(s.FileHashes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_hashes\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorTranslationFiles")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorTranslationFiles) {
					name = jsonFieldsNameOfPassportElementErrorTranslationFiles[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorTranslationFiles) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorTranslationFiles) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PassportElementErrorTranslationFilesType as json.
func (s PassportElementErrorTranslationFilesType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorTranslationFilesType from json.
func (s *PassportElementErrorTranslationFilesType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorTranslationFilesType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorTranslationFilesType(v) {
	case PassportElementErrorTranslationFilesTypePassport:
		*s = PassportElementErrorTranslationFilesTypePassport
	case PassportElementErrorTranslationFilesTypeDriverLicense:
		*s = PassportElementErrorTranslationFilesTypeDriverLicense
	case PassportElementErrorTranslationFilesTypeIdentityCard:
		*s = PassportElementErrorTranslationFilesTypeIdentityCard
	case PassportElementErrorTranslationFilesTypeInternalPassport:
		*s = PassportElementErrorTranslationFilesTypeInternalPassport
	case PassportElementErrorTranslationFilesTypeUtilityBill:
		*s = PassportElementErrorTranslationFilesTypeUtilityBill
	case PassportElementErrorTranslationFilesTypeBankStatement:
		*s = PassportElementErrorTranslationFilesTypeBankStatement
	case PassportElementErrorTranslationFilesTypeRentalAgreement:
		*s = PassportElementErrorTranslationFilesTypeRentalAgreement
	case PassportElementErrorTranslationFilesTypePassportRegistration:
		*s = PassportElementErrorTranslationFilesTypePassportRegistration
	case PassportElementErrorTranslationFilesTypeTemporaryRegistration:
		*s = PassportElementErrorTranslationFilesTypeTemporaryRegistration
	default:
		*s = PassportElementErrorTranslationFilesType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PassportElementErrorTranslationFilesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorTranslationFilesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportElementErrorUnspecified) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportElementErrorUnspecified) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("element_hash")
		e.Str(s.ElementHash)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPassportElementErrorUnspecified = [4]string{
	0: "source",
	1: "type",
	2: "element_hash",
	3: "message",
}

// Decode decodes PassportElementErrorUnspecified from json.
func (s *PassportElementErrorUnspecified) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportElementErrorUnspecified to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "element_hash":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ElementHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"element_hash\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportElementErrorUnspecified")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorUnspecified) {
					name = jsonFieldsNameOfPassportElementErrorUnspecified[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportElementErrorUnspecified) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportElementErrorUnspecified) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PassportFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PassportFile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		e.FieldStart("file_size")
		e.Int(s.FileSize)
	}
	{
		e.FieldStart("file_date")
		e.Int(s.FileDate)
	}
}

var jsonFieldsNameOfPassportFile = [4]string{
	0: "file_id",
	1: "file_unique_id",
	2: "file_size",
	3: "file_date",
}

// Decode decodes PassportFile from json.
func (s *PassportFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PassportFile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "file_size":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.FileSize = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		case "file_date":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.FileDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PassportFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportFile) {
					name = jsonFieldsNameOfPassportFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PassportFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PassportFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PhotoSize) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PhotoSize) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		e.FieldStart("width")
		e.Int(s.Width)
	}
	{
		e.FieldStart("height")
		e.Int(s.Height)
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfPhotoSize = [5]string{
	0: "file_id",
	1: "file_unique_id",
	2: "width",
	3: "height",
	4: "file_size",
}

// Decode decodes PhotoSize from json.
func (s *PhotoSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PhotoSize to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "width":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Width = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Height = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PhotoSize")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPhotoSize) {
					name = jsonFieldsNameOfPhotoSize[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PhotoSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PhotoSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PinChatMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PinChatMessage) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
}

var jsonFieldsNameOfPinChatMessage = [4]string{
	0: "business_connection_id",
	1: "chat_id",
	2: "message_id",
	3: "disable_notification",
}

// Decode decodes PinChatMessage from json.
func (s *PinChatMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PinChatMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PinChatMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPinChatMessage) {
					name = jsonFieldsNameOfPinChatMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PinChatMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PinChatMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Poll) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Poll) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("question")
		e.Str(s.Question)
	}
	{
		if s.QuestionEntities != nil {
			e.FieldStart("question_entities")
			e.ArrStart()
			for _, elem := range s.QuestionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("options")
		e.ArrStart()
		for _, elem := range s.Options {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total_voter_count")
		e.Int(s.TotalVoterCount)
	}
	{
		e.FieldStart("is_closed")
		e.Bool(s.IsClosed)
	}
	{
		e.FieldStart("is_anonymous")
		e.Bool(s.IsAnonymous)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("allows_multiple_answers")
		e.Bool(s.AllowsMultipleAnswers)
	}
	{
		if s.CorrectOptionID.Set {
			e.FieldStart("correct_option_id")
			s.CorrectOptionID.Encode(e)
		}
	}
	{
		if s.Explanation.Set {
			e.FieldStart("explanation")
			s.Explanation.Encode(e)
		}
	}
	{
		if s.ExplanationEntities != nil {
			e.FieldStart("explanation_entities")
			e.ArrStart()
			for _, elem := range s.ExplanationEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.OpenPeriod.Set {
			e.FieldStart("open_period")
			s.OpenPeriod.Encode(e)
		}
	}
	{
		if s.CloseDate.Set {
			e.FieldStart("close_date")
			s.CloseDate.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoll = [14]string{
	0:  "id",
	1:  "question",
	2:  "question_entities",
	3:  "options",
	4:  "total_voter_count",
	5:  "is_closed",
	6:  "is_anonymous",
	7:  "type",
	8:  "allows_multiple_answers",
	9:  "correct_option_id",
	10: "explanation",
	11: "explanation_entities",
	12: "open_period",
	13: "close_date",
}

// Decode decodes Poll from json.
func (s *Poll) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Poll to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "question":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Question = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"question\"")
			}
		case "question_entities":
			if err := func() error {
				s.QuestionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.QuestionEntities = append(s.QuestionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"question_entities\"")
			}
		case "options":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Options = make([]PollOption, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PollOption
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Options = append(s.Options, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		case "total_voter_count":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TotalVoterCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_voter_count\"")
			}
		case "is_closed":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsClosed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_closed\"")
			}
		case "is_anonymous":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsAnonymous = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_anonymous\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "allows_multiple_answers":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.AllowsMultipleAnswers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allows_multiple_answers\"")
			}
		case "correct_option_id":
			if err := func() error {
				s.CorrectOptionID.Reset()
				if err := s.CorrectOptionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correct_option_id\"")
			}
		case "explanation":
			if err := func() error {
				s.Explanation.Reset()
				if err := s.Explanation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explanation\"")
			}
		case "explanation_entities":
			if err := func() error {
				s.ExplanationEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExplanationEntities = append(s.ExplanationEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explanation_entities\"")
			}
		case "open_period":
			if err := func() error {
				s.OpenPeriod.Reset()
				if err := s.OpenPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_period\"")
			}
		case "close_date":
			if err := func() error {
				s.CloseDate.Reset()
				if err := s.CloseDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"close_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Poll")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPoll) {
					name = jsonFieldsNameOfPoll[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Poll) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Poll) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PollAnswer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PollAnswer) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("poll_id")
		e.Str(s.PollID)
	}
	{
		if s.VoterChat.Set {
			e.FieldStart("voter_chat")
			s.VoterChat.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		e.FieldStart("option_ids")
		e.ArrStart()
		for _, elem := range s.OptionIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPollAnswer = [4]string{
	0: "poll_id",
	1: "voter_chat",
	2: "user",
	3: "option_ids",
}

// Decode decodes PollAnswer from json.
func (s *PollAnswer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PollAnswer to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "poll_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PollID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"poll_id\"")
			}
		case "voter_chat":
			if err := func() error {
				s.VoterChat.Reset()
				if err := s.VoterChat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voter_chat\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "option_ids":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.OptionIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.OptionIds = append(s.OptionIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"option_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PollAnswer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPollAnswer) {
					name = jsonFieldsNameOfPollAnswer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PollAnswer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PollAnswer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PollOption) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PollOption) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.TextEntities != nil {
			e.FieldStart("text_entities")
			e.ArrStart()
			for _, elem := range s.TextEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("voter_count")
		e.Int(s.VoterCount)
	}
}

var jsonFieldsNameOfPollOption = [3]string{
	0: "text",
	1: "text_entities",
	2: "voter_count",
}

// Decode decodes PollOption from json.
func (s *PollOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PollOption to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "text_entities":
			if err := func() error {
				s.TextEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TextEntities = append(s.TextEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_entities\"")
			}
		case "voter_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.VoterCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voter_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PollOption")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPollOption) {
					name = jsonFieldsNameOfPollOption[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PollOption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PollOption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PollType as json.
func (s PollType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PollType from json.
func (s *PollType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PollType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PollType(v) {
	case PollTypeRegular:
		*s = PollTypeRegular
	case PollTypeQuiz:
		*s = PollTypeQuiz
	default:
		*s = PollType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PollType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PollType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PreCheckoutQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PreCheckoutQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("from")
		s.From.Encode(e)
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("total_amount")
		e.Int(s.TotalAmount)
	}
	{
		e.FieldStart("invoice_payload")
		e.Str(s.InvoicePayload)
	}
	{
		if s.ShippingOptionID.Set {
			e.FieldStart("shipping_option_id")
			s.ShippingOptionID.Encode(e)
		}
	}
	{
		if s.OrderInfo.Set {
			e.FieldStart("order_info")
			s.OrderInfo.Encode(e)
		}
	}
}

var jsonFieldsNameOfPreCheckoutQuery = [7]string{
	0: "id",
	1: "from",
	2: "currency",
	3: "total_amount",
	4: "invoice_payload",
	5: "shipping_option_id",
	6: "order_info",
}

// Decode decodes PreCheckoutQuery from json.
func (s *PreCheckoutQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PreCheckoutQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "currency":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "total_amount":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TotalAmount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_amount\"")
			}
		case "invoice_payload":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.InvoicePayload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoice_payload\"")
			}
		case "shipping_option_id":
			if err := func() error {
				s.ShippingOptionID.Reset()
				if err := s.ShippingOptionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shipping_option_id\"")
			}
		case "order_info":
			if err := func() error {
				s.OrderInfo.Reset()
				if err := s.OrderInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order_info\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PreCheckoutQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPreCheckoutQuery) {
					name = jsonFieldsNameOfPreCheckoutQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PreCheckoutQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PreCheckoutQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromoteChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromoteChatMember) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		if s.IsAnonymous.Set {
			e.FieldStart("is_anonymous")
			s.IsAnonymous.Encode(e)
		}
	}
	{
		if s.CanManageChat.Set {
			e.FieldStart("can_manage_chat")
			s.CanManageChat.Encode(e)
		}
	}
	{
		if s.CanDeleteMessages.Set {
			e.FieldStart("can_delete_messages")
			s.CanDeleteMessages.Encode(e)
		}
	}
	{
		if s.CanManageVideoChats.Set {
			e.FieldStart("can_manage_video_chats")
			s.CanManageVideoChats.Encode(e)
		}
	}
	{
		if s.CanRestrictMembers.Set {
			e.FieldStart("can_restrict_members")
			s.CanRestrictMembers.Encode(e)
		}
	}
	{
		if s.CanPromoteMembers.Set {
			e.FieldStart("can_promote_members")
			s.CanPromoteMembers.Encode(e)
		}
	}
	{
		if s.CanChangeInfo.Set {
			e.FieldStart("can_change_info")
			s.CanChangeInfo.Encode(e)
		}
	}
	{
		if s.CanInviteUsers.Set {
			e.FieldStart("can_invite_users")
			s.CanInviteUsers.Encode(e)
		}
	}
	{
		if s.CanPostStories.Set {
			e.FieldStart("can_post_stories")
			s.CanPostStories.Encode(e)
		}
	}
	{
		if s.CanEditStories.Set {
			e.FieldStart("can_edit_stories")
			s.CanEditStories.Encode(e)
		}
	}
	{
		if s.CanDeleteStories.Set {
			e.FieldStart("can_delete_stories")
			s.CanDeleteStories.Encode(e)
		}
	}
	{
		if s.CanPostMessages.Set {
			e.FieldStart("can_post_messages")
			s.CanPostMessages.Encode(e)
		}
	}
	{
		if s.CanEditMessages.Set {
			e.FieldStart("can_edit_messages")
			s.CanEditMessages.Encode(e)
		}
	}
	{
		if s.CanPinMessages.Set {
			e.FieldStart("can_pin_messages")
			s.CanPinMessages.Encode(e)
		}
	}
	{
		if s.CanManageTopics.Set {
			e.FieldStart("can_manage_topics")
			s.CanManageTopics.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromoteChatMember = [17]string{
	0:  "chat_id",
	1:  "user_id",
	2:  "is_anonymous",
	3:  "can_manage_chat",
	4:  "can_delete_messages",
	5:  "can_manage_video_chats",
	6:  "can_restrict_members",
	7:  "can_promote_members",
	8:  "can_change_info",
	9:  "can_invite_users",
	10: "can_post_stories",
	11: "can_edit_stories",
	12: "can_delete_stories",
	13: "can_post_messages",
	14: "can_edit_messages",
	15: "can_pin_messages",
	16: "can_manage_topics",
}

// Decode decodes PromoteChatMember from json.
func (s *PromoteChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromoteChatMember to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "is_anonymous":
			if err := func() error {
				s.IsAnonymous.Reset()
				if err := s.IsAnonymous.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_anonymous\"")
			}
		case "can_manage_chat":
			if err := func() error {
				s.CanManageChat.Reset()
				if err := s.CanManageChat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_manage_chat\"")
			}
		case "can_delete_messages":
			if err := func() error {
				s.CanDeleteMessages.Reset()
				if err := s.CanDeleteMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_delete_messages\"")
			}
		case "can_manage_video_chats":
			if err := func() error {
				s.CanManageVideoChats.Reset()
				if err := s.CanManageVideoChats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_manage_video_chats\"")
			}
		case "can_restrict_members":
			if err := func() error {
				s.CanRestrictMembers.Reset()
				if err := s.CanRestrictMembers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_restrict_members\"")
			}
		case "can_promote_members":
			if err := func() error {
				s.CanPromoteMembers.Reset()
				if err := s.CanPromoteMembers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_promote_members\"")
			}
		case "can_change_info":
			if err := func() error {
				s.CanChangeInfo.Reset()
				if err := s.CanChangeInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_change_info\"")
			}
		case "can_invite_users":
			if err := func() error {
				s.CanInviteUsers.Reset()
				if err := s.CanInviteUsers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_invite_users\"")
			}
		case "can_post_stories":
			if err := func() error {
				s.CanPostStories.Reset()
				if err := s.CanPostStories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_post_stories\"")
			}
		case "can_edit_stories":
			if err := func() error {
				s.CanEditStories.Reset()
				if err := s.CanEditStories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_edit_stories\"")
			}
		case "can_delete_stories":
			if err := func() error {
				s.CanDeleteStories.Reset()
				if err := s.CanDeleteStories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_delete_stories\"")
			}
		case "can_post_messages":
			if err := func() error {
				s.CanPostMessages.Reset()
				if err := s.CanPostMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_post_messages\"")
			}
		case "can_edit_messages":
			if err := func() error {
				s.CanEditMessages.Reset()
				if err := s.CanEditMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_edit_messages\"")
			}
		case "can_pin_messages":
			if err := func() error {
				s.CanPinMessages.Reset()
				if err := s.CanPinMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_pin_messages\"")
			}
		case "can_manage_topics":
			if err := func() error {
				s.CanManageTopics.Reset()
				if err := s.CanManageTopics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_manage_topics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromoteChatMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000011,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromoteChatMember) {
					name = jsonFieldsNameOfPromoteChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromoteChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromoteChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProximityAlertTriggered) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProximityAlertTriggered) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("traveler")
		s.Traveler.Encode(e)
	}
	{
		e.FieldStart("watcher")
		s.Watcher.Encode(e)
	}
	{
		e.FieldStart("distance")
		e.Int(s.Distance)
	}
}

var jsonFieldsNameOfProximityAlertTriggered = [3]string{
	0: "traveler",
	1: "watcher",
	2: "distance",
}

// Decode decodes ProximityAlertTriggered from json.
func (s *ProximityAlertTriggered) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProximityAlertTriggered to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "traveler":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Traveler.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"traveler\"")
			}
		case "watcher":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Watcher.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watcher\"")
			}
		case "distance":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Distance = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"distance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProximityAlertTriggered")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProximityAlertTriggered) {
					name = jsonFieldsNameOfProximityAlertTriggered[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProximityAlertTriggered) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProximityAlertTriggered) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReactionCount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReactionCount) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
}

var jsonFieldsNameOfReactionCount = [2]string{
	0: "type",
	1: "total_count",
}

// Decode decodes ReactionCount from json.
func (s *ReactionCount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionCount to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "total_count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionCount")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionCount) {
					name = jsonFieldsNameOfReactionCount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionCount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionCount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionType as json.
func (s ReactionType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ReactionType) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case ReactionTypeCustomEmojiReactionType:
		e.FieldStart("type")
		e.Str("ReactionTypeCustomEmoji")
		{
			s := s.ReactionTypeCustomEmoji
			{
				e.FieldStart("custom_emoji_id")
				e.Str(s.CustomEmojiID)
			}
		}
	case ReactionTypeEmojiReactionType:
		e.FieldStart("type")
		e.Str("ReactionTypeEmoji")
		{
			s := s.ReactionTypeEmoji
			{
				e.FieldStart("emoji")
				e.Str(s.Emoji)
			}
		}
	case ReactionTypePaidReactionType:
		e.FieldStart("type")
		e.Str("ReactionTypePaid")
	}
}

// Decode decodes ReactionType from json.
func (s *ReactionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionType to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "ReactionTypeCustomEmoji":
					s.Type = ReactionTypeCustomEmojiReactionType
					found = true
				case "ReactionTypeEmoji":
					s.Type = ReactionTypeEmojiReactionType
					found = true
				case "ReactionTypePaid":
					s.Type = ReactionTypePaidReactionType
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ReactionTypeEmojiReactionType:
		if err := s.ReactionTypeEmoji.Decode(d); err != nil {
			return err
		}
	case ReactionTypeCustomEmojiReactionType:
		if err := s.ReactionTypeCustomEmoji.Decode(d); err != nil {
			return err
		}
	case ReactionTypePaidReactionType:
		if err := s.ReactionTypePaid.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReactionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReactionTypeCustomEmoji) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReactionTypeCustomEmoji) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("custom_emoji_id")
		e.Str(s.CustomEmojiID)
	}
}

var jsonFieldsNameOfReactionTypeCustomEmoji = [2]string{
	0: "type",
	1: "custom_emoji_id",
}

// Decode decodes ReactionTypeCustomEmoji from json.
func (s *ReactionTypeCustomEmoji) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionTypeCustomEmoji to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "custom_emoji_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CustomEmojiID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_emoji_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionTypeCustomEmoji")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionTypeCustomEmoji) {
					name = jsonFieldsNameOfReactionTypeCustomEmoji[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionTypeCustomEmoji) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionTypeCustomEmoji) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReactionTypeEmoji) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReactionTypeEmoji) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("emoji")
		e.Str(s.Emoji)
	}
}

var jsonFieldsNameOfReactionTypeEmoji = [2]string{
	0: "type",
	1: "emoji",
}

// Decode decodes ReactionTypeEmoji from json.
func (s *ReactionTypeEmoji) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionTypeEmoji to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "emoji":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Emoji = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emoji\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionTypeEmoji")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionTypeEmoji) {
					name = jsonFieldsNameOfReactionTypeEmoji[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionTypeEmoji) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionTypeEmoji) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReactionTypePaid) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReactionTypePaid) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfReactionTypePaid = [1]string{
	0: "type",
}

// Decode decodes ReactionTypePaid from json.
func (s *ReactionTypePaid) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionTypePaid to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionTypePaid")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionTypePaid) {
					name = jsonFieldsNameOfReactionTypePaid[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionTypePaid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionTypePaid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RefundStarPayment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RefundStarPayment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("telegram_payment_charge_id")
		e.Str(s.TelegramPaymentChargeID)
	}
}

var jsonFieldsNameOfRefundStarPayment = [2]string{
	0: "user_id",
	1: "telegram_payment_charge_id",
}

// Decode decodes RefundStarPayment from json.
func (s *RefundStarPayment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RefundStarPayment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "telegram_payment_charge_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TelegramPaymentChargeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegram_payment_charge_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RefundStarPayment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRefundStarPayment) {
					name = jsonFieldsNameOfRefundStarPayment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RefundStarPayment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RefundStarPayment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RefundedPayment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RefundedPayment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("total_amount")
		e.Int(s.TotalAmount)
	}
	{
		e.FieldStart("invoice_payload")
		e.Str(s.InvoicePayload)
	}
	{
		e.FieldStart("telegram_payment_charge_id")
		e.Str(s.TelegramPaymentChargeID)
	}
	{
		if s.ProviderPaymentChargeID.Set {
			e.FieldStart("provider_payment_charge_id")
			s.ProviderPaymentChargeID.Encode(e)
		}
	}
}

var jsonFieldsNameOfRefundedPayment = [5]string{
	0: "currency",
	1: "total_amount",
	2: "invoice_payload",
	3: "telegram_payment_charge_id",
	4: "provider_payment_charge_id",
}

// Decode decodes RefundedPayment from json.
func (s *RefundedPayment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RefundedPayment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "total_amount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalAmount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_amount\"")
			}
		case "invoice_payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.InvoicePayload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoice_payload\"")
			}
		case "telegram_payment_charge_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TelegramPaymentChargeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegram_payment_charge_id\"")
			}
		case "provider_payment_charge_id":
			if err := func() error {
				s.ProviderPaymentChargeID.Reset()
				if err := s.ProviderPaymentChargeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_payment_charge_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RefundedPayment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRefundedPayment) {
					name = jsonFieldsNameOfRefundedPayment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RefundedPayment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RefundedPayment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveChatVerification) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveChatVerification) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfRemoveChatVerification = [1]string{
	0: "chat_id",
}

// Decode decodes RemoveChatVerification from json.
func (s *RemoveChatVerification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveChatVerification to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveChatVerification")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveChatVerification) {
					name = jsonFieldsNameOfRemoveChatVerification[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveChatVerification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveChatVerification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveUserVerification) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveUserVerification) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
}

var jsonFieldsNameOfRemoveUserVerification = [1]string{
	0: "user_id",
}

// Decode decodes RemoveUserVerification from json.
func (s *RemoveUserVerification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveUserVerification to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveUserVerification")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveUserVerification) {
					name = jsonFieldsNameOfRemoveUserVerification[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveUserVerification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveUserVerification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReopenForumTopic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReopenForumTopic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("message_thread_id")
		e.Int(s.MessageThreadID)
	}
}

var jsonFieldsNameOfReopenForumTopic = [2]string{
	0: "chat_id",
	1: "message_thread_id",
}

// Decode decodes ReopenForumTopic from json.
func (s *ReopenForumTopic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReopenForumTopic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MessageThreadID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReopenForumTopic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReopenForumTopic) {
					name = jsonFieldsNameOfReopenForumTopic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReopenForumTopic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReopenForumTopic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReopenGeneralForumTopic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReopenGeneralForumTopic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfReopenGeneralForumTopic = [1]string{
	0: "chat_id",
}

// Decode decodes ReopenGeneralForumTopic from json.
func (s *ReopenGeneralForumTopic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReopenGeneralForumTopic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReopenGeneralForumTopic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReopenGeneralForumTopic) {
					name = jsonFieldsNameOfReopenGeneralForumTopic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReopenGeneralForumTopic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReopenGeneralForumTopic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReplaceStickerInSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReplaceStickerInSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("old_sticker")
		e.Str(s.OldSticker)
	}
	{
		e.FieldStart("sticker")
		s.Sticker.Encode(e)
	}
}

var jsonFieldsNameOfReplaceStickerInSet = [4]string{
	0: "user_id",
	1: "name",
	2: "old_sticker",
	3: "sticker",
}

// Decode decodes ReplaceStickerInSet from json.
func (s *ReplaceStickerInSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReplaceStickerInSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "old_sticker":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.OldSticker = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_sticker\"")
			}
		case "sticker":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Sticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReplaceStickerInSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReplaceStickerInSet) {
					name = jsonFieldsNameOfReplaceStickerInSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReplaceStickerInSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReplaceStickerInSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReplyKeyboardMarkup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReplyKeyboardMarkup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("keyboard")
		e.ArrStart()
		for _, elem := range s.Keyboard {
			e.ArrStart()
			for _, elem := range elem {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
		e.ArrEnd()
	}
	{
		if s.IsPersistent.Set {
			e.FieldStart("is_persistent")
			s.IsPersistent.Encode(e)
		}
	}
	{
		if s.ResizeKeyboard.Set {
			e.FieldStart("resize_keyboard")
			s.ResizeKeyboard.Encode(e)
		}
	}
	{
		if s.OneTimeKeyboard.Set {
			e.FieldStart("one_time_keyboard")
			s.OneTimeKeyboard.Encode(e)
		}
	}
	{
		if s.InputFieldPlaceholder.Set {
			e.FieldStart("input_field_placeholder")
			s.InputFieldPlaceholder.Encode(e)
		}
	}
	{
		if s.Selective.Set {
			e.FieldStart("selective")
			s.Selective.Encode(e)
		}
	}
}

var jsonFieldsNameOfReplyKeyboardMarkup = [6]string{
	0: "keyboard",
	1: "is_persistent",
	2: "resize_keyboard",
	3: "one_time_keyboard",
	4: "input_field_placeholder",
	5: "selective",
}

// Decode decodes ReplyKeyboardMarkup from json.
func (s *ReplyKeyboardMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReplyKeyboardMarkup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "keyboard":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Keyboard = make([][]KeyboardButton, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem []KeyboardButton
					elem = make([]KeyboardButton, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elemElem KeyboardButton
						if err := elemElem.Decode(d); err != nil {
							return err
						}
						elem = append(elem, elemElem)
						return nil
					}); err != nil {
						return err
					}
					s.Keyboard = append(s.Keyboard, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyboard\"")
			}
		case "is_persistent":
			if err := func() error {
				s.IsPersistent.Reset()
				if err := s.IsPersistent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_persistent\"")
			}
		case "resize_keyboard":
			if err := func() error {
				s.ResizeKeyboard.Reset()
				if err := s.ResizeKeyboard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resize_keyboard\"")
			}
		case "one_time_keyboard":
			if err := func() error {
				s.OneTimeKeyboard.Reset()
				if err := s.OneTimeKeyboard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"one_time_keyboard\"")
			}
		case "input_field_placeholder":
			if err := func() error {
				s.InputFieldPlaceholder.Reset()
				if err := s.InputFieldPlaceholder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_field_placeholder\"")
			}
		case "selective":
			if err := func() error {
				s.Selective.Reset()
				if err := s.Selective.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selective\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReplyKeyboardMarkup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReplyKeyboardMarkup) {
					name = jsonFieldsNameOfReplyKeyboardMarkup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReplyKeyboardMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReplyKeyboardMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReplyKeyboardRemove) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReplyKeyboardRemove) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("remove_keyboard")
		e.Bool(s.RemoveKeyboard)
	}
	{
		if s.Selective.Set {
			e.FieldStart("selective")
			s.Selective.Encode(e)
		}
	}
}

var jsonFieldsNameOfReplyKeyboardRemove = [2]string{
	0: "remove_keyboard",
	1: "selective",
}

// Decode decodes ReplyKeyboardRemove from json.
func (s *ReplyKeyboardRemove) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReplyKeyboardRemove to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "remove_keyboard":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.RemoveKeyboard = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_keyboard\"")
			}
		case "selective":
			if err := func() error {
				s.Selective.Reset()
				if err := s.Selective.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selective\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReplyKeyboardRemove")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReplyKeyboardRemove) {
					name = jsonFieldsNameOfReplyKeyboardRemove[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReplyKeyboardRemove) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReplyKeyboardRemove) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReplyParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReplyParameters) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.FieldStart("allow_sending_without_reply")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.Quote.Set {
			e.FieldStart("quote")
			s.Quote.Encode(e)
		}
	}
	{
		if s.QuoteParseMode.Set {
			e.FieldStart("quote_parse_mode")
			s.QuoteParseMode.Encode(e)
		}
	}
	{
		if s.QuoteEntities != nil {
			e.FieldStart("quote_entities")
			e.ArrStart()
			for _, elem := range s.QuoteEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.QuotePosition.Set {
			e.FieldStart("quote_position")
			s.QuotePosition.Encode(e)
		}
	}
}

var jsonFieldsNameOfReplyParameters = [7]string{
	0: "message_id",
	1: "chat_id",
	2: "allow_sending_without_reply",
	3: "quote",
	4: "quote_parse_mode",
	5: "quote_entities",
	6: "quote_position",
}

// Decode decodes ReplyParameters from json.
func (s *ReplyParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReplyParameters to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "allow_sending_without_reply":
			if err := func() error {
				s.AllowSendingWithoutReply.Reset()
				if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_sending_without_reply\"")
			}
		case "quote":
			if err := func() error {
				s.Quote.Reset()
				if err := s.Quote.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quote\"")
			}
		case "quote_parse_mode":
			if err := func() error {
				s.QuoteParseMode.Reset()
				if err := s.QuoteParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quote_parse_mode\"")
			}
		case "quote_entities":
			if err := func() error {
				s.QuoteEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.QuoteEntities = append(s.QuoteEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quote_entities\"")
			}
		case "quote_position":
			if err := func() error {
				s.QuotePosition.Reset()
				if err := s.QuotePosition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quote_position\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReplyParameters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReplyParameters) {
					name = jsonFieldsNameOfReplyParameters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReplyParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReplyParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseParameters) encodeFields(e *jx.Encoder) {
	{
		if s.MigrateToChatID.Set {
			e.FieldStart("migrate_to_chat_id")
			s.MigrateToChatID.Encode(e)
		}
	}
	{
		if s.RetryAfter.Set {
			e.FieldStart("retry_after")
			s.RetryAfter.Encode(e)
		}
	}
}

var jsonFieldsNameOfResponseParameters = [2]string{
	0: "migrate_to_chat_id",
	1: "retry_after",
}

// Decode decodes ResponseParameters from json.
func (s *ResponseParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseParameters to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "migrate_to_chat_id":
			if err := func() error {
				s.MigrateToChatID.Reset()
				if err := s.MigrateToChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"migrate_to_chat_id\"")
			}
		case "retry_after":
			if err := func() error {
				s.RetryAfter.Reset()
				if err := s.RetryAfter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retry_after\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestrictChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestrictChatMember) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	{
		if s.UseIndependentChatPermissions.Set {
			e.FieldStart("use_independent_chat_permissions")
			s.UseIndependentChatPermissions.Encode(e)
		}
	}
	{
		if s.UntilDate.Set {
			e.FieldStart("until_date")
			s.UntilDate.Encode(e)
		}
	}
}

var jsonFieldsNameOfRestrictChatMember = [5]string{
	0: "chat_id",
	1: "user_id",
	2: "permissions",
	3: "use_independent_chat_permissions",
	4: "until_date",
}

// Decode decodes RestrictChatMember from json.
func (s *RestrictChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestrictChatMember to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "use_independent_chat_permissions":
			if err := func() error {
				s.UseIndependentChatPermissions.Reset()
				if err := s.UseIndependentChatPermissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_independent_chat_permissions\"")
			}
		case "until_date":
			if err := func() error {
				s.UntilDate.Reset()
				if err := s.UntilDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"until_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestrictChatMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestrictChatMember) {
					name = jsonFieldsNameOfRestrictChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestrictChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestrictChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Result) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Result) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResult = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes Result from json.
func (s *Result) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Result to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Result")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResult) {
					name = jsonFieldsNameOfResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Result) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Result) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultArrayOfBotCommand) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultArrayOfBotCommand) encodeFields(e *jx.Encoder) {
	{
		if s.Result != nil {
			e.FieldStart("result")
			e.ArrStart()
			for _, elem := range s.Result {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultArrayOfBotCommand = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfBotCommand from json.
func (s *ResultArrayOfBotCommand) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultArrayOfBotCommand to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result = make([]BotCommand, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BotCommand
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultArrayOfBotCommand")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfBotCommand) {
					name = jsonFieldsNameOfResultArrayOfBotCommand[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultArrayOfBotCommand) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultArrayOfBotCommand) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultArrayOfChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultArrayOfChatMember) encodeFields(e *jx.Encoder) {
	{
		if s.Result != nil {
			e.FieldStart("result")
			e.ArrStart()
			for _, elem := range s.Result {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultArrayOfChatMember = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfChatMember from json.
func (s *ResultArrayOfChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultArrayOfChatMember to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result = make([]ChatMember, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ChatMember
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultArrayOfChatMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfChatMember) {
					name = jsonFieldsNameOfResultArrayOfChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultArrayOfChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultArrayOfChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultArrayOfGameHighScore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultArrayOfGameHighScore) encodeFields(e *jx.Encoder) {
	{
		if s.Result != nil {
			e.FieldStart("result")
			e.ArrStart()
			for _, elem := range s.Result {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultArrayOfGameHighScore = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfGameHighScore from json.
func (s *ResultArrayOfGameHighScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultArrayOfGameHighScore to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result = make([]GameHighScore, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GameHighScore
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultArrayOfGameHighScore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfGameHighScore) {
					name = jsonFieldsNameOfResultArrayOfGameHighScore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultArrayOfGameHighScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultArrayOfGameHighScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultArrayOfMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultArrayOfMessage) encodeFields(e *jx.Encoder) {
	{
		if s.Result != nil {
			e.FieldStart("result")
			e.ArrStart()
			for _, elem := range s.Result {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultArrayOfMessage = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfMessage from json.
func (s *ResultArrayOfMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultArrayOfMessage to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result = make([]Message, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Message
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultArrayOfMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfMessage) {
					name = jsonFieldsNameOfResultArrayOfMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultArrayOfMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultArrayOfMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultArrayOfMessageId) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultArrayOfMessageId) encodeFields(e *jx.Encoder) {
	{
		if s.Result != nil {
			e.FieldStart("result")
			e.ArrStart()
			for _, elem := range s.Result {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultArrayOfMessageId = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfMessageId from json.
func (s *ResultArrayOfMessageId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultArrayOfMessageId to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result = make([]MessageId, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageId
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultArrayOfMessageId")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfMessageId) {
					name = jsonFieldsNameOfResultArrayOfMessageId[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultArrayOfMessageId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultArrayOfMessageId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultArrayOfSticker) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultArrayOfSticker) encodeFields(e *jx.Encoder) {
	{
		if s.Result != nil {
			e.FieldStart("result")
			e.ArrStart()
			for _, elem := range s.Result {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultArrayOfSticker = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfSticker from json.
func (s *ResultArrayOfSticker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultArrayOfSticker to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result = make([]Sticker, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Sticker
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultArrayOfSticker")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfSticker) {
					name = jsonFieldsNameOfResultArrayOfSticker[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultArrayOfSticker) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultArrayOfSticker) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultArrayOfUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultArrayOfUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Result != nil {
			e.FieldStart("result")
			e.ArrStart()
			for _, elem := range s.Result {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultArrayOfUpdate = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfUpdate from json.
func (s *ResultArrayOfUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultArrayOfUpdate to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result = make([]Update, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Update
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultArrayOfUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfUpdate) {
					name = jsonFieldsNameOfResultArrayOfUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultArrayOfUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultArrayOfUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultChatInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultChatInviteLink) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultChatInviteLink = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultChatInviteLink from json.
func (s *ResultChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultChatInviteLink to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultChatInviteLink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultChatInviteLink) {
					name = jsonFieldsNameOfResultChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultChatInviteLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultChatInviteLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultChatMember) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultChatMember = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultChatMember from json.
func (s *ResultChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultChatMember to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultChatMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultChatMember) {
					name = jsonFieldsNameOfResultChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultFile) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultFile = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultFile from json.
func (s *ResultFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultFile to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultFile) {
					name = jsonFieldsNameOfResultFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultInt) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultInt) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultInt = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultInt from json.
func (s *ResultInt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultInt to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultInt")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultInt) {
					name = jsonFieldsNameOfResultInt[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultMessage) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultMessage = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultMessage from json.
func (s *ResultMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultMessage to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultMessage) {
					name = jsonFieldsNameOfResultMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultMessageId) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultMessageId) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultMessageId = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultMessageId from json.
func (s *ResultMessageId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultMessageId to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultMessageId")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultMessageId) {
					name = jsonFieldsNameOfResultMessageId[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultMessageId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultMessageId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultMessageOrBoolean) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultMessageOrBoolean) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultMessageOrBoolean = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultMessageOrBoolean from json.
func (s *ResultMessageOrBoolean) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultMessageOrBoolean to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultMessageOrBoolean")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultMessageOrBoolean) {
					name = jsonFieldsNameOfResultMessageOrBoolean[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultMessageOrBoolean) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultMessageOrBoolean) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResultMessageOrBooleanResult as json.
func (s ResultMessageOrBooleanResult) Encode(e *jx.Encoder) {
	switch s.Type {
	case MessageResultMessageOrBooleanResult:
		s.Message.Encode(e)
	case BoolResultMessageOrBooleanResult:
		e.Bool(s.Bool)
	}
}

// Decode decodes ResultMessageOrBooleanResult from json.
func (s *ResultMessageOrBooleanResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultMessageOrBooleanResult to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolResultMessageOrBooleanResult
	case jx.Object:
		if err := s.Message.Decode(d); err != nil {
			return err
		}
		s.Type = MessageResultMessageOrBooleanResult
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResultMessageOrBooleanResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultMessageOrBooleanResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultPoll) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultPoll) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultPoll = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultPoll from json.
func (s *ResultPoll) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultPoll to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultPoll")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultPoll) {
					name = jsonFieldsNameOfResultPoll[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultPoll) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultPoll) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultStickerSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultStickerSet) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultStickerSet = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultStickerSet from json.
func (s *ResultStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultStickerSet to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultStickerSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultStickerSet) {
					name = jsonFieldsNameOfResultStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultStickerSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultStickerSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultString) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultString) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultString = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultString from json.
func (s *ResultString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultString to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultString")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultString) {
					name = jsonFieldsNameOfResultString[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultUser) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultUser = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultUser from json.
func (s *ResultUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultUser to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultUser) {
					name = jsonFieldsNameOfResultUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultUserProfilePhotos) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultUserProfilePhotos) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultUserProfilePhotos = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultUserProfilePhotos from json.
func (s *ResultUserProfilePhotos) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultUserProfilePhotos to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultUserProfilePhotos")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultUserProfilePhotos) {
					name = jsonFieldsNameOfResultUserProfilePhotos[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultUserProfilePhotos) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultUserProfilePhotos) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultWebhookInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultWebhookInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("ok")
		e.Bool(s.Ok)
	}
}

var jsonFieldsNameOfResultWebhookInfo = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultWebhookInfo from json.
func (s *ResultWebhookInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultWebhookInfo to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ok = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultWebhookInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultWebhookInfo) {
					name = jsonFieldsNameOfResultWebhookInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultWebhookInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultWebhookInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeChatInviteLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeChatInviteLink) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("invite_link")
		e.Str(s.InviteLink)
	}
}

var jsonFieldsNameOfRevokeChatInviteLink = [2]string{
	0: "chat_id",
	1: "invite_link",
}

// Decode decodes RevokeChatInviteLink from json.
func (s *RevokeChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeChatInviteLink to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "invite_link":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InviteLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invite_link\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeChatInviteLink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeChatInviteLink) {
					name = jsonFieldsNameOfRevokeChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeChatInviteLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeChatInviteLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SavePreparedInlineMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SavePreparedInlineMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("result")
		s.Result.Encode(e)
	}
	{
		if s.AllowUserChats.Set {
			e.FieldStart("allow_user_chats")
			s.AllowUserChats.Encode(e)
		}
	}
	{
		if s.AllowBotChats.Set {
			e.FieldStart("allow_bot_chats")
			s.AllowBotChats.Encode(e)
		}
	}
	{
		if s.AllowGroupChats.Set {
			e.FieldStart("allow_group_chats")
			s.AllowGroupChats.Encode(e)
		}
	}
	{
		if s.AllowChannelChats.Set {
			e.FieldStart("allow_channel_chats")
			s.AllowChannelChats.Encode(e)
		}
	}
}

var jsonFieldsNameOfSavePreparedInlineMessage = [6]string{
	0: "user_id",
	1: "result",
	2: "allow_user_chats",
	3: "allow_bot_chats",
	4: "allow_group_chats",
	5: "allow_channel_chats",
}

// Decode decodes SavePreparedInlineMessage from json.
func (s *SavePreparedInlineMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SavePreparedInlineMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "result":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "allow_user_chats":
			if err := func() error {
				s.AllowUserChats.Reset()
				if err := s.AllowUserChats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_user_chats\"")
			}
		case "allow_bot_chats":
			if err := func() error {
				s.AllowBotChats.Reset()
				if err := s.AllowBotChats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_bot_chats\"")
			}
		case "allow_group_chats":
			if err := func() error {
				s.AllowGroupChats.Reset()
				if err := s.AllowGroupChats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_group_chats\"")
			}
		case "allow_channel_chats":
			if err := func() error {
				s.AllowChannelChats.Reset()
				if err := s.AllowChannelChats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_channel_chats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SavePreparedInlineMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSavePreparedInlineMessage) {
					name = jsonFieldsNameOfSavePreparedInlineMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SavePreparedInlineMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SavePreparedInlineMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendAnimation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendAnimation) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("animation")
		e.Str(s.Animation)
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Width.Set {
			e.FieldStart("width")
			s.Width.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.HasSpoiler.Set {
			e.FieldStart("has_spoiler")
			s.HasSpoiler.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendAnimation = [19]string{
	0:  "business_connection_id",
	1:  "chat_id",
	2:  "message_thread_id",
	3:  "animation",
	4:  "duration",
	5:  "width",
	6:  "height",
	7:  "thumbnail",
	8:  "caption",
	9:  "parse_mode",
	10: "caption_entities",
	11: "show_caption_above_media",
	12: "has_spoiler",
	13: "disable_notification",
	14: "protect_content",
	15: "allow_paid_broadcast",
	16: "message_effect_id",
	17: "reply_parameters",
	18: "reply_markup",
}

// Decode decodes SendAnimation from json.
func (s *SendAnimation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendAnimation to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "animation":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Animation = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"animation\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "width":
			if err := func() error {
				s.Width.Reset()
				if err := s.Width.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "has_spoiler":
			if err := func() error {
				s.HasSpoiler.Reset()
				if err := s.HasSpoiler.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_spoiler\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendAnimation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00001010,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendAnimation) {
					name = jsonFieldsNameOfSendAnimation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendAnimation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendAnimation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendAudio) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendAudio) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("audio")
		e.Str(s.Audio)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Performer.Set {
			e.FieldStart("performer")
			s.Performer.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendAudio = [17]string{
	0:  "business_connection_id",
	1:  "chat_id",
	2:  "message_thread_id",
	3:  "audio",
	4:  "caption",
	5:  "parse_mode",
	6:  "caption_entities",
	7:  "duration",
	8:  "performer",
	9:  "title",
	10: "thumbnail",
	11: "disable_notification",
	12: "protect_content",
	13: "allow_paid_broadcast",
	14: "message_effect_id",
	15: "reply_parameters",
	16: "reply_markup",
}

// Decode decodes SendAudio from json.
func (s *SendAudio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendAudio to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "audio":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Audio = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "performer":
			if err := func() error {
				s.Performer.Reset()
				if err := s.Performer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performer\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendAudio")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00001010,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendAudio) {
					name = jsonFieldsNameOfSendAudio[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendAudio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendAudio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendChatAction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendChatAction) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("action")
		e.Str(s.Action)
	}
}

var jsonFieldsNameOfSendChatAction = [4]string{
	0: "business_connection_id",
	1: "chat_id",
	2: "message_thread_id",
	3: "action",
}

// Decode decodes SendChatAction from json.
func (s *SendChatAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendChatAction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "action":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Action = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendChatAction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendChatAction) {
					name = jsonFieldsNameOfSendChatAction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendChatAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendChatAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendContact) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendContact) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("first_name")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.FieldStart("last_name")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Vcard.Set {
			e.FieldStart("vcard")
			s.Vcard.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendContact = [13]string{
	0:  "business_connection_id",
	1:  "chat_id",
	2:  "message_thread_id",
	3:  "phone_number",
	4:  "first_name",
	5:  "last_name",
	6:  "vcard",
	7:  "disable_notification",
	8:  "protect_content",
	9:  "allow_paid_broadcast",
	10: "message_effect_id",
	11: "reply_parameters",
	12: "reply_markup",
}

// Decode decodes SendContact from json.
func (s *SendContact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendContact to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "phone_number":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.FirstName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_name\"")
			}
		case "vcard":
			if err := func() error {
				s.Vcard.Reset()
				if err := s.Vcard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcard\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendContact")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendContact) {
					name = jsonFieldsNameOfSendContact[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendContact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendContact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendDice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendDice) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		if s.Emoji.Set {
			e.FieldStart("emoji")
			s.Emoji.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendDice = [10]string{
	0: "business_connection_id",
	1: "chat_id",
	2: "message_thread_id",
	3: "emoji",
	4: "disable_notification",
	5: "protect_content",
	6: "allow_paid_broadcast",
	7: "message_effect_id",
	8: "reply_parameters",
	9: "reply_markup",
}

// Decode decodes SendDice from json.
func (s *SendDice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendDice to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "emoji":
			if err := func() error {
				s.Emoji.Reset()
				if err := s.Emoji.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emoji\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendDice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendDice) {
					name = jsonFieldsNameOfSendDice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendDice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendDice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendDocument) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendDocument) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("document")
		e.Str(s.Document)
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableContentTypeDetection.Set {
			e.FieldStart("disable_content_type_detection")
			s.DisableContentTypeDetection.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendDocument = [15]string{
	0:  "business_connection_id",
	1:  "chat_id",
	2:  "message_thread_id",
	3:  "document",
	4:  "thumbnail",
	5:  "caption",
	6:  "parse_mode",
	7:  "caption_entities",
	8:  "disable_content_type_detection",
	9:  "disable_notification",
	10: "protect_content",
	11: "allow_paid_broadcast",
	12: "message_effect_id",
	13: "reply_parameters",
	14: "reply_markup",
}

// Decode decodes SendDocument from json.
func (s *SendDocument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendDocument to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "document":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Document = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "disable_content_type_detection":
			if err := func() error {
				s.DisableContentTypeDetection.Reset()
				if err := s.DisableContentTypeDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_content_type_detection\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendDocument")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendDocument) {
					name = jsonFieldsNameOfSendDocument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendDocument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendDocument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendGame) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendGame) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		e.Int64(s.ChatID)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("game_short_name")
		e.Str(s.GameShortName)
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendGame = [10]string{
	0: "business_connection_id",
	1: "chat_id",
	2: "message_thread_id",
	3: "game_short_name",
	4: "disable_notification",
	5: "protect_content",
	6: "allow_paid_broadcast",
	7: "message_effect_id",
	8: "reply_parameters",
	9: "reply_markup",
}

// Decode decodes SendGame from json.
func (s *SendGame) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendGame to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.ChatID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "game_short_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GameShortName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_short_name\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendGame")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendGame) {
					name = jsonFieldsNameOfSendGame[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendGame) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendGame) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendGift) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendGift) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("gift_id")
		e.Str(s.GiftID)
	}
	{
		if s.PayForUpgrade.Set {
			e.FieldStart("pay_for_upgrade")
			s.PayForUpgrade.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.TextParseMode.Set {
			e.FieldStart("text_parse_mode")
			s.TextParseMode.Encode(e)
		}
	}
	{
		if s.TextEntities != nil {
			e.FieldStart("text_entities")
			e.ArrStart()
			for _, elem := range s.TextEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSendGift = [6]string{
	0: "user_id",
	1: "gift_id",
	2: "pay_for_upgrade",
	3: "text",
	4: "text_parse_mode",
	5: "text_entities",
}

// Decode decodes SendGift from json.
func (s *SendGift) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendGift to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "gift_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GiftID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gift_id\"")
			}
		case "pay_for_upgrade":
			if err := func() error {
				s.PayForUpgrade.Reset()
				if err := s.PayForUpgrade.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pay_for_upgrade\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "text_parse_mode":
			if err := func() error {
				s.TextParseMode.Reset()
				if err := s.TextParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_parse_mode\"")
			}
		case "text_entities":
			if err := func() error {
				s.TextEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TextEntities = append(s.TextEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_entities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendGift")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendGift) {
					name = jsonFieldsNameOfSendGift[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendGift) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendGift) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendInvoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendInvoice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("payload")
		e.Str(s.Payload)
	}
	{
		if s.ProviderToken.Set {
			e.FieldStart("provider_token")
			s.ProviderToken.Encode(e)
		}
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("prices")
		e.ArrStart()
		for _, elem := range s.Prices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.MaxTipAmount.Set {
			e.FieldStart("max_tip_amount")
			s.MaxTipAmount.Encode(e)
		}
	}
	{
		if s.SuggestedTipAmounts != nil {
			e.FieldStart("suggested_tip_amounts")
			e.ArrStart()
			for _, elem := range s.SuggestedTipAmounts {
				e.Int64(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.StartParameter.Set {
			e.FieldStart("start_parameter")
			s.StartParameter.Encode(e)
		}
	}
	{
		if s.ProviderData.Set {
			e.FieldStart("provider_data")
			s.ProviderData.Encode(e)
		}
	}
	{
		if s.PhotoURL.Set {
			e.FieldStart("photo_url")
			s.PhotoURL.Encode(e)
		}
	}
	{
		if s.PhotoSize.Set {
			e.FieldStart("photo_size")
			s.PhotoSize.Encode(e)
		}
	}
	{
		if s.PhotoWidth.Set {
			e.FieldStart("photo_width")
			s.PhotoWidth.Encode(e)
		}
	}
	{
		if s.PhotoHeight.Set {
			e.FieldStart("photo_height")
			s.PhotoHeight.Encode(e)
		}
	}
	{
		if s.NeedName.Set {
			e.FieldStart("need_name")
			s.NeedName.Encode(e)
		}
	}
	{
		if s.NeedPhoneNumber.Set {
			e.FieldStart("need_phone_number")
			s.NeedPhoneNumber.Encode(e)
		}
	}
	{
		if s.NeedEmail.Set {
			e.FieldStart("need_email")
			s.NeedEmail.Encode(e)
		}
	}
	{
		if s.NeedShippingAddress.Set {
			e.FieldStart("need_shipping_address")
			s.NeedShippingAddress.Encode(e)
		}
	}
	{
		if s.SendPhoneNumberToProvider.Set {
			e.FieldStart("send_phone_number_to_provider")
			s.SendPhoneNumberToProvider.Encode(e)
		}
	}
	{
		if s.SendEmailToProvider.Set {
			e.FieldStart("send_email_to_provider")
			s.SendEmailToProvider.Encode(e)
		}
	}
	{
		if s.IsFlexible.Set {
			e.FieldStart("is_flexible")
			s.IsFlexible.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendInvoice = [29]string{
	0:  "chat_id",
	1:  "message_thread_id",
	2:  "title",
	3:  "description",
	4:  "payload",
	5:  "provider_token",
	6:  "currency",
	7:  "prices",
	8:  "max_tip_amount",
	9:  "suggested_tip_amounts",
	10: "start_parameter",
	11: "provider_data",
	12: "photo_url",
	13: "photo_size",
	14: "photo_width",
	15: "photo_height",
	16: "need_name",
	17: "need_phone_number",
	18: "need_email",
	19: "need_shipping_address",
	20: "send_phone_number_to_provider",
	21: "send_email_to_provider",
	22: "is_flexible",
	23: "disable_notification",
	24: "protect_content",
	25: "allow_paid_broadcast",
	26: "message_effect_id",
	27: "reply_parameters",
	28: "reply_markup",
}

// Decode decodes SendInvoice from json.
func (s *SendInvoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendInvoice to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Payload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "provider_token":
			if err := func() error {
				s.ProviderToken.Reset()
				if err := s.ProviderToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_token\"")
			}
		case "currency":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "prices":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.Prices = make([]LabeledPrice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LabeledPrice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Prices = append(s.Prices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prices\"")
			}
		case "max_tip_amount":
			if err := func() error {
				s.MaxTipAmount.Reset()
				if err := s.MaxTipAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_tip_amount\"")
			}
		case "suggested_tip_amounts":
			if err := func() error {
				s.SuggestedTipAmounts = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int64
					v, err := d.Int64()
					elem = int64(v)
					if err != nil {
						return err
					}
					s.SuggestedTipAmounts = append(s.SuggestedTipAmounts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suggested_tip_amounts\"")
			}
		case "start_parameter":
			if err := func() error {
				s.StartParameter.Reset()
				if err := s.StartParameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_parameter\"")
			}
		case "provider_data":
			if err := func() error {
				s.ProviderData.Reset()
				if err := s.ProviderData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_data\"")
			}
		case "photo_url":
			if err := func() error {
				s.PhotoURL.Reset()
				if err := s.PhotoURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_url\"")
			}
		case "photo_size":
			if err := func() error {
				s.PhotoSize.Reset()
				if err := s.PhotoSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_size\"")
			}
		case "photo_width":
			if err := func() error {
				s.PhotoWidth.Reset()
				if err := s.PhotoWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_width\"")
			}
		case "photo_height":
			if err := func() error {
				s.PhotoHeight.Reset()
				if err := s.PhotoHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_height\"")
			}
		case "need_name":
			if err := func() error {
				s.NeedName.Reset()
				if err := s.NeedName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_name\"")
			}
		case "need_phone_number":
			if err := func() error {
				s.NeedPhoneNumber.Reset()
				if err := s.NeedPhoneNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_phone_number\"")
			}
		case "need_email":
			if err := func() error {
				s.NeedEmail.Reset()
				if err := s.NeedEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_email\"")
			}
		case "need_shipping_address":
			if err := func() error {
				s.NeedShippingAddress.Reset()
				if err := s.NeedShippingAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"need_shipping_address\"")
			}
		case "send_phone_number_to_provider":
			if err := func() error {
				s.SendPhoneNumberToProvider.Reset()
				if err := s.SendPhoneNumberToProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"send_phone_number_to_provider\"")
			}
		case "send_email_to_provider":
			if err := func() error {
				s.SendEmailToProvider.Reset()
				if err := s.SendEmailToProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"send_email_to_provider\"")
			}
		case "is_flexible":
			if err := func() error {
				s.IsFlexible.Reset()
				if err := s.IsFlexible.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_flexible\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendInvoice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11011101,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendInvoice) {
					name = jsonFieldsNameOfSendInvoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendInvoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendInvoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendLocation) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		if s.HorizontalAccuracy.Set {
			e.FieldStart("horizontal_accuracy")
			s.HorizontalAccuracy.Encode(e)
		}
	}
	{
		if s.LivePeriod.Set {
			e.FieldStart("live_period")
			s.LivePeriod.Encode(e)
		}
	}
	{
		if s.Heading.Set {
			e.FieldStart("heading")
			s.Heading.Encode(e)
		}
	}
	{
		if s.ProximityAlertRadius.Set {
			e.FieldStart("proximity_alert_radius")
			s.ProximityAlertRadius.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendLocation = [15]string{
	0:  "business_connection_id",
	1:  "chat_id",
	2:  "message_thread_id",
	3:  "latitude",
	4:  "longitude",
	5:  "horizontal_accuracy",
	6:  "live_period",
	7:  "heading",
	8:  "proximity_alert_radius",
	9:  "disable_notification",
	10: "protect_content",
	11: "allow_paid_broadcast",
	12: "message_effect_id",
	13: "reply_parameters",
	14: "reply_markup",
}

// Decode decodes SendLocation from json.
func (s *SendLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendLocation to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "horizontal_accuracy":
			if err := func() error {
				s.HorizontalAccuracy.Reset()
				if err := s.HorizontalAccuracy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"horizontal_accuracy\"")
			}
		case "live_period":
			if err := func() error {
				s.LivePeriod.Reset()
				if err := s.LivePeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"live_period\"")
			}
		case "heading":
			if err := func() error {
				s.Heading.Reset()
				if err := s.Heading.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heading\"")
			}
		case "proximity_alert_radius":
			if err := func() error {
				s.ProximityAlertRadius.Reset()
				if err := s.ProximityAlertRadius.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proximity_alert_radius\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendLocation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendLocation) {
					name = jsonFieldsNameOfSendLocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendMediaGroup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendMediaGroup) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("media")
		e.ArrStart()
		for _, elem := range s.Media {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendMediaGroup = [9]string{
	0: "business_connection_id",
	1: "chat_id",
	2: "message_thread_id",
	3: "media",
	4: "disable_notification",
	5: "protect_content",
	6: "allow_paid_broadcast",
	7: "message_effect_id",
	8: "reply_parameters",
}

// Decode decodes SendMediaGroup from json.
func (s *SendMediaGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendMediaGroup to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Media = make([]SendMediaGroupMediaItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SendMediaGroupMediaItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Media = append(s.Media, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendMediaGroup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendMediaGroup) {
					name = jsonFieldsNameOfSendMediaGroup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendMediaGroup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendMediaGroup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendMediaGroupMediaItem as json.
func (s SendMediaGroupMediaItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s SendMediaGroupMediaItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InputMediaAudioSendMediaGroupMediaItem:
		e.FieldStart("type")
		e.Str("audio")
		{
			s := s.InputMediaAudio
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Thumbnail.Set {
					e.FieldStart("thumbnail")
					s.Thumbnail.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.Duration.Set {
					e.FieldStart("duration")
					s.Duration.Encode(e)
				}
			}
			{
				if s.Performer.Set {
					e.FieldStart("performer")
					s.Performer.Encode(e)
				}
			}
			{
				if s.Title.Set {
					e.FieldStart("title")
					s.Title.Encode(e)
				}
			}
		}
	case InputMediaDocumentSendMediaGroupMediaItem:
		e.FieldStart("type")
		e.Str("document")
		{
			s := s.InputMediaDocument
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Thumbnail.Set {
					e.FieldStart("thumbnail")
					s.Thumbnail.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.DisableContentTypeDetection.Set {
					e.FieldStart("disable_content_type_detection")
					s.DisableContentTypeDetection.Encode(e)
				}
			}
		}
	case InputMediaPhotoSendMediaGroupMediaItem:
		e.FieldStart("type")
		e.Str("photo")
		{
			s := s.InputMediaPhoto
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ShowCaptionAboveMedia.Set {
					e.FieldStart("show_caption_above_media")
					s.ShowCaptionAboveMedia.Encode(e)
				}
			}
			{
				if s.HasSpoiler.Set {
					e.FieldStart("has_spoiler")
					s.HasSpoiler.Encode(e)
				}
			}
		}
	case InputMediaVideoSendMediaGroupMediaItem:
		e.FieldStart("type")
		e.Str("video")
		{
			s := s.InputMediaVideo
			{
				e.FieldStart("media")
				e.Str(s.Media)
			}
			{
				if s.Thumbnail.Set {
					e.FieldStart("thumbnail")
					s.Thumbnail.Encode(e)
				}
			}
			{
				if s.Caption.Set {
					e.FieldStart("caption")
					s.Caption.Encode(e)
				}
			}
			{
				if s.ParseMode.Set {
					e.FieldStart("parse_mode")
					s.ParseMode.Encode(e)
				}
			}
			{
				if s.CaptionEntities != nil {
					e.FieldStart("caption_entities")
					e.ArrStart()
					for _, elem := range s.CaptionEntities {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ShowCaptionAboveMedia.Set {
					e.FieldStart("show_caption_above_media")
					s.ShowCaptionAboveMedia.Encode(e)
				}
			}
			{
				if s.Width.Set {
					e.FieldStart("width")
					s.Width.Encode(e)
				}
			}
			{
				if s.Height.Set {
					e.FieldStart("height")
					s.Height.Encode(e)
				}
			}
			{
				if s.Duration.Set {
					e.FieldStart("duration")
					s.Duration.Encode(e)
				}
			}
			{
				if s.SupportsStreaming.Set {
					e.FieldStart("supports_streaming")
					s.SupportsStreaming.Encode(e)
				}
			}
			{
				if s.HasSpoiler.Set {
					e.FieldStart("has_spoiler")
					s.HasSpoiler.Encode(e)
				}
			}
		}
	}
}

// Decode decodes SendMediaGroupMediaItem from json.
func (s *SendMediaGroupMediaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendMediaGroupMediaItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "audio":
					s.Type = InputMediaAudioSendMediaGroupMediaItem
					found = true
				case "document":
					s.Type = InputMediaDocumentSendMediaGroupMediaItem
					found = true
				case "photo":
					s.Type = InputMediaPhotoSendMediaGroupMediaItem
					found = true
				case "video":
					s.Type = InputMediaVideoSendMediaGroupMediaItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InputMediaAudioSendMediaGroupMediaItem:
		if err := s.InputMediaAudio.Decode(d); err != nil {
			return err
		}
	case InputMediaDocumentSendMediaGroupMediaItem:
		if err := s.InputMediaDocument.Decode(d); err != nil {
			return err
		}
	case InputMediaPhotoSendMediaGroupMediaItem:
		if err := s.InputMediaPhoto.Decode(d); err != nil {
			return err
		}
	case InputMediaVideoSendMediaGroupMediaItem:
		if err := s.InputMediaVideo.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendMediaGroupMediaItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendMediaGroupMediaItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendMessage) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.Entities != nil {
			e.FieldStart("entities")
			e.ArrStart()
			for _, elem := range s.Entities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LinkPreviewOptions.Set {
			e.FieldStart("link_preview_options")
			s.LinkPreviewOptions.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendMessage = [13]string{
	0:  "business_connection_id",
	1:  "chat_id",
	2:  "message_thread_id",
	3:  "text",
	4:  "parse_mode",
	5:  "entities",
	6:  "link_preview_options",
	7:  "disable_notification",
	8:  "protect_content",
	9:  "allow_paid_broadcast",
	10: "message_effect_id",
	11: "reply_parameters",
	12: "reply_markup",
}

// Decode decodes SendMessage from json.
func (s *SendMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendMessage to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "entities":
			if err := func() error {
				s.Entities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entities = append(s.Entities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entities\"")
			}
		case "link_preview_options":
			if err := func() error {
				s.LinkPreviewOptions.Reset()
				if err := s.LinkPreviewOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_preview_options\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendMessage) {
					name = jsonFieldsNameOfSendMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendPaidMedia) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendPaidMedia) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("star_count")
		e.Int(s.StarCount)
	}
	{
		e.FieldStart("media")
		e.ArrStart()
		for _, elem := range s.Media {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Payload.Set {
			e.FieldStart("payload")
			s.Payload.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendPaidMedia = [14]string{
	0:  "business_connection_id",
	1:  "chat_id",
	2:  "star_count",
	3:  "media",
	4:  "payload",
	5:  "caption",
	6:  "parse_mode",
	7:  "caption_entities",
	8:  "show_caption_above_media",
	9:  "disable_notification",
	10: "protect_content",
	11: "allow_paid_broadcast",
	12: "reply_parameters",
	13: "reply_markup",
}

// Decode decodes SendPaidMedia from json.
func (s *SendPaidMedia) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendPaidMedia to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "star_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.StarCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"star_count\"")
			}
		case "media":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Media = make([]InputPaidMedia, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InputPaidMedia
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Media = append(s.Media, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media\"")
			}
		case "payload":
			if err := func() error {
				s.Payload.Reset()
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendPaidMedia")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendPaidMedia) {
					name = jsonFieldsNameOfSendPaidMedia[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendPaidMedia) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendPaidMedia) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendPhoto) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("photo")
		e.Str(s.Photo)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.HasSpoiler.Set {
			e.FieldStart("has_spoiler")
			s.HasSpoiler.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendPhoto = [15]string{
	0:  "business_connection_id",
	1:  "chat_id",
	2:  "message_thread_id",
	3:  "photo",
	4:  "caption",
	5:  "parse_mode",
	6:  "caption_entities",
	7:  "show_caption_above_media",
	8:  "has_spoiler",
	9:  "disable_notification",
	10: "protect_content",
	11: "allow_paid_broadcast",
	12: "message_effect_id",
	13: "reply_parameters",
	14: "reply_markup",
}

// Decode decodes SendPhoto from json.
func (s *SendPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendPhoto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "photo":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Photo = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "has_spoiler":
			if err := func() error {
				s.HasSpoiler.Reset()
				if err := s.HasSpoiler.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_spoiler\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendPhoto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendPhoto) {
					name = jsonFieldsNameOfSendPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendPhoto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendPhoto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendPoll) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendPoll) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("question")
		e.Str(s.Question)
	}
	{
		if s.QuestionParseMode.Set {
			e.FieldStart("question_parse_mode")
			s.QuestionParseMode.Encode(e)
		}
	}
	{
		if s.QuestionEntities != nil {
			e.FieldStart("question_entities")
			e.ArrStart()
			for _, elem := range s.QuestionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("options")
		e.ArrStart()
		for _, elem := range s.Options {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.IsAnonymous.Set {
			e.FieldStart("is_anonymous")
			s.IsAnonymous.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.AllowsMultipleAnswers.Set {
			e.FieldStart("allows_multiple_answers")
			s.AllowsMultipleAnswers.Encode(e)
		}
	}
	{
		if s.CorrectOptionID.Set {
			e.FieldStart("correct_option_id")
			s.CorrectOptionID.Encode(e)
		}
	}
	{
		if s.Explanation.Set {
			e.FieldStart("explanation")
			s.Explanation.Encode(e)
		}
	}
	{
		if s.ExplanationParseMode.Set {
			e.FieldStart("explanation_parse_mode")
			s.ExplanationParseMode.Encode(e)
		}
	}
	{
		if s.ExplanationEntities != nil {
			e.FieldStart("explanation_entities")
			e.ArrStart()
			for _, elem := range s.ExplanationEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.OpenPeriod.Set {
			e.FieldStart("open_period")
			s.OpenPeriod.Encode(e)
		}
	}
	{
		if s.CloseDate.Set {
			e.FieldStart("close_date")
			s.CloseDate.Encode(e)
		}
	}
	{
		if s.IsClosed.Set {
			e.FieldStart("is_closed")
			s.IsClosed.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendPoll = [23]string{
	0:  "business_connection_id",
	1:  "chat_id",
	2:  "message_thread_id",
	3:  "question",
	4:  "question_parse_mode",
	5:  "question_entities",
	6:  "options",
	7:  "is_anonymous",
	8:  "type",
	9:  "allows_multiple_answers",
	10: "correct_option_id",
	11: "explanation",
	12: "explanation_parse_mode",
	13: "explanation_entities",
	14: "open_period",
	15: "close_date",
	16: "is_closed",
	17: "disable_notification",
	18: "protect_content",
	19: "allow_paid_broadcast",
	20: "message_effect_id",
	21: "reply_parameters",
	22: "reply_markup",
}

// Decode decodes SendPoll from json.
func (s *SendPoll) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendPoll to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "question":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Question = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"question\"")
			}
		case "question_parse_mode":
			if err := func() error {
				s.QuestionParseMode.Reset()
				if err := s.QuestionParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"question_parse_mode\"")
			}
		case "question_entities":
			if err := func() error {
				s.QuestionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.QuestionEntities = append(s.QuestionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"question_entities\"")
			}
		case "options":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.Options = make([]InputPollOption, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InputPollOption
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Options = append(s.Options, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		case "is_anonymous":
			if err := func() error {
				s.IsAnonymous.Reset()
				if err := s.IsAnonymous.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_anonymous\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "allows_multiple_answers":
			if err := func() error {
				s.AllowsMultipleAnswers.Reset()
				if err := s.AllowsMultipleAnswers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allows_multiple_answers\"")
			}
		case "correct_option_id":
			if err := func() error {
				s.CorrectOptionID.Reset()
				if err := s.CorrectOptionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correct_option_id\"")
			}
		case "explanation":
			if err := func() error {
				s.Explanation.Reset()
				if err := s.Explanation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explanation\"")
			}
		case "explanation_parse_mode":
			if err := func() error {
				s.ExplanationParseMode.Reset()
				if err := s.ExplanationParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explanation_parse_mode\"")
			}
		case "explanation_entities":
			if err := func() error {
				s.ExplanationEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExplanationEntities = append(s.ExplanationEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explanation_entities\"")
			}
		case "open_period":
			if err := func() error {
				s.OpenPeriod.Reset()
				if err := s.OpenPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_period\"")
			}
		case "close_date":
			if err := func() error {
				s.CloseDate.Reset()
				if err := s.CloseDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"close_date\"")
			}
		case "is_closed":
			if err := func() error {
				s.IsClosed.Reset()
				if err := s.IsClosed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_closed\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendPoll")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01001010,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendPoll) {
					name = jsonFieldsNameOfSendPoll[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendPoll) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendPoll) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendReplyMarkup as json.
func (s SendReplyMarkup) Encode(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

func (s SendReplyMarkup) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case InlineKeyboardMarkupSendReplyMarkup:
		s.InlineKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardMarkupSendReplyMarkup:
		s.ReplyKeyboardMarkup.encodeFields(e)
	case ReplyKeyboardRemoveSendReplyMarkup:
		s.ReplyKeyboardRemove.encodeFields(e)
	case ForceReplySendReplyMarkup:
		s.ForceReply.encodeFields(e)
	}
}

// Decode decodes SendReplyMarkup from json.
func (s *SendReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendReplyMarkup to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "inline_keyboard":
				match := InlineKeyboardMarkupSendReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "keyboard":
				match := ReplyKeyboardMarkupSendReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "is_persistent":
				match := ReplyKeyboardMarkupSendReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "resize_keyboard":
				match := ReplyKeyboardMarkupSendReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "one_time_keyboard":
				match := ReplyKeyboardMarkupSendReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "remove_keyboard":
				match := ReplyKeyboardRemoveSendReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "force_reply":
				match := ForceReplySendReplyMarkup
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SendReplyMarkup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendReplyMarkup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendSticker) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendSticker) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("sticker")
		e.Str(s.Sticker)
	}
	{
		if s.Emoji.Set {
			e.FieldStart("emoji")
			s.Emoji.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendSticker = [11]string{
	0:  "business_connection_id",
	1:  "chat_id",
	2:  "message_thread_id",
	3:  "sticker",
	4:  "emoji",
	5:  "disable_notification",
	6:  "protect_content",
	7:  "allow_paid_broadcast",
	8:  "message_effect_id",
	9:  "reply_parameters",
	10: "reply_markup",
}

// Decode decodes SendSticker from json.
func (s *SendSticker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendSticker to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "sticker":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Sticker = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		case "emoji":
			if err := func() error {
				s.Emoji.Reset()
				if err := s.Emoji.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emoji\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendSticker")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendSticker) {
					name = jsonFieldsNameOfSendSticker[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendSticker) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendSticker) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendVenue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendVenue) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		if s.FoursquareID.Set {
			e.FieldStart("foursquare_id")
			s.FoursquareID.Encode(e)
		}
	}
	{
		if s.FoursquareType.Set {
			e.FieldStart("foursquare_type")
			s.FoursquareType.Encode(e)
		}
	}
	{
		if s.GooglePlaceID.Set {
			e.FieldStart("google_place_id")
			s.GooglePlaceID.Encode(e)
		}
	}
	{
		if s.GooglePlaceType.Set {
			e.FieldStart("google_place_type")
			s.GooglePlaceType.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendVenue = [17]string{
	0:  "business_connection_id",
	1:  "chat_id",
	2:  "message_thread_id",
	3:  "latitude",
	4:  "longitude",
	5:  "title",
	6:  "address",
	7:  "foursquare_id",
	8:  "foursquare_type",
	9:  "google_place_id",
	10: "google_place_type",
	11: "disable_notification",
	12: "protect_content",
	13: "allow_paid_broadcast",
	14: "message_effect_id",
	15: "reply_parameters",
	16: "reply_markup",
}

// Decode decodes SendVenue from json.
func (s *SendVenue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendVenue to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "foursquare_id":
			if err := func() error {
				s.FoursquareID.Reset()
				if err := s.FoursquareID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foursquare_id\"")
			}
		case "foursquare_type":
			if err := func() error {
				s.FoursquareType.Reset()
				if err := s.FoursquareType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foursquare_type\"")
			}
		case "google_place_id":
			if err := func() error {
				s.GooglePlaceID.Reset()
				if err := s.GooglePlaceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_place_id\"")
			}
		case "google_place_type":
			if err := func() error {
				s.GooglePlaceType.Reset()
				if err := s.GooglePlaceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_place_type\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendVenue")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01111010,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendVenue) {
					name = jsonFieldsNameOfSendVenue[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendVenue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendVenue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendVideo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendVideo) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("video")
		e.Str(s.Video)
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Width.Set {
			e.FieldStart("width")
			s.Width.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ShowCaptionAboveMedia.Set {
			e.FieldStart("show_caption_above_media")
			s.ShowCaptionAboveMedia.Encode(e)
		}
	}
	{
		if s.HasSpoiler.Set {
			e.FieldStart("has_spoiler")
			s.HasSpoiler.Encode(e)
		}
	}
	{
		if s.SupportsStreaming.Set {
			e.FieldStart("supports_streaming")
			s.SupportsStreaming.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendVideo = [20]string{
	0:  "business_connection_id",
	1:  "chat_id",
	2:  "message_thread_id",
	3:  "video",
	4:  "duration",
	5:  "width",
	6:  "height",
	7:  "thumbnail",
	8:  "caption",
	9:  "parse_mode",
	10: "caption_entities",
	11: "show_caption_above_media",
	12: "has_spoiler",
	13: "supports_streaming",
	14: "disable_notification",
	15: "protect_content",
	16: "allow_paid_broadcast",
	17: "message_effect_id",
	18: "reply_parameters",
	19: "reply_markup",
}

// Decode decodes SendVideo from json.
func (s *SendVideo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendVideo to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "video":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Video = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "width":
			if err := func() error {
				s.Width.Reset()
				if err := s.Width.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "show_caption_above_media":
			if err := func() error {
				s.ShowCaptionAboveMedia.Reset()
				if err := s.ShowCaptionAboveMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_caption_above_media\"")
			}
		case "has_spoiler":
			if err := func() error {
				s.HasSpoiler.Reset()
				if err := s.HasSpoiler.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_spoiler\"")
			}
		case "supports_streaming":
			if err := func() error {
				s.SupportsStreaming.Reset()
				if err := s.SupportsStreaming.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supports_streaming\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendVideo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00001010,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendVideo) {
					name = jsonFieldsNameOfSendVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendVideo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendVideo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendVideoNote) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendVideoNote) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("video_note")
		e.Str(s.VideoNote)
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Length.Set {
			e.FieldStart("length")
			s.Length.Encode(e)
		}
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendVideoNote = [13]string{
	0:  "business_connection_id",
	1:  "chat_id",
	2:  "message_thread_id",
	3:  "video_note",
	4:  "duration",
	5:  "length",
	6:  "thumbnail",
	7:  "disable_notification",
	8:  "protect_content",
	9:  "allow_paid_broadcast",
	10: "message_effect_id",
	11: "reply_parameters",
	12: "reply_markup",
}

// Decode decodes SendVideoNote from json.
func (s *SendVideoNote) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendVideoNote to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "video_note":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VideoNote = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_note\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "length":
			if err := func() error {
				s.Length.Reset()
				if err := s.Length.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"length\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendVideoNote")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendVideoNote) {
					name = jsonFieldsNameOfSendVideoNote[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendVideoNote) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendVideoNote) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendVoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendVoice) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageThreadID.Set {
			e.FieldStart("message_thread_id")
			s.MessageThreadID.Encode(e)
		}
	}
	{
		e.FieldStart("voice")
		e.Str(s.Voice)
	}
	{
		if s.Caption.Set {
			e.FieldStart("caption")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.FieldStart("parse_mode")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.FieldStart("caption_entities")
			e.ArrStart()
			for _, elem := range s.CaptionEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.FieldStart("disable_notification")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.FieldStart("protect_content")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.AllowPaidBroadcast.Set {
			e.FieldStart("allow_paid_broadcast")
			s.AllowPaidBroadcast.Encode(e)
		}
	}
	{
		if s.MessageEffectID.Set {
			e.FieldStart("message_effect_id")
			s.MessageEffectID.Encode(e)
		}
	}
	{
		if s.ReplyParameters.Set {
			e.FieldStart("reply_parameters")
			s.ReplyParameters.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendVoice = [14]string{
	0:  "business_connection_id",
	1:  "chat_id",
	2:  "message_thread_id",
	3:  "voice",
	4:  "caption",
	5:  "parse_mode",
	6:  "caption_entities",
	7:  "duration",
	8:  "disable_notification",
	9:  "protect_content",
	10: "allow_paid_broadcast",
	11: "message_effect_id",
	12: "reply_parameters",
	13: "reply_markup",
}

// Decode decodes SendVoice from json.
func (s *SendVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendVoice to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			if err := func() error {
				s.MessageThreadID.Reset()
				if err := s.MessageThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		case "voice":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Voice = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice\"")
			}
		case "caption":
			if err := func() error {
				s.Caption.Reset()
				if err := s.Caption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption\"")
			}
		case "parse_mode":
			if err := func() error {
				s.ParseMode.Reset()
				if err := s.ParseMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parse_mode\"")
			}
		case "caption_entities":
			if err := func() error {
				s.CaptionEntities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaptionEntities = append(s.CaptionEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_entities\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "disable_notification":
			if err := func() error {
				s.DisableNotification.Reset()
				if err := s.DisableNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_notification\"")
			}
		case "protect_content":
			if err := func() error {
				s.ProtectContent.Reset()
				if err := s.ProtectContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protect_content\"")
			}
		case "allow_paid_broadcast":
			if err := func() error {
				s.AllowPaidBroadcast.Reset()
				if err := s.AllowPaidBroadcast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_paid_broadcast\"")
			}
		case "message_effect_id":
			if err := func() error {
				s.MessageEffectID.Reset()
				if err := s.MessageEffectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_effect_id\"")
			}
		case "reply_parameters":
			if err := func() error {
				s.ReplyParameters.Reset()
				if err := s.ReplyParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_parameters\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendVoice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendVoice) {
					name = jsonFieldsNameOfSendVoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetChatAdministratorCustomTitle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetChatAdministratorCustomTitle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("custom_title")
		e.Str(s.CustomTitle)
	}
}

var jsonFieldsNameOfSetChatAdministratorCustomTitle = [3]string{
	0: "chat_id",
	1: "user_id",
	2: "custom_title",
}

// Decode decodes SetChatAdministratorCustomTitle from json.
func (s *SetChatAdministratorCustomTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetChatAdministratorCustomTitle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "custom_title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CustomTitle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetChatAdministratorCustomTitle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatAdministratorCustomTitle) {
					name = jsonFieldsNameOfSetChatAdministratorCustomTitle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetChatAdministratorCustomTitle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetChatAdministratorCustomTitle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetChatDescription) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetChatDescription) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetChatDescription = [2]string{
	0: "chat_id",
	1: "description",
}

// Decode decodes SetChatDescription from json.
func (s *SetChatDescription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetChatDescription to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetChatDescription")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatDescription) {
					name = jsonFieldsNameOfSetChatDescription[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetChatDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetChatDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetChatMenuButton) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetChatMenuButton) encodeFields(e *jx.Encoder) {
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MenuButton.Set {
			e.FieldStart("menu_button")
			s.MenuButton.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetChatMenuButton = [2]string{
	0: "chat_id",
	1: "menu_button",
}

// Decode decodes SetChatMenuButton from json.
func (s *SetChatMenuButton) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetChatMenuButton to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "menu_button":
			if err := func() error {
				s.MenuButton.Reset()
				if err := s.MenuButton.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"menu_button\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetChatMenuButton")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetChatMenuButton) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetChatMenuButton) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetChatPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetChatPermissions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	{
		if s.UseIndependentChatPermissions.Set {
			e.FieldStart("use_independent_chat_permissions")
			s.UseIndependentChatPermissions.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetChatPermissions = [3]string{
	0: "chat_id",
	1: "permissions",
	2: "use_independent_chat_permissions",
}

// Decode decodes SetChatPermissions from json.
func (s *SetChatPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetChatPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "use_independent_chat_permissions":
			if err := func() error {
				s.UseIndependentChatPermissions.Reset()
				if err := s.UseIndependentChatPermissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_independent_chat_permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetChatPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatPermissions) {
					name = jsonFieldsNameOfSetChatPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetChatPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetChatPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetChatPhoto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetChatPhoto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("photo")
		e.Str(s.Photo)
	}
}

var jsonFieldsNameOfSetChatPhoto = [2]string{
	0: "chat_id",
	1: "photo",
}

// Decode decodes SetChatPhoto from json.
func (s *SetChatPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetChatPhoto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "photo":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Photo = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetChatPhoto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatPhoto) {
					name = jsonFieldsNameOfSetChatPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetChatPhoto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetChatPhoto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetChatStickerSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetChatStickerSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("sticker_set_name")
		e.Str(s.StickerSetName)
	}
}

var jsonFieldsNameOfSetChatStickerSet = [2]string{
	0: "chat_id",
	1: "sticker_set_name",
}

// Decode decodes SetChatStickerSet from json.
func (s *SetChatStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetChatStickerSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "sticker_set_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.StickerSetName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker_set_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetChatStickerSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatStickerSet) {
					name = jsonFieldsNameOfSetChatStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetChatStickerSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetChatStickerSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetChatTitle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetChatTitle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
}

var jsonFieldsNameOfSetChatTitle = [2]string{
	0: "chat_id",
	1: "title",
}

// Decode decodes SetChatTitle from json.
func (s *SetChatTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetChatTitle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetChatTitle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatTitle) {
					name = jsonFieldsNameOfSetChatTitle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetChatTitle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetChatTitle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetCustomEmojiStickerSetThumbnail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetCustomEmojiStickerSetThumbnail) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.CustomEmojiID.Set {
			e.FieldStart("custom_emoji_id")
			s.CustomEmojiID.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetCustomEmojiStickerSetThumbnail = [2]string{
	0: "name",
	1: "custom_emoji_id",
}

// Decode decodes SetCustomEmojiStickerSetThumbnail from json.
func (s *SetCustomEmojiStickerSetThumbnail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetCustomEmojiStickerSetThumbnail to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "custom_emoji_id":
			if err := func() error {
				s.CustomEmojiID.Reset()
				if err := s.CustomEmojiID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_emoji_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetCustomEmojiStickerSetThumbnail")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetCustomEmojiStickerSetThumbnail) {
					name = jsonFieldsNameOfSetCustomEmojiStickerSetThumbnail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetCustomEmojiStickerSetThumbnail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetCustomEmojiStickerSetThumbnail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetGameScore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetGameScore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("score")
		e.Int(s.Score)
	}
	{
		if s.Force.Set {
			e.FieldStart("force")
			s.Force.Encode(e)
		}
	}
	{
		if s.DisableEditMessage.Set {
			e.FieldStart("disable_edit_message")
			s.DisableEditMessage.Encode(e)
		}
	}
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetGameScore = [7]string{
	0: "user_id",
	1: "score",
	2: "force",
	3: "disable_edit_message",
	4: "chat_id",
	5: "message_id",
	6: "inline_message_id",
}

// Decode decodes SetGameScore from json.
func (s *SetGameScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetGameScore to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "score":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Score = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "force":
			if err := func() error {
				s.Force.Reset()
				if err := s.Force.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force\"")
			}
		case "disable_edit_message":
			if err := func() error {
				s.DisableEditMessage.Reset()
				if err := s.DisableEditMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_edit_message\"")
			}
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetGameScore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetGameScore) {
					name = jsonFieldsNameOfSetGameScore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetGameScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetGameScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetMessageReaction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetMessageReaction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
	{
		if s.Reaction != nil {
			e.FieldStart("reaction")
			e.ArrStart()
			for _, elem := range s.Reaction {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IsBig.Set {
			e.FieldStart("is_big")
			s.IsBig.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetMessageReaction = [4]string{
	0: "chat_id",
	1: "message_id",
	2: "reaction",
	3: "is_big",
}

// Decode decodes SetMessageReaction from json.
func (s *SetMessageReaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetMessageReaction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "reaction":
			if err := func() error {
				s.Reaction = make([]ReactionType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReactionType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Reaction = append(s.Reaction, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reaction\"")
			}
		case "is_big":
			if err := func() error {
				s.IsBig.Reset()
				if err := s.IsBig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_big\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetMessageReaction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetMessageReaction) {
					name = jsonFieldsNameOfSetMessageReaction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetMessageReaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetMessageReaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetMyCommands) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetMyCommands) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("commands")
		e.ArrStart()
		for _, elem := range s.Commands {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetMyCommands = [3]string{
	0: "commands",
	1: "scope",
	2: "language_code",
}

// Decode decodes SetMyCommands from json.
func (s *SetMyCommands) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetMyCommands to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commands":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Commands = make([]BotCommand, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BotCommand
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Commands = append(s.Commands, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commands\"")
			}
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetMyCommands")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetMyCommands) {
					name = jsonFieldsNameOfSetMyCommands[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetMyCommands) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetMyCommands) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetMyDefaultAdministratorRights) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetMyDefaultAdministratorRights) encodeFields(e *jx.Encoder) {
	{
		if s.Rights.Set {
			e.FieldStart("rights")
			s.Rights.Encode(e)
		}
	}
	{
		if s.ForChannels.Set {
			e.FieldStart("for_channels")
			s.ForChannels.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetMyDefaultAdministratorRights = [2]string{
	0: "rights",
	1: "for_channels",
}

// Decode decodes SetMyDefaultAdministratorRights from json.
func (s *SetMyDefaultAdministratorRights) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetMyDefaultAdministratorRights to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rights":
			if err := func() error {
				s.Rights.Reset()
				if err := s.Rights.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rights\"")
			}
		case "for_channels":
			if err := func() error {
				s.ForChannels.Reset()
				if err := s.ForChannels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"for_channels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetMyDefaultAdministratorRights")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetMyDefaultAdministratorRights) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetMyDefaultAdministratorRights) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetMyDescription) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetMyDescription) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetMyDescription = [2]string{
	0: "description",
	1: "language_code",
}

// Decode decodes SetMyDescription from json.
func (s *SetMyDescription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetMyDescription to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetMyDescription")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetMyDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetMyDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetMyName) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetMyName) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetMyName = [2]string{
	0: "name",
	1: "language_code",
}

// Decode decodes SetMyName from json.
func (s *SetMyName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetMyName to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetMyName")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetMyName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetMyName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetMyShortDescription) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetMyShortDescription) encodeFields(e *jx.Encoder) {
	{
		if s.ShortDescription.Set {
			e.FieldStart("short_description")
			s.ShortDescription.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetMyShortDescription = [2]string{
	0: "short_description",
	1: "language_code",
}

// Decode decodes SetMyShortDescription from json.
func (s *SetMyShortDescription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetMyShortDescription to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "short_description":
			if err := func() error {
				s.ShortDescription.Reset()
				if err := s.ShortDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"short_description\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetMyShortDescription")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetMyShortDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetMyShortDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetPassportDataErrors) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetPassportDataErrors) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("errors")
		e.ArrStart()
		for _, elem := range s.Errors {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSetPassportDataErrors = [2]string{
	0: "user_id",
	1: "errors",
}

// Decode decodes SetPassportDataErrors from json.
func (s *SetPassportDataErrors) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetPassportDataErrors to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "errors":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Errors = make([]PassportElementError, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PassportElementError
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetPassportDataErrors")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetPassportDataErrors) {
					name = jsonFieldsNameOfSetPassportDataErrors[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetPassportDataErrors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetPassportDataErrors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetStickerEmojiList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetStickerEmojiList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sticker")
		e.Str(s.Sticker)
	}
	{
		e.FieldStart("emoji_list")
		e.ArrStart()
		for _, elem := range s.EmojiList {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSetStickerEmojiList = [2]string{
	0: "sticker",
	1: "emoji_list",
}

// Decode decodes SetStickerEmojiList from json.
func (s *SetStickerEmojiList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetStickerEmojiList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sticker":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sticker = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		case "emoji_list":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.EmojiList = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.EmojiList = append(s.EmojiList, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emoji_list\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetStickerEmojiList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetStickerEmojiList) {
					name = jsonFieldsNameOfSetStickerEmojiList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetStickerEmojiList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetStickerEmojiList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetStickerKeywords) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetStickerKeywords) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sticker")
		e.Str(s.Sticker)
	}
	{
		if s.Keywords != nil {
			e.FieldStart("keywords")
			e.ArrStart()
			for _, elem := range s.Keywords {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSetStickerKeywords = [2]string{
	0: "sticker",
	1: "keywords",
}

// Decode decodes SetStickerKeywords from json.
func (s *SetStickerKeywords) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetStickerKeywords to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sticker":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sticker = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		case "keywords":
			if err := func() error {
				s.Keywords = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Keywords = append(s.Keywords, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keywords\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetStickerKeywords")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetStickerKeywords) {
					name = jsonFieldsNameOfSetStickerKeywords[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetStickerKeywords) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetStickerKeywords) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetStickerMaskPosition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetStickerMaskPosition) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sticker")
		e.Str(s.Sticker)
	}
	{
		if s.MaskPosition.Set {
			e.FieldStart("mask_position")
			s.MaskPosition.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetStickerMaskPosition = [2]string{
	0: "sticker",
	1: "mask_position",
}

// Decode decodes SetStickerMaskPosition from json.
func (s *SetStickerMaskPosition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetStickerMaskPosition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sticker":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sticker = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		case "mask_position":
			if err := func() error {
				s.MaskPosition.Reset()
				if err := s.MaskPosition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mask_position\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetStickerMaskPosition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetStickerMaskPosition) {
					name = jsonFieldsNameOfSetStickerMaskPosition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetStickerMaskPosition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetStickerMaskPosition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetStickerPositionInSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetStickerPositionInSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sticker")
		e.Str(s.Sticker)
	}
	{
		e.FieldStart("position")
		e.Int(s.Position)
	}
}

var jsonFieldsNameOfSetStickerPositionInSet = [2]string{
	0: "sticker",
	1: "position",
}

// Decode decodes SetStickerPositionInSet from json.
func (s *SetStickerPositionInSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetStickerPositionInSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sticker":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sticker = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		case "position":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Position = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetStickerPositionInSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetStickerPositionInSet) {
					name = jsonFieldsNameOfSetStickerPositionInSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetStickerPositionInSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetStickerPositionInSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetStickerSetThumbnail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetStickerSetThumbnail) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
	{
		e.FieldStart("format")
		e.Str(s.Format)
	}
}

var jsonFieldsNameOfSetStickerSetThumbnail = [4]string{
	0: "name",
	1: "user_id",
	2: "thumbnail",
	3: "format",
}

// Decode decodes SetStickerSetThumbnail from json.
func (s *SetStickerSetThumbnail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetStickerSetThumbnail to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "format":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Format = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetStickerSetThumbnail")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetStickerSetThumbnail) {
					name = jsonFieldsNameOfSetStickerSetThumbnail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetStickerSetThumbnail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetStickerSetThumbnail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetStickerSetTitle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetStickerSetTitle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
}

var jsonFieldsNameOfSetStickerSetTitle = [2]string{
	0: "name",
	1: "title",
}

// Decode decodes SetStickerSetTitle from json.
func (s *SetStickerSetTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetStickerSetTitle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetStickerSetTitle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetStickerSetTitle) {
					name = jsonFieldsNameOfSetStickerSetTitle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetStickerSetTitle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetStickerSetTitle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetUserEmojiStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetUserEmojiStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		if s.EmojiStatusCustomEmojiID.Set {
			e.FieldStart("emoji_status_custom_emoji_id")
			s.EmojiStatusCustomEmojiID.Encode(e)
		}
	}
	{
		if s.EmojiStatusExpirationDate.Set {
			e.FieldStart("emoji_status_expiration_date")
			s.EmojiStatusExpirationDate.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetUserEmojiStatus = [3]string{
	0: "user_id",
	1: "emoji_status_custom_emoji_id",
	2: "emoji_status_expiration_date",
}

// Decode decodes SetUserEmojiStatus from json.
func (s *SetUserEmojiStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetUserEmojiStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "emoji_status_custom_emoji_id":
			if err := func() error {
				s.EmojiStatusCustomEmojiID.Reset()
				if err := s.EmojiStatusCustomEmojiID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emoji_status_custom_emoji_id\"")
			}
		case "emoji_status_expiration_date":
			if err := func() error {
				s.EmojiStatusExpirationDate.Reset()
				if err := s.EmojiStatusExpirationDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emoji_status_expiration_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetUserEmojiStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetUserEmojiStatus) {
					name = jsonFieldsNameOfSetUserEmojiStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetUserEmojiStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetUserEmojiStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetWebhook) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		if s.Certificate.Set {
			e.FieldStart("certificate")
			s.Certificate.Encode(e)
		}
	}
	{
		if s.IPAddress.Set {
			e.FieldStart("ip_address")
			s.IPAddress.Encode(e)
		}
	}
	{
		if s.MaxConnections.Set {
			e.FieldStart("max_connections")
			s.MaxConnections.Encode(e)
		}
	}
	{
		if s.AllowedUpdates != nil {
			e.FieldStart("allowed_updates")
			e.ArrStart()
			for _, elem := range s.AllowedUpdates {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DropPendingUpdates.Set {
			e.FieldStart("drop_pending_updates")
			s.DropPendingUpdates.Encode(e)
		}
	}
	{
		if s.SecretToken.Set {
			e.FieldStart("secret_token")
			s.SecretToken.Encode(e)
		}
	}
}

var jsonFieldsNameOfSetWebhook = [7]string{
	0: "url",
	1: "certificate",
	2: "ip_address",
	3: "max_connections",
	4: "allowed_updates",
	5: "drop_pending_updates",
	6: "secret_token",
}

// Decode decodes SetWebhook from json.
func (s *SetWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetWebhook to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "certificate":
			if err := func() error {
				s.Certificate.Reset()
				if err := s.Certificate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate\"")
			}
		case "ip_address":
			if err := func() error {
				s.IPAddress.Reset()
				if err := s.IPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip_address\"")
			}
		case "max_connections":
			if err := func() error {
				s.MaxConnections.Reset()
				if err := s.MaxConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_connections\"")
			}
		case "allowed_updates":
			if err := func() error {
				s.AllowedUpdates = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedUpdates = append(s.AllowedUpdates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_updates\"")
			}
		case "drop_pending_updates":
			if err := func() error {
				s.DropPendingUpdates.Reset()
				if err := s.DropPendingUpdates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drop_pending_updates\"")
			}
		case "secret_token":
			if err := func() error {
				s.SecretToken.Reset()
				if err := s.SecretToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetWebhook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetWebhook) {
					name = jsonFieldsNameOfSetWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SharedUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SharedUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		if s.FirstName.Set {
			e.FieldStart("first_name")
			s.FirstName.Encode(e)
		}
	}
	{
		if s.LastName.Set {
			e.FieldStart("last_name")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Photo != nil {
			e.FieldStart("photo")
			e.ArrStart()
			for _, elem := range s.Photo {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSharedUser = [5]string{
	0: "user_id",
	1: "first_name",
	2: "last_name",
	3: "username",
	4: "photo",
}

// Decode decodes SharedUser from json.
func (s *SharedUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SharedUser to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "first_name":
			if err := func() error {
				s.FirstName.Reset()
				if err := s.FirstName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_name\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "photo":
			if err := func() error {
				s.Photo = make([]PhotoSize, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PhotoSize
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Photo = append(s.Photo, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SharedUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSharedUser) {
					name = jsonFieldsNameOfSharedUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SharedUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SharedUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ShippingAddress) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ShippingAddress) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("country_code")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("city")
		e.Str(s.City)
	}
	{
		e.FieldStart("street_line1")
		e.Str(s.StreetLine1)
	}
	{
		e.FieldStart("street_line2")
		e.Str(s.StreetLine2)
	}
	{
		e.FieldStart("post_code")
		e.Str(s.PostCode)
	}
}

var jsonFieldsNameOfShippingAddress = [6]string{
	0: "country_code",
	1: "state",
	2: "city",
	3: "street_line1",
	4: "street_line2",
	5: "post_code",
}

// Decode decodes ShippingAddress from json.
func (s *ShippingAddress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShippingAddress to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "country_code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country_code\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "city":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.City = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"city\"")
			}
		case "street_line1":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.StreetLine1 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"street_line1\"")
			}
		case "street_line2":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.StreetLine2 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"street_line2\"")
			}
		case "post_code":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PostCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"post_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ShippingAddress")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfShippingAddress) {
					name = jsonFieldsNameOfShippingAddress[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ShippingAddress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ShippingAddress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ShippingOption) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ShippingOption) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("prices")
		e.ArrStart()
		for _, elem := range s.Prices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfShippingOption = [3]string{
	0: "id",
	1: "title",
	2: "prices",
}

// Decode decodes ShippingOption from json.
func (s *ShippingOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShippingOption to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "prices":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Prices = make([]LabeledPrice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LabeledPrice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Prices = append(s.Prices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ShippingOption")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfShippingOption) {
					name = jsonFieldsNameOfShippingOption[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ShippingOption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ShippingOption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ShippingQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ShippingQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("from")
		s.From.Encode(e)
	}
	{
		e.FieldStart("invoice_payload")
		e.Str(s.InvoicePayload)
	}
	{
		e.FieldStart("shipping_address")
		s.ShippingAddress.Encode(e)
	}
}

var jsonFieldsNameOfShippingQuery = [4]string{
	0: "id",
	1: "from",
	2: "invoice_payload",
	3: "shipping_address",
}

// Decode decodes ShippingQuery from json.
func (s *ShippingQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShippingQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "invoice_payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.InvoicePayload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoice_payload\"")
			}
		case "shipping_address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ShippingAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shipping_address\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ShippingQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfShippingQuery) {
					name = jsonFieldsNameOfShippingQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ShippingQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ShippingQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Sticker) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Sticker) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("width")
		e.Int(s.Width)
	}
	{
		e.FieldStart("height")
		e.Int(s.Height)
	}
	{
		e.FieldStart("is_animated")
		e.Bool(s.IsAnimated)
	}
	{
		e.FieldStart("is_video")
		e.Bool(s.IsVideo)
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
	{
		if s.Emoji.Set {
			e.FieldStart("emoji")
			s.Emoji.Encode(e)
		}
	}
	{
		if s.SetName.Set {
			e.FieldStart("set_name")
			s.SetName.Encode(e)
		}
	}
	{
		if s.PremiumAnimation.Set {
			e.FieldStart("premium_animation")
			s.PremiumAnimation.Encode(e)
		}
	}
	{
		if s.MaskPosition.Set {
			e.FieldStart("mask_position")
			s.MaskPosition.Encode(e)
		}
	}
	{
		if s.CustomEmojiID.Set {
			e.FieldStart("custom_emoji_id")
			s.CustomEmojiID.Encode(e)
		}
	}
	{
		if s.NeedsRepainting.Set {
			e.FieldStart("needs_repainting")
			s.NeedsRepainting.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfSticker = [15]string{
	0:  "file_id",
	1:  "file_unique_id",
	2:  "type",
	3:  "width",
	4:  "height",
	5:  "is_animated",
	6:  "is_video",
	7:  "thumbnail",
	8:  "emoji",
	9:  "set_name",
	10: "premium_animation",
	11: "mask_position",
	12: "custom_emoji_id",
	13: "needs_repainting",
	14: "file_size",
}

// Decode decodes Sticker from json.
func (s *Sticker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Sticker to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "width":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Width = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Height = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "is_animated":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsAnimated = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_animated\"")
			}
		case "is_video":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsVideo = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_video\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "emoji":
			if err := func() error {
				s.Emoji.Reset()
				if err := s.Emoji.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emoji\"")
			}
		case "set_name":
			if err := func() error {
				s.SetName.Reset()
				if err := s.SetName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"set_name\"")
			}
		case "premium_animation":
			if err := func() error {
				s.PremiumAnimation.Reset()
				if err := s.PremiumAnimation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"premium_animation\"")
			}
		case "mask_position":
			if err := func() error {
				s.MaskPosition.Reset()
				if err := s.MaskPosition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mask_position\"")
			}
		case "custom_emoji_id":
			if err := func() error {
				s.CustomEmojiID.Reset()
				if err := s.CustomEmojiID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_emoji_id\"")
			}
		case "needs_repainting":
			if err := func() error {
				s.NeedsRepainting.Reset()
				if err := s.NeedsRepainting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"needs_repainting\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Sticker")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSticker) {
					name = jsonFieldsNameOfSticker[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Sticker) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Sticker) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StickerSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StickerSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("sticker_type")
		e.Str(s.StickerType)
	}
	{
		e.FieldStart("stickers")
		e.ArrStart()
		for _, elem := range s.Stickers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
}

var jsonFieldsNameOfStickerSet = [5]string{
	0: "name",
	1: "title",
	2: "sticker_type",
	3: "stickers",
	4: "thumbnail",
}

// Decode decodes StickerSet from json.
func (s *StickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StickerSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "sticker_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StickerType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker_type\"")
			}
		case "stickers":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Stickers = make([]Sticker, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Sticker
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Stickers = append(s.Stickers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stickers\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StickerSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStickerSet) {
					name = jsonFieldsNameOfStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StickerSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StickerSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StickerType as json.
func (s StickerType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StickerType from json.
func (s *StickerType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StickerType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StickerType(v) {
	case StickerTypeRegular:
		*s = StickerTypeRegular
	case StickerTypeMask:
		*s = StickerTypeMask
	case StickerTypeCustomEmoji:
		*s = StickerTypeCustomEmoji
	default:
		*s = StickerType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StickerType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StickerType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StopMessageLiveLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StopMessageLiveLocation) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		if s.ChatID.Set {
			e.FieldStart("chat_id")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.FieldStart("inline_message_id")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfStopMessageLiveLocation = [5]string{
	0: "business_connection_id",
	1: "chat_id",
	2: "message_id",
	3: "inline_message_id",
	4: "reply_markup",
}

// Decode decodes StopMessageLiveLocation from json.
func (s *StopMessageLiveLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopMessageLiveLocation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			if err := func() error {
				s.ChatID.Reset()
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "inline_message_id":
			if err := func() error {
				s.InlineMessageID.Reset()
				if err := s.InlineMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_message_id\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StopMessageLiveLocation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StopMessageLiveLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopMessageLiveLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StopPoll) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StopPoll) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("message_id")
		e.Int(s.MessageID)
	}
	{
		if s.ReplyMarkup.Set {
			e.FieldStart("reply_markup")
			s.ReplyMarkup.Encode(e)
		}
	}
}

var jsonFieldsNameOfStopPoll = [4]string{
	0: "business_connection_id",
	1: "chat_id",
	2: "message_id",
	3: "reply_markup",
}

// Decode decodes StopPoll from json.
func (s *StopPoll) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopPoll to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MessageID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		case "reply_markup":
			if err := func() error {
				s.ReplyMarkup.Reset()
				if err := s.ReplyMarkup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_markup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StopPoll")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStopPoll) {
					name = jsonFieldsNameOfStopPoll[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StopPoll) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopPoll) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Story) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Story) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat")
		s.Chat.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
}

var jsonFieldsNameOfStory = [2]string{
	0: "chat",
	1: "id",
}

// Decode decodes Story from json.
func (s *Story) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Story to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Chat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Story")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStory) {
					name = jsonFieldsNameOfStory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Story) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Story) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessfulPayment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessfulPayment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("total_amount")
		e.Int(s.TotalAmount)
	}
	{
		e.FieldStart("invoice_payload")
		e.Str(s.InvoicePayload)
	}
	{
		if s.SubscriptionExpirationDate.Set {
			e.FieldStart("subscription_expiration_date")
			s.SubscriptionExpirationDate.Encode(e)
		}
	}
	{
		if s.IsRecurring.Set {
			e.FieldStart("is_recurring")
			s.IsRecurring.Encode(e)
		}
	}
	{
		if s.IsFirstRecurring.Set {
			e.FieldStart("is_first_recurring")
			s.IsFirstRecurring.Encode(e)
		}
	}
	{
		if s.ShippingOptionID.Set {
			e.FieldStart("shipping_option_id")
			s.ShippingOptionID.Encode(e)
		}
	}
	{
		if s.OrderInfo.Set {
			e.FieldStart("order_info")
			s.OrderInfo.Encode(e)
		}
	}
	{
		e.FieldStart("telegram_payment_charge_id")
		e.Str(s.TelegramPaymentChargeID)
	}
	{
		e.FieldStart("provider_payment_charge_id")
		e.Str(s.ProviderPaymentChargeID)
	}
}

var jsonFieldsNameOfSuccessfulPayment = [10]string{
	0: "currency",
	1: "total_amount",
	2: "invoice_payload",
	3: "subscription_expiration_date",
	4: "is_recurring",
	5: "is_first_recurring",
	6: "shipping_option_id",
	7: "order_info",
	8: "telegram_payment_charge_id",
	9: "provider_payment_charge_id",
}

// Decode decodes SuccessfulPayment from json.
func (s *SuccessfulPayment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessfulPayment to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "total_amount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalAmount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_amount\"")
			}
		case "invoice_payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.InvoicePayload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoice_payload\"")
			}
		case "subscription_expiration_date":
			if err := func() error {
				s.SubscriptionExpirationDate.Reset()
				if err := s.SubscriptionExpirationDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_expiration_date\"")
			}
		case "is_recurring":
			if err := func() error {
				s.IsRecurring.Reset()
				if err := s.IsRecurring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_recurring\"")
			}
		case "is_first_recurring":
			if err := func() error {
				s.IsFirstRecurring.Reset()
				if err := s.IsFirstRecurring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_first_recurring\"")
			}
		case "shipping_option_id":
			if err := func() error {
				s.ShippingOptionID.Reset()
				if err := s.ShippingOptionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shipping_option_id\"")
			}
		case "order_info":
			if err := func() error {
				s.OrderInfo.Reset()
				if err := s.OrderInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order_info\"")
			}
		case "telegram_payment_charge_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TelegramPaymentChargeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegram_payment_charge_id\"")
			}
		case "provider_payment_charge_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ProviderPaymentChargeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_payment_charge_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessfulPayment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessfulPayment) {
					name = jsonFieldsNameOfSuccessfulPayment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessfulPayment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessfulPayment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SwitchInlineQueryChosenChat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SwitchInlineQueryChosenChat) encodeFields(e *jx.Encoder) {
	{
		if s.Query.Set {
			e.FieldStart("query")
			s.Query.Encode(e)
		}
	}
	{
		if s.AllowUserChats.Set {
			e.FieldStart("allow_user_chats")
			s.AllowUserChats.Encode(e)
		}
	}
	{
		if s.AllowBotChats.Set {
			e.FieldStart("allow_bot_chats")
			s.AllowBotChats.Encode(e)
		}
	}
	{
		if s.AllowGroupChats.Set {
			e.FieldStart("allow_group_chats")
			s.AllowGroupChats.Encode(e)
		}
	}
	{
		if s.AllowChannelChats.Set {
			e.FieldStart("allow_channel_chats")
			s.AllowChannelChats.Encode(e)
		}
	}
}

var jsonFieldsNameOfSwitchInlineQueryChosenChat = [5]string{
	0: "query",
	1: "allow_user_chats",
	2: "allow_bot_chats",
	3: "allow_group_chats",
	4: "allow_channel_chats",
}

// Decode decodes SwitchInlineQueryChosenChat from json.
func (s *SwitchInlineQueryChosenChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SwitchInlineQueryChosenChat to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "query":
			if err := func() error {
				s.Query.Reset()
				if err := s.Query.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		case "allow_user_chats":
			if err := func() error {
				s.AllowUserChats.Reset()
				if err := s.AllowUserChats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_user_chats\"")
			}
		case "allow_bot_chats":
			if err := func() error {
				s.AllowBotChats.Reset()
				if err := s.AllowBotChats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_bot_chats\"")
			}
		case "allow_group_chats":
			if err := func() error {
				s.AllowGroupChats.Reset()
				if err := s.AllowGroupChats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_group_chats\"")
			}
		case "allow_channel_chats":
			if err := func() error {
				s.AllowChannelChats.Reset()
				if err := s.AllowChannelChats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_channel_chats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SwitchInlineQueryChosenChat")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SwitchInlineQueryChosenChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SwitchInlineQueryChosenChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TextQuote) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TextQuote) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.Entities != nil {
			e.FieldStart("entities")
			e.ArrStart()
			for _, elem := range s.Entities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("position")
		e.Int(s.Position)
	}
	{
		if s.IsManual.Set {
			e.FieldStart("is_manual")
			s.IsManual.Encode(e)
		}
	}
}

var jsonFieldsNameOfTextQuote = [4]string{
	0: "text",
	1: "entities",
	2: "position",
	3: "is_manual",
}

// Decode decodes TextQuote from json.
func (s *TextQuote) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TextQuote to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "entities":
			if err := func() error {
				s.Entities = make([]MessageEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entities = append(s.Entities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entities\"")
			}
		case "position":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Position = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "is_manual":
			if err := func() error {
				s.IsManual.Reset()
				if err := s.IsManual.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_manual\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TextQuote")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTextQuote) {
					name = jsonFieldsNameOfTextQuote[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TextQuote) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TextQuote) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnbanChatMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnbanChatMember) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		if s.OnlyIfBanned.Set {
			e.FieldStart("only_if_banned")
			s.OnlyIfBanned.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnbanChatMember = [3]string{
	0: "chat_id",
	1: "user_id",
	2: "only_if_banned",
}

// Decode decodes UnbanChatMember from json.
func (s *UnbanChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnbanChatMember to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "only_if_banned":
			if err := func() error {
				s.OnlyIfBanned.Reset()
				if err := s.OnlyIfBanned.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"only_if_banned\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnbanChatMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnbanChatMember) {
					name = jsonFieldsNameOfUnbanChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnbanChatMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnbanChatMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnbanChatSenderChat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnbanChatSenderChat) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("sender_chat_id")
		e.Int64(s.SenderChatID)
	}
}

var jsonFieldsNameOfUnbanChatSenderChat = [2]string{
	0: "chat_id",
	1: "sender_chat_id",
}

// Decode decodes UnbanChatSenderChat from json.
func (s *UnbanChatSenderChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnbanChatSenderChat to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "sender_chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.SenderChatID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sender_chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnbanChatSenderChat")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnbanChatSenderChat) {
					name = jsonFieldsNameOfUnbanChatSenderChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnbanChatSenderChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnbanChatSenderChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnhideGeneralForumTopic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnhideGeneralForumTopic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfUnhideGeneralForumTopic = [1]string{
	0: "chat_id",
}

// Decode decodes UnhideGeneralForumTopic from json.
func (s *UnhideGeneralForumTopic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnhideGeneralForumTopic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnhideGeneralForumTopic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnhideGeneralForumTopic) {
					name = jsonFieldsNameOfUnhideGeneralForumTopic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnhideGeneralForumTopic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnhideGeneralForumTopic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnpinAllChatMessages) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnpinAllChatMessages) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfUnpinAllChatMessages = [1]string{
	0: "chat_id",
}

// Decode decodes UnpinAllChatMessages from json.
func (s *UnpinAllChatMessages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnpinAllChatMessages to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnpinAllChatMessages")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnpinAllChatMessages) {
					name = jsonFieldsNameOfUnpinAllChatMessages[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnpinAllChatMessages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnpinAllChatMessages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnpinAllForumTopicMessages) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnpinAllForumTopicMessages) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		e.FieldStart("message_thread_id")
		e.Int(s.MessageThreadID)
	}
}

var jsonFieldsNameOfUnpinAllForumTopicMessages = [2]string{
	0: "chat_id",
	1: "message_thread_id",
}

// Decode decodes UnpinAllForumTopicMessages from json.
func (s *UnpinAllForumTopicMessages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnpinAllForumTopicMessages to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_thread_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MessageThreadID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_thread_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnpinAllForumTopicMessages")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnpinAllForumTopicMessages) {
					name = jsonFieldsNameOfUnpinAllForumTopicMessages[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnpinAllForumTopicMessages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnpinAllForumTopicMessages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnpinAllGeneralForumTopicMessages) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnpinAllGeneralForumTopicMessages) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
}

var jsonFieldsNameOfUnpinAllGeneralForumTopicMessages = [1]string{
	0: "chat_id",
}

// Decode decodes UnpinAllGeneralForumTopicMessages from json.
func (s *UnpinAllGeneralForumTopicMessages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnpinAllGeneralForumTopicMessages to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnpinAllGeneralForumTopicMessages")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnpinAllGeneralForumTopicMessages) {
					name = jsonFieldsNameOfUnpinAllGeneralForumTopicMessages[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnpinAllGeneralForumTopicMessages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnpinAllGeneralForumTopicMessages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnpinChatMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnpinChatMessage) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessConnectionID.Set {
			e.FieldStart("business_connection_id")
			s.BusinessConnectionID.Encode(e)
		}
	}
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageID.Set {
			e.FieldStart("message_id")
			s.MessageID.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnpinChatMessage = [3]string{
	0: "business_connection_id",
	1: "chat_id",
	2: "message_id",
}

// Decode decodes UnpinChatMessage from json.
func (s *UnpinChatMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnpinChatMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_connection_id":
			if err := func() error {
				s.BusinessConnectionID.Reset()
				if err := s.BusinessConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection_id\"")
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "message_id":
			if err := func() error {
				s.MessageID.Reset()
				if err := s.MessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnpinChatMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnpinChatMessage) {
					name = jsonFieldsNameOfUnpinChatMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnpinChatMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnpinChatMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Update) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Update) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("update_id")
		e.Int(s.UpdateID)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.EditedMessage.Set {
			e.FieldStart("edited_message")
			s.EditedMessage.Encode(e)
		}
	}
	{
		if s.ChannelPost.Set {
			e.FieldStart("channel_post")
			s.ChannelPost.Encode(e)
		}
	}
	{
		if s.EditedChannelPost.Set {
			e.FieldStart("edited_channel_post")
			s.EditedChannelPost.Encode(e)
		}
	}
	{
		if s.BusinessConnection.Set {
			e.FieldStart("business_connection")
			s.BusinessConnection.Encode(e)
		}
	}
	{
		if s.BusinessMessage.Set {
			e.FieldStart("business_message")
			s.BusinessMessage.Encode(e)
		}
	}
	{
		if s.EditedBusinessMessage.Set {
			e.FieldStart("edited_business_message")
			s.EditedBusinessMessage.Encode(e)
		}
	}
	{
		if s.DeletedBusinessMessages.Set {
			e.FieldStart("deleted_business_messages")
			s.DeletedBusinessMessages.Encode(e)
		}
	}
	{
		if s.MessageReaction.Set {
			e.FieldStart("message_reaction")
			s.MessageReaction.Encode(e)
		}
	}
	{
		if s.MessageReactionCount.Set {
			e.FieldStart("message_reaction_count")
			s.MessageReactionCount.Encode(e)
		}
	}
	{
		if s.InlineQuery.Set {
			e.FieldStart("inline_query")
			s.InlineQuery.Encode(e)
		}
	}
	{
		if s.ChosenInlineResult.Set {
			e.FieldStart("chosen_inline_result")
			s.ChosenInlineResult.Encode(e)
		}
	}
	{
		if s.CallbackQuery.Set {
			e.FieldStart("callback_query")
			s.CallbackQuery.Encode(e)
		}
	}
	{
		if s.ShippingQuery.Set {
			e.FieldStart("shipping_query")
			s.ShippingQuery.Encode(e)
		}
	}
	{
		if s.PreCheckoutQuery.Set {
			e.FieldStart("pre_checkout_query")
			s.PreCheckoutQuery.Encode(e)
		}
	}
	{
		if s.PurchasedPaidMedia.Set {
			e.FieldStart("purchased_paid_media")
			s.PurchasedPaidMedia.Encode(e)
		}
	}
	{
		if s.Poll.Set {
			e.FieldStart("poll")
			s.Poll.Encode(e)
		}
	}
	{
		if s.PollAnswer.Set {
			e.FieldStart("poll_answer")
			s.PollAnswer.Encode(e)
		}
	}
	{
		if s.MyChatMember.Set {
			e.FieldStart("my_chat_member")
			s.MyChatMember.Encode(e)
		}
	}
	{
		if s.ChatMember.Set {
			e.FieldStart("chat_member")
			s.ChatMember.Encode(e)
		}
	}
	{
		if s.ChatJoinRequest.Set {
			e.FieldStart("chat_join_request")
			s.ChatJoinRequest.Encode(e)
		}
	}
	{
		if s.ChatBoost.Set {
			e.FieldStart("chat_boost")
			s.ChatBoost.Encode(e)
		}
	}
	{
		if s.RemovedChatBoost.Set {
			e.FieldStart("removed_chat_boost")
			s.RemovedChatBoost.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdate = [24]string{
	0:  "update_id",
	1:  "message",
	2:  "edited_message",
	3:  "channel_post",
	4:  "edited_channel_post",
	5:  "business_connection",
	6:  "business_message",
	7:  "edited_business_message",
	8:  "deleted_business_messages",
	9:  "message_reaction",
	10: "message_reaction_count",
	11: "inline_query",
	12: "chosen_inline_result",
	13: "callback_query",
	14: "shipping_query",
	15: "pre_checkout_query",
	16: "purchased_paid_media",
	17: "poll",
	18: "poll_answer",
	19: "my_chat_member",
	20: "chat_member",
	21: "chat_join_request",
	22: "chat_boost",
	23: "removed_chat_boost",
}

// Decode decodes Update from json.
func (s *Update) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Update to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "update_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.UpdateID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_id\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "edited_message":
			if err := func() error {
				s.EditedMessage.Reset()
				if err := s.EditedMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edited_message\"")
			}
		case "channel_post":
			if err := func() error {
				s.ChannelPost.Reset()
				if err := s.ChannelPost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel_post\"")
			}
		case "edited_channel_post":
			if err := func() error {
				s.EditedChannelPost.Reset()
				if err := s.EditedChannelPost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edited_channel_post\"")
			}
		case "business_connection":
			if err := func() error {
				s.BusinessConnection.Reset()
				if err := s.BusinessConnection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_connection\"")
			}
		case "business_message":
			if err := func() error {
				s.BusinessMessage.Reset()
				if err := s.BusinessMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_message\"")
			}
		case "edited_business_message":
			if err := func() error {
				s.EditedBusinessMessage.Reset()
				if err := s.EditedBusinessMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edited_business_message\"")
			}
		case "deleted_business_messages":
			if err := func() error {
				s.DeletedBusinessMessages.Reset()
				if err := s.DeletedBusinessMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleted_business_messages\"")
			}
		case "message_reaction":
			if err := func() error {
				s.MessageReaction.Reset()
				if err := s.MessageReaction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_reaction\"")
			}
		case "message_reaction_count":
			if err := func() error {
				s.MessageReactionCount.Reset()
				if err := s.MessageReactionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_reaction_count\"")
			}
		case "inline_query":
			if err := func() error {
				s.InlineQuery.Reset()
				if err := s.InlineQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inline_query\"")
			}
		case "chosen_inline_result":
			if err := func() error {
				s.ChosenInlineResult.Reset()
				if err := s.ChosenInlineResult.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chosen_inline_result\"")
			}
		case "callback_query":
			if err := func() error {
				s.CallbackQuery.Reset()
				if err := s.CallbackQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"callback_query\"")
			}
		case "shipping_query":
			if err := func() error {
				s.ShippingQuery.Reset()
				if err := s.ShippingQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shipping_query\"")
			}
		case "pre_checkout_query":
			if err := func() error {
				s.PreCheckoutQuery.Reset()
				if err := s.PreCheckoutQuery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pre_checkout_query\"")
			}
		case "purchased_paid_media":
			if err := func() error {
				s.PurchasedPaidMedia.Reset()
				if err := s.PurchasedPaidMedia.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"purchased_paid_media\"")
			}
		case "poll":
			if err := func() error {
				s.Poll.Reset()
				if err := s.Poll.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"poll\"")
			}
		case "poll_answer":
			if err := func() error {
				s.PollAnswer.Reset()
				if err := s.PollAnswer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"poll_answer\"")
			}
		case "my_chat_member":
			if err := func() error {
				s.MyChatMember.Reset()
				if err := s.MyChatMember.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"my_chat_member\"")
			}
		case "chat_member":
			if err := func() error {
				s.ChatMember.Reset()
				if err := s.ChatMember.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_member\"")
			}
		case "chat_join_request":
			if err := func() error {
				s.ChatJoinRequest.Reset()
				if err := s.ChatJoinRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_join_request\"")
			}
		case "chat_boost":
			if err := func() error {
				s.ChatBoost.Reset()
				if err := s.ChatBoost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_boost\"")
			}
		case "removed_chat_boost":
			if err := func() error {
				s.RemovedChatBoost.Reset()
				if err := s.RemovedChatBoost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"removed_chat_boost\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Update")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdate) {
					name = jsonFieldsNameOfUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Update) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Update) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UploadStickerFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UploadStickerFile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		e.FieldStart("sticker")
		e.Str(s.Sticker)
	}
	{
		e.FieldStart("sticker_format")
		e.Str(s.StickerFormat)
	}
}

var jsonFieldsNameOfUploadStickerFile = [3]string{
	0: "user_id",
	1: "sticker",
	2: "sticker_format",
}

// Decode decodes UploadStickerFile from json.
func (s *UploadStickerFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadStickerFile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "sticker":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sticker = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		case "sticker_format":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StickerFormat = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker_format\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UploadStickerFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUploadStickerFile) {
					name = jsonFieldsNameOfUploadStickerFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadStickerFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadStickerFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *User) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *User) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{
		e.FieldStart("is_bot")
		e.Bool(s.IsBot)
	}
	{
		e.FieldStart("first_name")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.FieldStart("last_name")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
	{
		if s.IsPremium.Set {
			e.FieldStart("is_premium")
			s.IsPremium.Encode(e)
		}
	}
	{
		if s.AddedToAttachmentMenu.Set {
			e.FieldStart("added_to_attachment_menu")
			s.AddedToAttachmentMenu.Encode(e)
		}
	}
	{
		if s.CanJoinGroups.Set {
			e.FieldStart("can_join_groups")
			s.CanJoinGroups.Encode(e)
		}
	}
	{
		if s.CanReadAllGroupMessages.Set {
			e.FieldStart("can_read_all_group_messages")
			s.CanReadAllGroupMessages.Encode(e)
		}
	}
	{
		if s.SupportsInlineQueries.Set {
			e.FieldStart("supports_inline_queries")
			s.SupportsInlineQueries.Encode(e)
		}
	}
	{
		if s.CanConnectToBusiness.Set {
			e.FieldStart("can_connect_to_business")
			s.CanConnectToBusiness.Encode(e)
		}
	}
	{
		if s.HasMainWebApp.Set {
			e.FieldStart("has_main_web_app")
			s.HasMainWebApp.Encode(e)
		}
	}
}

var jsonFieldsNameOfUser = [13]string{
	0:  "id",
	1:  "is_bot",
	2:  "first_name",
	3:  "last_name",
	4:  "username",
	5:  "language_code",
	6:  "is_premium",
	7:  "added_to_attachment_menu",
	8:  "can_join_groups",
	9:  "can_read_all_group_messages",
	10: "supports_inline_queries",
	11: "can_connect_to_business",
	12: "has_main_web_app",
}

// Decode decodes User from json.
func (s *User) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode User to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_bot":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsBot = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_bot\"")
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FirstName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_name\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		case "is_premium":
			if err := func() error {
				s.IsPremium.Reset()
				if err := s.IsPremium.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_premium\"")
			}
		case "added_to_attachment_menu":
			if err := func() error {
				s.AddedToAttachmentMenu.Reset()
				if err := s.AddedToAttachmentMenu.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"added_to_attachment_menu\"")
			}
		case "can_join_groups":
			if err := func() error {
				s.CanJoinGroups.Reset()
				if err := s.CanJoinGroups.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_join_groups\"")
			}
		case "can_read_all_group_messages":
			if err := func() error {
				s.CanReadAllGroupMessages.Reset()
				if err := s.CanReadAllGroupMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_read_all_group_messages\"")
			}
		case "supports_inline_queries":
			if err := func() error {
				s.SupportsInlineQueries.Reset()
				if err := s.SupportsInlineQueries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supports_inline_queries\"")
			}
		case "can_connect_to_business":
			if err := func() error {
				s.CanConnectToBusiness.Reset()
				if err := s.CanConnectToBusiness.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_connect_to_business\"")
			}
		case "has_main_web_app":
			if err := func() error {
				s.HasMainWebApp.Reset()
				if err := s.HasMainWebApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_main_web_app\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode User")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUser) {
					name = jsonFieldsNameOfUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *User) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *User) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserProfilePhotos) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserProfilePhotos) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("photos")
		e.ArrStart()
		for _, elem := range s.Photos {
			e.ArrStart()
			for _, elem := range elem {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUserProfilePhotos = [2]string{
	0: "total_count",
	1: "photos",
}

// Decode decodes UserProfilePhotos from json.
func (s *UserProfilePhotos) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserProfilePhotos to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "photos":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Photos = make([][]PhotoSize, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem []PhotoSize
					elem = make([]PhotoSize, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elemElem PhotoSize
						if err := elemElem.Decode(d); err != nil {
							return err
						}
						elem = append(elem, elemElem)
						return nil
					}); err != nil {
						return err
					}
					s.Photos = append(s.Photos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserProfilePhotos")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserProfilePhotos) {
					name = jsonFieldsNameOfUserProfilePhotos[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserProfilePhotos) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserProfilePhotos) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersShared) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersShared) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("request_id")
		e.Int(s.RequestID)
	}
	{
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUsersShared = [2]string{
	0: "request_id",
	1: "users",
}

// Decode decodes UsersShared from json.
func (s *UsersShared) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersShared to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "request_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.RequestID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		case "users":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Users = make([]SharedUser, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SharedUser
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersShared")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsersShared) {
					name = jsonFieldsNameOfUsersShared[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersShared) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersShared) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Venue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Venue) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("location")
		s.Location.Encode(e)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		if s.FoursquareID.Set {
			e.FieldStart("foursquare_id")
			s.FoursquareID.Encode(e)
		}
	}
	{
		if s.FoursquareType.Set {
			e.FieldStart("foursquare_type")
			s.FoursquareType.Encode(e)
		}
	}
	{
		if s.GooglePlaceID.Set {
			e.FieldStart("google_place_id")
			s.GooglePlaceID.Encode(e)
		}
	}
	{
		if s.GooglePlaceType.Set {
			e.FieldStart("google_place_type")
			s.GooglePlaceType.Encode(e)
		}
	}
}

var jsonFieldsNameOfVenue = [7]string{
	0: "location",
	1: "title",
	2: "address",
	3: "foursquare_id",
	4: "foursquare_type",
	5: "google_place_id",
	6: "google_place_type",
}

// Decode decodes Venue from json.
func (s *Venue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Venue to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "location":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "foursquare_id":
			if err := func() error {
				s.FoursquareID.Reset()
				if err := s.FoursquareID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foursquare_id\"")
			}
		case "foursquare_type":
			if err := func() error {
				s.FoursquareType.Reset()
				if err := s.FoursquareType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foursquare_type\"")
			}
		case "google_place_id":
			if err := func() error {
				s.GooglePlaceID.Reset()
				if err := s.GooglePlaceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_place_id\"")
			}
		case "google_place_type":
			if err := func() error {
				s.GooglePlaceType.Reset()
				if err := s.GooglePlaceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_place_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Venue")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVenue) {
					name = jsonFieldsNameOfVenue[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Venue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Venue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifyChat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifyChat) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_id")
		s.ChatID.Encode(e)
	}
	{
		if s.CustomDescription.Set {
			e.FieldStart("custom_description")
			s.CustomDescription.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerifyChat = [2]string{
	0: "chat_id",
	1: "custom_description",
}

// Decode decodes VerifyChat from json.
func (s *VerifyChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyChat to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChatID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_id\"")
			}
		case "custom_description":
			if err := func() error {
				s.CustomDescription.Reset()
				if err := s.CustomDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifyChat")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVerifyChat) {
					name = jsonFieldsNameOfVerifyChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyChat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyChat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifyUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifyUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Int64(s.UserID)
	}
	{
		if s.CustomDescription.Set {
			e.FieldStart("custom_description")
			s.CustomDescription.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerifyUser = [2]string{
	0: "user_id",
	1: "custom_description",
}

// Decode decodes VerifyUser from json.
func (s *VerifyUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyUser to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.UserID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "custom_description":
			if err := func() error {
				s.CustomDescription.Reset()
				if err := s.CustomDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifyUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVerifyUser) {
					name = jsonFieldsNameOfVerifyUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Video) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Video) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		e.FieldStart("width")
		e.Int(s.Width)
	}
	{
		e.FieldStart("height")
		e.Int(s.Height)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
	{
		if s.FileName.Set {
			e.FieldStart("file_name")
			s.FileName.Encode(e)
		}
	}
	{
		if s.MimeType.Set {
			e.FieldStart("mime_type")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfVideo = [9]string{
	0: "file_id",
	1: "file_unique_id",
	2: "width",
	3: "height",
	4: "duration",
	5: "thumbnail",
	6: "file_name",
	7: "mime_type",
	8: "file_size",
}

// Decode decodes Video from json.
func (s *Video) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Video to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "width":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Width = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "height":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Height = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "file_name":
			if err := func() error {
				s.FileName.Reset()
				if err := s.FileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_name\"")
			}
		case "mime_type":
			if err := func() error {
				s.MimeType.Reset()
				if err := s.MimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Video")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideo) {
					name = jsonFieldsNameOfVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Video) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Video) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VideoChatEnded) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VideoChatEnded) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
}

var jsonFieldsNameOfVideoChatEnded = [1]string{
	0: "duration",
}

// Decode decodes VideoChatEnded from json.
func (s *VideoChatEnded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoChatEnded to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "duration":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VideoChatEnded")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideoChatEnded) {
					name = jsonFieldsNameOfVideoChatEnded[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VideoChatEnded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VideoChatEnded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VideoChatParticipantsInvited) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VideoChatParticipantsInvited) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfVideoChatParticipantsInvited = [1]string{
	0: "users",
}

// Decode decodes VideoChatParticipantsInvited from json.
func (s *VideoChatParticipantsInvited) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoChatParticipantsInvited to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Users = make([]User, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem User
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VideoChatParticipantsInvited")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideoChatParticipantsInvited) {
					name = jsonFieldsNameOfVideoChatParticipantsInvited[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VideoChatParticipantsInvited) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VideoChatParticipantsInvited) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VideoChatScheduled) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VideoChatScheduled) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("start_date")
		e.Int(s.StartDate)
	}
}

var jsonFieldsNameOfVideoChatScheduled = [1]string{
	0: "start_date",
}

// Decode decodes VideoChatScheduled from json.
func (s *VideoChatScheduled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoChatScheduled to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "start_date":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.StartDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VideoChatScheduled")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideoChatScheduled) {
					name = jsonFieldsNameOfVideoChatScheduled[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VideoChatScheduled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VideoChatScheduled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VideoChatStarted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VideoChatStarted) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfVideoChatStarted = [0]string{}

// Decode decodes VideoChatStarted from json.
func (s *VideoChatStarted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoChatStarted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode VideoChatStarted")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VideoChatStarted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VideoChatStarted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VideoNote) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VideoNote) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		e.FieldStart("length")
		e.Int(s.Length)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
	{
		if s.Thumbnail.Set {
			e.FieldStart("thumbnail")
			s.Thumbnail.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfVideoNote = [6]string{
	0: "file_id",
	1: "file_unique_id",
	2: "length",
	3: "duration",
	4: "thumbnail",
	5: "file_size",
}

// Decode decodes VideoNote from json.
func (s *VideoNote) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoNote to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "length":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Length = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"length\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "thumbnail":
			if err := func() error {
				s.Thumbnail.Reset()
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VideoNote")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideoNote) {
					name = jsonFieldsNameOfVideoNote[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VideoNote) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VideoNote) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Voice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Voice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_unique_id")
		e.Str(s.FileUniqueID)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
	{
		if s.MimeType.Set {
			e.FieldStart("mime_type")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfVoice = [5]string{
	0: "file_id",
	1: "file_unique_id",
	2: "duration",
	3: "mime_type",
	4: "file_size",
}

// Decode decodes Voice from json.
func (s *Voice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Voice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileUniqueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_unique_id\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "mime_type":
			if err := func() error {
				s.MimeType.Reset()
				if err := s.MimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Voice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoice) {
					name = jsonFieldsNameOfVoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Voice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Voice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebAppData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebAppData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.Str(s.Data)
	}
	{
		e.FieldStart("button_text")
		e.Str(s.ButtonText)
	}
}

var jsonFieldsNameOfWebAppData = [2]string{
	0: "data",
	1: "button_text",
}

// Decode decodes WebAppData from json.
func (s *WebAppData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebAppData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Data = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "button_text":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ButtonText = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"button_text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebAppData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebAppData) {
					name = jsonFieldsNameOfWebAppData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebAppData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebAppData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebAppInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebAppInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfWebAppInfo = [1]string{
	0: "url",
}

// Decode decodes WebAppInfo from json.
func (s *WebAppInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebAppInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebAppInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebAppInfo) {
					name = jsonFieldsNameOfWebAppInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebAppInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebAppInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("has_custom_certificate")
		e.Bool(s.HasCustomCertificate)
	}
	{
		e.FieldStart("pending_update_count")
		e.Int(s.PendingUpdateCount)
	}
	{
		if s.IPAddress.Set {
			e.FieldStart("ip_address")
			s.IPAddress.Encode(e)
		}
	}
	{
		if s.LastErrorDate.Set {
			e.FieldStart("last_error_date")
			s.LastErrorDate.Encode(e)
		}
	}
	{
		if s.LastErrorMessage.Set {
			e.FieldStart("last_error_message")
			s.LastErrorMessage.Encode(e)
		}
	}
	{
		if s.LastSynchronizationErrorDate.Set {
			e.FieldStart("last_synchronization_error_date")
			s.LastSynchronizationErrorDate.Encode(e)
		}
	}
	{
		if s.MaxConnections.Set {
			e.FieldStart("max_connections")
			s.MaxConnections.Encode(e)
		}
	}
	{
		if s.AllowedUpdates != nil {
			e.FieldStart("allowed_updates")
			e.ArrStart()
			for _, elem := range s.AllowedUpdates {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfWebhookInfo = [9]string{
	0: "url",
	1: "has_custom_certificate",
	2: "pending_update_count",
	3: "ip_address",
	4: "last_error_date",
	5: "last_error_message",
	6: "last_synchronization_error_date",
	7: "max_connections",
	8: "allowed_updates",
}

// Decode decodes WebhookInfo from json.
func (s *WebhookInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookInfo to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "has_custom_certificate":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasCustomCertificate = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_custom_certificate\"")
			}
		case "pending_update_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.PendingUpdateCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pending_update_count\"")
			}
		case "ip_address":
			if err := func() error {
				s.IPAddress.Reset()
				if err := s.IPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip_address\"")
			}
		case "last_error_date":
			if err := func() error {
				s.LastErrorDate.Reset()
				if err := s.LastErrorDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_error_date\"")
			}
		case "last_error_message":
			if err := func() error {
				s.LastErrorMessage.Reset()
				if err := s.LastErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_error_message\"")
			}
		case "last_synchronization_error_date":
			if err := func() error {
				s.LastSynchronizationErrorDate.Reset()
				if err := s.LastSynchronizationErrorDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_synchronization_error_date\"")
			}
		case "max_connections":
			if err := func() error {
				s.MaxConnections.Reset()
				if err := s.MaxConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_connections\"")
			}
		case "allowed_updates":
			if err := func() error {
				s.AllowedUpdates = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedUpdates = append(s.AllowedUpdates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_updates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhookInfo) {
					name = jsonFieldsNameOfWebhookInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WriteAccessAllowed) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WriteAccessAllowed) encodeFields(e *jx.Encoder) {
	{
		if s.FromRequest.Set {
			e.FieldStart("from_request")
			s.FromRequest.Encode(e)
		}
	}
	{
		if s.WebAppName.Set {
			e.FieldStart("web_app_name")
			s.WebAppName.Encode(e)
		}
	}
	{
		if s.FromAttachmentMenu.Set {
			e.FieldStart("from_attachment_menu")
			s.FromAttachmentMenu.Encode(e)
		}
	}
}

var jsonFieldsNameOfWriteAccessAllowed = [3]string{
	0: "from_request",
	1: "web_app_name",
	2: "from_attachment_menu",
}

// Decode decodes WriteAccessAllowed from json.
func (s *WriteAccessAllowed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WriteAccessAllowed to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from_request":
			if err := func() error {
				s.FromRequest.Reset()
				if err := s.FromRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_request\"")
			}
		case "web_app_name":
			if err := func() error {
				s.WebAppName.Reset()
				if err := s.WebAppName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"web_app_name\"")
			}
		case "from_attachment_menu":
			if err := func() error {
				s.FromAttachmentMenu.Reset()
				if err := s.FromAttachmentMenu.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_attachment_menu\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WriteAccessAllowed")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WriteAccessAllowed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WriteAccessAllowed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
