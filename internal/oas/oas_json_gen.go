// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/bits"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = bits.LeadingZeros64
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
)

// Encode implements json.Marshaler.
func (s AddStickerToSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.PNGSticker.Set {
			e.Comma()
		}
		if s.PNGSticker.Set {
			e.RawStr("\"png_sticker\"" + ":")
			s.PNGSticker.Encode(e)
		}
	}
	{
		if s.TgsSticker.Set {
			e.Comma()
		}
		if s.TgsSticker.Set {
			e.RawStr("\"tgs_sticker\"" + ":")
			s.TgsSticker.Encode(e)
		}
	}
	{
		if s.WebmSticker.Set {
			e.Comma()
		}
		if s.WebmSticker.Set {
			e.RawStr("\"webm_sticker\"" + ":")
			s.WebmSticker.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"emojis\"" + ":")
		e.Str(s.Emojis)
	}
	{
		if s.MaskPosition.Set {
			e.Comma()
		}
		if s.MaskPosition.Set {
			e.RawStr("\"mask_position\"" + ":")
			s.MaskPosition.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAddStickerToSet = [7]string{
	0: "user_id",
	1: "name",
	2: "png_sticker",
	3: "tgs_sticker",
	4: "webm_sticker",
	5: "emojis",
	6: "mask_position",
}

// Decode decodes AddStickerToSet from json.
func (s *AddStickerToSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AddStickerToSet to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "png_sticker":
			s.PNGSticker.Reset()
			if err := s.PNGSticker.Decode(d); err != nil {
				return err
			}
		case "tgs_sticker":
			s.TgsSticker.Reset()
			if err := s.TgsSticker.Decode(d); err != nil {
				return err
			}
		case "webm_sticker":
			s.WebmSticker.Reset()
			if err := s.WebmSticker.Decode(d); err != nil {
				return err
			}
		case "emojis":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Emojis = string(v)
			if err != nil {
				return err
			}
		case "mask_position":
			s.MaskPosition.Reset()
			if err := s.MaskPosition.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddStickerToSet) {
					name = jsonFieldsNameOfAddStickerToSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Animation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"file_id\"" + ":")
		e.Str(s.FileID)
	}
	{
		e.Comma()

		e.RawStr("\"file_unique_id\"" + ":")
		e.Str(s.FileUniqueID)
	}
	{
		e.Comma()

		e.RawStr("\"width\"" + ":")
		e.Int(s.Width)
	}
	{
		e.Comma()

		e.RawStr("\"height\"" + ":")
		e.Int(s.Height)
	}
	{
		e.Comma()

		e.RawStr("\"duration\"" + ":")
		e.Int(s.Duration)
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.FileName.Set {
			e.Comma()
		}
		if s.FileName.Set {
			e.RawStr("\"file_name\"" + ":")
			s.FileName.Encode(e)
		}
	}
	{
		if s.MimeType.Set {
			e.Comma()
		}
		if s.MimeType.Set {
			e.RawStr("\"mime_type\"" + ":")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.Comma()
		}
		if s.FileSize.Set {
			e.RawStr("\"file_size\"" + ":")
			s.FileSize.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAnimation = [9]string{
	0: "file_id",
	1: "file_unique_id",
	2: "width",
	3: "height",
	4: "duration",
	5: "thumb",
	6: "file_name",
	7: "mime_type",
	8: "file_size",
}

// Decode decodes Animation from json.
func (s *Animation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Animation to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "width":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.Width = int(v)
			if err != nil {
				return err
			}
		case "height":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Int()
			s.Height = int(v)
			if err != nil {
				return err
			}
		case "duration":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Int()
			s.Duration = int(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "file_name":
			s.FileName.Reset()
			if err := s.FileName.Decode(d); err != nil {
				return err
			}
		case "mime_type":
			s.MimeType.Reset()
			if err := s.MimeType.Decode(d); err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnimation) {
					name = jsonFieldsNameOfAnimation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AnswerCallbackQuery) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"callback_query_id\"" + ":")
		e.Str(s.CallbackQueryID)
	}
	{
		if s.Text.Set {
			e.Comma()
		}
		if s.Text.Set {
			e.RawStr("\"text\"" + ":")
			s.Text.Encode(e)
		}
	}
	{
		if s.ShowAlert.Set {
			e.Comma()
		}
		if s.ShowAlert.Set {
			e.RawStr("\"show_alert\"" + ":")
			s.ShowAlert.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.Comma()
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.CacheTime.Set {
			e.Comma()
		}
		if s.CacheTime.Set {
			e.RawStr("\"cache_time\"" + ":")
			s.CacheTime.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAnswerCallbackQuery = [5]string{
	0: "callback_query_id",
	1: "text",
	2: "show_alert",
	3: "url",
	4: "cache_time",
}

// Decode decodes AnswerCallbackQuery from json.
func (s *AnswerCallbackQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AnswerCallbackQuery to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "callback_query_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.CallbackQueryID = string(v)
			if err != nil {
				return err
			}
		case "text":
			s.Text.Reset()
			if err := s.Text.Decode(d); err != nil {
				return err
			}
		case "show_alert":
			s.ShowAlert.Reset()
			if err := s.ShowAlert.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "cache_time":
			s.CacheTime.Reset()
			if err := s.CacheTime.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnswerCallbackQuery) {
					name = jsonFieldsNameOfAnswerCallbackQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AnswerInlineQuery) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"inline_query_id\"" + ":")
		e.Str(s.InlineQueryID)
	}
	{
		e.Comma()

		e.RawStr("\"results\"" + ":")
		e.ArrStart()
		if len(s.Results) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Results[0]
				elem.Encode(e)
			}
			for _, elem := range s.Results[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.CacheTime.Set {
			e.Comma()
		}
		if s.CacheTime.Set {
			e.RawStr("\"cache_time\"" + ":")
			s.CacheTime.Encode(e)
		}
	}
	{
		if s.IsPersonal.Set {
			e.Comma()
		}
		if s.IsPersonal.Set {
			e.RawStr("\"is_personal\"" + ":")
			s.IsPersonal.Encode(e)
		}
	}
	{
		if s.NextOffset.Set {
			e.Comma()
		}
		if s.NextOffset.Set {
			e.RawStr("\"next_offset\"" + ":")
			s.NextOffset.Encode(e)
		}
	}
	{
		if s.SwitchPmText.Set {
			e.Comma()
		}
		if s.SwitchPmText.Set {
			e.RawStr("\"switch_pm_text\"" + ":")
			s.SwitchPmText.Encode(e)
		}
	}
	{
		if s.SwitchPmParameter.Set {
			e.Comma()
		}
		if s.SwitchPmParameter.Set {
			e.RawStr("\"switch_pm_parameter\"" + ":")
			s.SwitchPmParameter.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAnswerInlineQuery = [7]string{
	0: "inline_query_id",
	1: "results",
	2: "cache_time",
	3: "is_personal",
	4: "next_offset",
	5: "switch_pm_text",
	6: "switch_pm_parameter",
}

// Decode decodes AnswerInlineQuery from json.
func (s *AnswerInlineQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AnswerInlineQuery to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inline_query_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.InlineQueryID = string(v)
			if err != nil {
				return err
			}
		case "results":
			requiredBitSet[0] |= 1 << 1
			s.Results = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem InlineQueryResult
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Results = append(s.Results, elem)
				return nil
			}); err != nil {
				return err
			}
		case "cache_time":
			s.CacheTime.Reset()
			if err := s.CacheTime.Decode(d); err != nil {
				return err
			}
		case "is_personal":
			s.IsPersonal.Reset()
			if err := s.IsPersonal.Decode(d); err != nil {
				return err
			}
		case "next_offset":
			s.NextOffset.Reset()
			if err := s.NextOffset.Decode(d); err != nil {
				return err
			}
		case "switch_pm_text":
			s.SwitchPmText.Reset()
			if err := s.SwitchPmText.Decode(d); err != nil {
				return err
			}
		case "switch_pm_parameter":
			s.SwitchPmParameter.Reset()
			if err := s.SwitchPmParameter.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnswerInlineQuery) {
					name = jsonFieldsNameOfAnswerInlineQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AnswerPreCheckoutQuery) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"pre_checkout_query_id\"" + ":")
		e.Str(s.PreCheckoutQueryID)
	}
	{
		e.Comma()

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	{
		if s.ErrorMessage.Set {
			e.Comma()
		}
		if s.ErrorMessage.Set {
			e.RawStr("\"error_message\"" + ":")
			s.ErrorMessage.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAnswerPreCheckoutQuery = [3]string{
	0: "pre_checkout_query_id",
	1: "ok",
	2: "error_message",
}

// Decode decodes AnswerPreCheckoutQuery from json.
func (s *AnswerPreCheckoutQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AnswerPreCheckoutQuery to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pre_checkout_query_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.PreCheckoutQueryID = string(v)
			if err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		case "error_message":
			s.ErrorMessage.Reset()
			if err := s.ErrorMessage.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnswerPreCheckoutQuery) {
					name = jsonFieldsNameOfAnswerPreCheckoutQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AnswerShippingQuery) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"shipping_query_id\"" + ":")
		e.Str(s.ShippingQueryID)
	}
	{
		e.Comma()

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	{
		if s.ShippingOptions != nil {
			e.Comma()
		}
		if s.ShippingOptions != nil {
			e.RawStr("\"shipping_options\"" + ":")
			e.ArrStart()
			if len(s.ShippingOptions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ShippingOptions[0]
					elem.Encode(e)
				}
				for _, elem := range s.ShippingOptions[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ErrorMessage.Set {
			e.Comma()
		}
		if s.ErrorMessage.Set {
			e.RawStr("\"error_message\"" + ":")
			s.ErrorMessage.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAnswerShippingQuery = [4]string{
	0: "shipping_query_id",
	1: "ok",
	2: "shipping_options",
	3: "error_message",
}

// Decode decodes AnswerShippingQuery from json.
func (s *AnswerShippingQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AnswerShippingQuery to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shipping_query_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.ShippingQueryID = string(v)
			if err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		case "shipping_options":
			s.ShippingOptions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ShippingOption
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ShippingOptions = append(s.ShippingOptions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "error_message":
			s.ErrorMessage.Reset()
			if err := s.ErrorMessage.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnswerShippingQuery) {
					name = jsonFieldsNameOfAnswerShippingQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ApproveChatJoinRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfApproveChatJoinRequest = [2]string{
	0: "chat_id",
	1: "user_id",
}

// Decode decodes ApproveChatJoinRequest from json.
func (s *ApproveChatJoinRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ApproveChatJoinRequest to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApproveChatJoinRequest) {
					name = jsonFieldsNameOfApproveChatJoinRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Audio) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"file_id\"" + ":")
		e.Str(s.FileID)
	}
	{
		e.Comma()

		e.RawStr("\"file_unique_id\"" + ":")
		e.Str(s.FileUniqueID)
	}
	{
		e.Comma()

		e.RawStr("\"duration\"" + ":")
		e.Int(s.Duration)
	}
	{
		if s.Performer.Set {
			e.Comma()
		}
		if s.Performer.Set {
			e.RawStr("\"performer\"" + ":")
			s.Performer.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.Comma()
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.FileName.Set {
			e.Comma()
		}
		if s.FileName.Set {
			e.RawStr("\"file_name\"" + ":")
			s.FileName.Encode(e)
		}
	}
	{
		if s.MimeType.Set {
			e.Comma()
		}
		if s.MimeType.Set {
			e.RawStr("\"mime_type\"" + ":")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.Comma()
		}
		if s.FileSize.Set {
			e.RawStr("\"file_size\"" + ":")
			s.FileSize.Encode(e)
		}
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAudio = [9]string{
	0: "file_id",
	1: "file_unique_id",
	2: "duration",
	3: "performer",
	4: "title",
	5: "file_name",
	6: "mime_type",
	7: "file_size",
	8: "thumb",
}

// Decode decodes Audio from json.
func (s *Audio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Audio to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "duration":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.Duration = int(v)
			if err != nil {
				return err
			}
		case "performer":
			s.Performer.Reset()
			if err := s.Performer.Decode(d); err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "file_name":
			s.FileName.Reset()
			if err := s.FileName.Decode(d); err != nil {
				return err
			}
		case "mime_type":
			s.MimeType.Reset()
			if err := s.MimeType.Decode(d); err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAudio) {
					name = jsonFieldsNameOfAudio[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BanChatMember) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	{
		if s.UntilDate.Set {
			e.Comma()
		}
		if s.UntilDate.Set {
			e.RawStr("\"until_date\"" + ":")
			s.UntilDate.Encode(e)
		}
	}
	{
		if s.RevokeMessages.Set {
			e.Comma()
		}
		if s.RevokeMessages.Set {
			e.RawStr("\"revoke_messages\"" + ":")
			s.RevokeMessages.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBanChatMember = [4]string{
	0: "chat_id",
	1: "user_id",
	2: "until_date",
	3: "revoke_messages",
}

// Decode decodes BanChatMember from json.
func (s *BanChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BanChatMember to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		case "until_date":
			s.UntilDate.Reset()
			if err := s.UntilDate.Decode(d); err != nil {
				return err
			}
		case "revoke_messages":
			s.RevokeMessages.Reset()
			if err := s.RevokeMessages.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBanChatMember) {
					name = jsonFieldsNameOfBanChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BanChatSenderChat) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"sender_chat_id\"" + ":")
		e.Int64(s.SenderChatID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBanChatSenderChat = [2]string{
	0: "chat_id",
	1: "sender_chat_id",
}

// Decode decodes BanChatSenderChat from json.
func (s *BanChatSenderChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BanChatSenderChat to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "sender_chat_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int64()
			s.SenderChatID = int64(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBanChatSenderChat) {
					name = jsonFieldsNameOfBanChatSenderChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BotCommand) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"command\"" + ":")
		e.Str(s.Command)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBotCommand = [2]string{
	0: "command",
	1: "description",
}

// Decode decodes BotCommand from json.
func (s *BotCommand) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommand to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "command":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Command = string(v)
			if err != nil {
				return err
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommand) {
					name = jsonFieldsNameOfBotCommand[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes BotCommandScope as json.
func (s BotCommandScope) Encode(e *jx.Writer) {
	switch s.Type {
	case BotCommandScopeDefaultBotCommandScope:
		s.BotCommandScopeDefault.Encode(e)
	case BotCommandScopeAllPrivateChatsBotCommandScope:
		s.BotCommandScopeAllPrivateChats.Encode(e)
	case BotCommandScopeAllGroupChatsBotCommandScope:
		s.BotCommandScopeAllGroupChats.Encode(e)
	case BotCommandScopeAllChatAdministratorsBotCommandScope:
		s.BotCommandScopeAllChatAdministrators.Encode(e)
	case BotCommandScopeChatBotCommandScope:
		s.BotCommandScopeChat.Encode(e)
	case BotCommandScopeChatAdministratorsBotCommandScope:
		s.BotCommandScopeChatAdministrators.Encode(e)
	case BotCommandScopeChatMemberBotCommandScope:
		s.BotCommandScopeChatMember.Encode(e)
	}
}

// Decode decodes BotCommandScope from json.
func (s *BotCommandScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommandScope to nil`)
	}
	// Sum type discriminator.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "all_chat_administrators":
					s.Type = BotCommandScopeAllChatAdministratorsBotCommandScope
					found = true
				case "all_group_chats":
					s.Type = BotCommandScopeAllGroupChatsBotCommandScope
					found = true
				case "all_private_chats":
					s.Type = BotCommandScopeAllPrivateChatsBotCommandScope
					found = true
				case "chat":
					s.Type = BotCommandScopeChatBotCommandScope
					found = true
				case "chat_administrators":
					s.Type = BotCommandScopeChatAdministratorsBotCommandScope
					found = true
				case "chat_member":
					s.Type = BotCommandScopeChatMemberBotCommandScope
					found = true
				case "default":
					s.Type = BotCommandScopeDefaultBotCommandScope
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case BotCommandScopeDefaultBotCommandScope:
		if err := s.BotCommandScopeDefault.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeAllPrivateChatsBotCommandScope:
		if err := s.BotCommandScopeAllPrivateChats.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeAllGroupChatsBotCommandScope:
		if err := s.BotCommandScopeAllGroupChats.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeAllChatAdministratorsBotCommandScope:
		if err := s.BotCommandScopeAllChatAdministrators.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeChatBotCommandScope:
		if err := s.BotCommandScopeChat.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeChatAdministratorsBotCommandScope:
		if err := s.BotCommandScopeChatAdministrators.Decode(d); err != nil {
			return err
		}
	case BotCommandScopeChatMemberBotCommandScope:
		if err := s.BotCommandScopeChatMember.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s BotCommandScopeAllChatAdministrators) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBotCommandScopeAllChatAdministrators = [1]string{
	0: "type",
}

// Decode decodes BotCommandScopeAllChatAdministrators from json.
func (s *BotCommandScopeAllChatAdministrators) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommandScopeAllChatAdministrators to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeAllChatAdministrators) {
					name = jsonFieldsNameOfBotCommandScopeAllChatAdministrators[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BotCommandScopeAllGroupChats) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBotCommandScopeAllGroupChats = [1]string{
	0: "type",
}

// Decode decodes BotCommandScopeAllGroupChats from json.
func (s *BotCommandScopeAllGroupChats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommandScopeAllGroupChats to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeAllGroupChats) {
					name = jsonFieldsNameOfBotCommandScopeAllGroupChats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BotCommandScopeAllPrivateChats) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBotCommandScopeAllPrivateChats = [1]string{
	0: "type",
}

// Decode decodes BotCommandScopeAllPrivateChats from json.
func (s *BotCommandScopeAllPrivateChats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommandScopeAllPrivateChats to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeAllPrivateChats) {
					name = jsonFieldsNameOfBotCommandScopeAllPrivateChats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BotCommandScopeChat) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBotCommandScopeChat = [2]string{
	0: "type",
	1: "chat_id",
}

// Decode decodes BotCommandScopeChat from json.
func (s *BotCommandScopeChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommandScopeChat to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeChat) {
					name = jsonFieldsNameOfBotCommandScopeChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BotCommandScopeChatAdministrators) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBotCommandScopeChatAdministrators = [2]string{
	0: "type",
	1: "chat_id",
}

// Decode decodes BotCommandScopeChatAdministrators from json.
func (s *BotCommandScopeChatAdministrators) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommandScopeChatAdministrators to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeChatAdministrators) {
					name = jsonFieldsNameOfBotCommandScopeChatAdministrators[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BotCommandScopeChatMember) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBotCommandScopeChatMember = [3]string{
	0: "type",
	1: "chat_id",
	2: "user_id",
}

// Decode decodes BotCommandScopeChatMember from json.
func (s *BotCommandScopeChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommandScopeChatMember to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeChatMember) {
					name = jsonFieldsNameOfBotCommandScopeChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BotCommandScopeDefault) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBotCommandScopeDefault = [1]string{
	0: "type",
}

// Decode decodes BotCommandScopeDefault from json.
func (s *BotCommandScopeDefault) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BotCommandScopeDefault to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBotCommandScopeDefault) {
					name = jsonFieldsNameOfBotCommandScopeDefault[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CallbackGame) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfCallbackGame = [0]string{}

// Decode decodes CallbackGame from json.
func (s *CallbackGame) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CallbackGame to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CallbackQuery) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"from\"" + ":")
		s.From.Encode(e)
	}
	{
		if s.Message.Set {
			e.Comma()
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.Comma()
		}
		if s.InlineMessageID.Set {
			e.RawStr("\"inline_message_id\"" + ":")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"chat_instance\"" + ":")
		e.Str(s.ChatInstance)
	}
	{
		if s.Data.Set {
			e.Comma()
		}
		if s.Data.Set {
			e.RawStr("\"data\"" + ":")
			s.Data.Encode(e)
		}
	}
	{
		if s.GameShortName.Set {
			e.Comma()
		}
		if s.GameShortName.Set {
			e.RawStr("\"game_short_name\"" + ":")
			s.GameShortName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCallbackQuery = [7]string{
	0: "id",
	1: "from",
	2: "message",
	3: "inline_message_id",
	4: "chat_instance",
	5: "data",
	6: "game_short_name",
}

// Decode decodes CallbackQuery from json.
func (s *CallbackQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CallbackQuery to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := s.From.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		case "chat_instance":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.ChatInstance = string(v)
			if err != nil {
				return err
			}
		case "data":
			s.Data.Reset()
			if err := s.Data.Decode(d); err != nil {
				return err
			}
		case "game_short_name":
			s.GameShortName.Reset()
			if err := s.GameShortName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCallbackQuery) {
					name = jsonFieldsNameOfCallbackQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Chat) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int64(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		if s.Title.Set {
			e.Comma()
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.Comma()
		}
		if s.Username.Set {
			e.RawStr("\"username\"" + ":")
			s.Username.Encode(e)
		}
	}
	{
		if s.FirstName.Set {
			e.Comma()
		}
		if s.FirstName.Set {
			e.RawStr("\"first_name\"" + ":")
			s.FirstName.Encode(e)
		}
	}
	{
		if s.LastName.Set {
			e.Comma()
		}
		if s.LastName.Set {
			e.RawStr("\"last_name\"" + ":")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Photo.Set {
			e.Comma()
		}
		if s.Photo.Set {
			e.RawStr("\"photo\"" + ":")
			s.Photo.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.Comma()
		}
		if s.Bio.Set {
			e.RawStr("\"bio\"" + ":")
			s.Bio.Encode(e)
		}
	}
	{
		if s.HasPrivateForwards.Set {
			e.Comma()
		}
		if s.HasPrivateForwards.Set {
			e.RawStr("\"has_private_forwards\"" + ":")
			s.HasPrivateForwards.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.InviteLink.Set {
			e.Comma()
		}
		if s.InviteLink.Set {
			e.RawStr("\"invite_link\"" + ":")
			s.InviteLink.Encode(e)
		}
	}
	{
		if s.PinnedMessage != nil {
			e.Comma()
		}
		if s.PinnedMessage != nil {
			e.RawStr("\"pinned_message\"" + ":")
			s.PinnedMessage.Encode(e)
		}
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.SlowModeDelay.Set {
			e.Comma()
		}
		if s.SlowModeDelay.Set {
			e.RawStr("\"slow_mode_delay\"" + ":")
			s.SlowModeDelay.Encode(e)
		}
	}
	{
		if s.MessageAutoDeleteTime.Set {
			e.Comma()
		}
		if s.MessageAutoDeleteTime.Set {
			e.RawStr("\"message_auto_delete_time\"" + ":")
			s.MessageAutoDeleteTime.Encode(e)
		}
	}
	{
		if s.HasProtectedContent.Set {
			e.Comma()
		}
		if s.HasProtectedContent.Set {
			e.RawStr("\"has_protected_content\"" + ":")
			s.HasProtectedContent.Encode(e)
		}
	}
	{
		if s.StickerSetName.Set {
			e.Comma()
		}
		if s.StickerSetName.Set {
			e.RawStr("\"sticker_set_name\"" + ":")
			s.StickerSetName.Encode(e)
		}
	}
	{
		if s.CanSetStickerSet.Set {
			e.Comma()
		}
		if s.CanSetStickerSet.Set {
			e.RawStr("\"can_set_sticker_set\"" + ":")
			s.CanSetStickerSet.Encode(e)
		}
	}
	{
		if s.LinkedChatID.Set {
			e.Comma()
		}
		if s.LinkedChatID.Set {
			e.RawStr("\"linked_chat_id\"" + ":")
			s.LinkedChatID.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.Comma()
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	{
		if s.AllMembersAreAdministrators.Set {
			e.Comma()
		}
		if s.AllMembersAreAdministrators.Set {
			e.RawStr("\"all_members_are_administrators\"" + ":")
			s.AllMembersAreAdministrators.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChat = [21]string{
	0:  "id",
	1:  "type",
	2:  "title",
	3:  "username",
	4:  "first_name",
	5:  "last_name",
	6:  "photo",
	7:  "bio",
	8:  "has_private_forwards",
	9:  "description",
	10: "invite_link",
	11: "pinned_message",
	12: "permissions",
	13: "slow_mode_delay",
	14: "message_auto_delete_time",
	15: "has_protected_content",
	16: "sticker_set_name",
	17: "can_set_sticker_set",
	18: "linked_chat_id",
	19: "location",
	20: "all_members_are_administrators",
}

// Decode decodes Chat from json.
func (s *Chat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Chat to nil`)
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int64()
			s.ID = int64(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "username":
			s.Username.Reset()
			if err := s.Username.Decode(d); err != nil {
				return err
			}
		case "first_name":
			s.FirstName.Reset()
			if err := s.FirstName.Decode(d); err != nil {
				return err
			}
		case "last_name":
			s.LastName.Reset()
			if err := s.LastName.Decode(d); err != nil {
				return err
			}
		case "photo":
			s.Photo.Reset()
			if err := s.Photo.Decode(d); err != nil {
				return err
			}
		case "bio":
			s.Bio.Reset()
			if err := s.Bio.Decode(d); err != nil {
				return err
			}
		case "has_private_forwards":
			s.HasPrivateForwards.Reset()
			if err := s.HasPrivateForwards.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "invite_link":
			s.InviteLink.Reset()
			if err := s.InviteLink.Decode(d); err != nil {
				return err
			}
		case "pinned_message":
			s.PinnedMessage = nil
			var elem Message
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.PinnedMessage = &elem
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "slow_mode_delay":
			s.SlowModeDelay.Reset()
			if err := s.SlowModeDelay.Decode(d); err != nil {
				return err
			}
		case "message_auto_delete_time":
			s.MessageAutoDeleteTime.Reset()
			if err := s.MessageAutoDeleteTime.Decode(d); err != nil {
				return err
			}
		case "has_protected_content":
			s.HasProtectedContent.Reset()
			if err := s.HasProtectedContent.Decode(d); err != nil {
				return err
			}
		case "sticker_set_name":
			s.StickerSetName.Reset()
			if err := s.StickerSetName.Decode(d); err != nil {
				return err
			}
		case "can_set_sticker_set":
			s.CanSetStickerSet.Reset()
			if err := s.CanSetStickerSet.Decode(d); err != nil {
				return err
			}
		case "linked_chat_id":
			s.LinkedChatID.Reset()
			if err := s.LinkedChatID.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "all_members_are_administrators":
			s.AllMembersAreAdministrators.Reset()
			if err := s.AllMembersAreAdministrators.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000011,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChat) {
					name = jsonFieldsNameOfChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChatInviteLink) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"invite_link\"" + ":")
		e.Str(s.InviteLink)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"creates_join_request\"" + ":")
		e.Bool(s.CreatesJoinRequest)
	}
	{
		e.Comma()

		e.RawStr("\"is_primary\"" + ":")
		e.Bool(s.IsPrimary)
	}
	{
		e.Comma()

		e.RawStr("\"is_revoked\"" + ":")
		e.Bool(s.IsRevoked)
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.ExpireDate.Set {
			e.Comma()
		}
		if s.ExpireDate.Set {
			e.RawStr("\"expire_date\"" + ":")
			s.ExpireDate.Encode(e)
		}
	}
	{
		if s.MemberLimit.Set {
			e.Comma()
		}
		if s.MemberLimit.Set {
			e.RawStr("\"member_limit\"" + ":")
			s.MemberLimit.Encode(e)
		}
	}
	{
		if s.PendingJoinRequestCount.Set {
			e.Comma()
		}
		if s.PendingJoinRequestCount.Set {
			e.RawStr("\"pending_join_request_count\"" + ":")
			s.PendingJoinRequestCount.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChatInviteLink = [9]string{
	0: "invite_link",
	1: "creator",
	2: "creates_join_request",
	3: "is_primary",
	4: "is_revoked",
	5: "name",
	6: "expire_date",
	7: "member_limit",
	8: "pending_join_request_count",
}

// Decode decodes ChatInviteLink from json.
func (s *ChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatInviteLink to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "invite_link":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.InviteLink = string(v)
			if err != nil {
				return err
			}
		case "creator":
			requiredBitSet[0] |= 1 << 1
			if err := s.Creator.Decode(d); err != nil {
				return err
			}
		case "creates_join_request":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Bool()
			s.CreatesJoinRequest = bool(v)
			if err != nil {
				return err
			}
		case "is_primary":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Bool()
			s.IsPrimary = bool(v)
			if err != nil {
				return err
			}
		case "is_revoked":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Bool()
			s.IsRevoked = bool(v)
			if err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "expire_date":
			s.ExpireDate.Reset()
			if err := s.ExpireDate.Decode(d); err != nil {
				return err
			}
		case "member_limit":
			s.MemberLimit.Reset()
			if err := s.MemberLimit.Decode(d); err != nil {
				return err
			}
		case "pending_join_request_count":
			s.PendingJoinRequestCount.Reset()
			if err := s.PendingJoinRequestCount.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatInviteLink) {
					name = jsonFieldsNameOfChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChatJoinRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat\"" + ":")
		s.Chat.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"from\"" + ":")
		s.From.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"date\"" + ":")
		e.Int(s.Date)
	}
	{
		if s.Bio.Set {
			e.Comma()
		}
		if s.Bio.Set {
			e.RawStr("\"bio\"" + ":")
			s.Bio.Encode(e)
		}
	}
	{
		if s.InviteLink.Set {
			e.Comma()
		}
		if s.InviteLink.Set {
			e.RawStr("\"invite_link\"" + ":")
			s.InviteLink.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChatJoinRequest = [5]string{
	0: "chat",
	1: "from",
	2: "date",
	3: "bio",
	4: "invite_link",
}

// Decode decodes ChatJoinRequest from json.
func (s *ChatJoinRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatJoinRequest to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat":
			requiredBitSet[0] |= 1 << 0
			if err := s.Chat.Decode(d); err != nil {
				return err
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := s.From.Decode(d); err != nil {
				return err
			}
		case "date":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.Date = int(v)
			if err != nil {
				return err
			}
		case "bio":
			s.Bio.Reset()
			if err := s.Bio.Decode(d); err != nil {
				return err
			}
		case "invite_link":
			s.InviteLink.Reset()
			if err := s.InviteLink.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatJoinRequest) {
					name = jsonFieldsNameOfChatJoinRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChatLocation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"location\"" + ":")
		s.Location.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"address\"" + ":")
		e.Str(s.Address)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChatLocation = [2]string{
	0: "location",
	1: "address",
}

// Decode decodes ChatLocation from json.
func (s *ChatLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatLocation to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "location":
			requiredBitSet[0] |= 1 << 0
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "address":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Address = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatLocation) {
					name = jsonFieldsNameOfChatLocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ChatMember as json.
func (s ChatMember) Encode(e *jx.Writer) {
	switch s.Type {
	case ChatMemberOwnerChatMember:
		s.ChatMemberOwner.Encode(e)
	case ChatMemberAdministratorChatMember:
		s.ChatMemberAdministrator.Encode(e)
	case ChatMemberMemberChatMember:
		s.ChatMemberMember.Encode(e)
	case ChatMemberRestrictedChatMember:
		s.ChatMemberRestricted.Encode(e)
	case ChatMemberLeftChatMember:
		s.ChatMemberLeft.Encode(e)
	case ChatMemberBannedChatMember:
		s.ChatMemberBanned.Encode(e)
	}
}

// Decode decodes ChatMember from json.
func (s *ChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatMember to nil`)
	}
	// Sum type discriminator.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "status":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "ChatMemberAdministrator":
					s.Type = ChatMemberAdministratorChatMember
					found = true
				case "ChatMemberBanned":
					s.Type = ChatMemberBannedChatMember
					found = true
				case "ChatMemberLeft":
					s.Type = ChatMemberLeftChatMember
					found = true
				case "ChatMemberMember":
					s.Type = ChatMemberMemberChatMember
					found = true
				case "ChatMemberOwner":
					s.Type = ChatMemberOwnerChatMember
					found = true
				case "ChatMemberRestricted":
					s.Type = ChatMemberRestrictedChatMember
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ChatMemberOwnerChatMember:
		if err := s.ChatMemberOwner.Decode(d); err != nil {
			return err
		}
	case ChatMemberAdministratorChatMember:
		if err := s.ChatMemberAdministrator.Decode(d); err != nil {
			return err
		}
	case ChatMemberMemberChatMember:
		if err := s.ChatMemberMember.Decode(d); err != nil {
			return err
		}
	case ChatMemberRestrictedChatMember:
		if err := s.ChatMemberRestricted.Decode(d); err != nil {
			return err
		}
	case ChatMemberLeftChatMember:
		if err := s.ChatMemberLeft.Decode(d); err != nil {
			return err
		}
	case ChatMemberBannedChatMember:
		if err := s.ChatMemberBanned.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ChatMemberAdministrator) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"can_be_edited\"" + ":")
		e.Bool(s.CanBeEdited)
	}
	{
		e.Comma()

		e.RawStr("\"is_anonymous\"" + ":")
		e.Bool(s.IsAnonymous)
	}
	{
		e.Comma()

		e.RawStr("\"can_manage_chat\"" + ":")
		e.Bool(s.CanManageChat)
	}
	{
		e.Comma()

		e.RawStr("\"can_delete_messages\"" + ":")
		e.Bool(s.CanDeleteMessages)
	}
	{
		e.Comma()

		e.RawStr("\"can_manage_voice_chats\"" + ":")
		e.Bool(s.CanManageVoiceChats)
	}
	{
		e.Comma()

		e.RawStr("\"can_restrict_members\"" + ":")
		e.Bool(s.CanRestrictMembers)
	}
	{
		e.Comma()

		e.RawStr("\"can_promote_members\"" + ":")
		e.Bool(s.CanPromoteMembers)
	}
	{
		e.Comma()

		e.RawStr("\"can_change_info\"" + ":")
		e.Bool(s.CanChangeInfo)
	}
	{
		e.Comma()

		e.RawStr("\"can_invite_users\"" + ":")
		e.Bool(s.CanInviteUsers)
	}
	{
		if s.CanPostMessages.Set {
			e.Comma()
		}
		if s.CanPostMessages.Set {
			e.RawStr("\"can_post_messages\"" + ":")
			s.CanPostMessages.Encode(e)
		}
	}
	{
		if s.CanEditMessages.Set {
			e.Comma()
		}
		if s.CanEditMessages.Set {
			e.RawStr("\"can_edit_messages\"" + ":")
			s.CanEditMessages.Encode(e)
		}
	}
	{
		if s.CanPinMessages.Set {
			e.Comma()
		}
		if s.CanPinMessages.Set {
			e.RawStr("\"can_pin_messages\"" + ":")
			s.CanPinMessages.Encode(e)
		}
	}
	{
		if s.CustomTitle.Set {
			e.Comma()
		}
		if s.CustomTitle.Set {
			e.RawStr("\"custom_title\"" + ":")
			s.CustomTitle.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChatMemberAdministrator = [15]string{
	0:  "status",
	1:  "user",
	2:  "can_be_edited",
	3:  "is_anonymous",
	4:  "can_manage_chat",
	5:  "can_delete_messages",
	6:  "can_manage_voice_chats",
	7:  "can_restrict_members",
	8:  "can_promote_members",
	9:  "can_change_info",
	10: "can_invite_users",
	11: "can_post_messages",
	12: "can_edit_messages",
	13: "can_pin_messages",
	14: "custom_title",
}

// Decode decodes ChatMemberAdministrator from json.
func (s *ChatMemberAdministrator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatMemberAdministrator to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "can_be_edited":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Bool()
			s.CanBeEdited = bool(v)
			if err != nil {
				return err
			}
		case "is_anonymous":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Bool()
			s.IsAnonymous = bool(v)
			if err != nil {
				return err
			}
		case "can_manage_chat":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Bool()
			s.CanManageChat = bool(v)
			if err != nil {
				return err
			}
		case "can_delete_messages":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Bool()
			s.CanDeleteMessages = bool(v)
			if err != nil {
				return err
			}
		case "can_manage_voice_chats":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Bool()
			s.CanManageVoiceChats = bool(v)
			if err != nil {
				return err
			}
		case "can_restrict_members":
			requiredBitSet[0] |= 1 << 7
			v, err := d.Bool()
			s.CanRestrictMembers = bool(v)
			if err != nil {
				return err
			}
		case "can_promote_members":
			requiredBitSet[1] |= 1 << 0
			v, err := d.Bool()
			s.CanPromoteMembers = bool(v)
			if err != nil {
				return err
			}
		case "can_change_info":
			requiredBitSet[1] |= 1 << 1
			v, err := d.Bool()
			s.CanChangeInfo = bool(v)
			if err != nil {
				return err
			}
		case "can_invite_users":
			requiredBitSet[1] |= 1 << 2
			v, err := d.Bool()
			s.CanInviteUsers = bool(v)
			if err != nil {
				return err
			}
		case "can_post_messages":
			s.CanPostMessages.Reset()
			if err := s.CanPostMessages.Decode(d); err != nil {
				return err
			}
		case "can_edit_messages":
			s.CanEditMessages.Reset()
			if err := s.CanEditMessages.Decode(d); err != nil {
				return err
			}
		case "can_pin_messages":
			s.CanPinMessages.Reset()
			if err := s.CanPinMessages.Decode(d); err != nil {
				return err
			}
		case "custom_title":
			s.CustomTitle.Reset()
			if err := s.CustomTitle.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberAdministrator) {
					name = jsonFieldsNameOfChatMemberAdministrator[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChatMemberBanned) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"until_date\"" + ":")
		e.Int(s.UntilDate)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChatMemberBanned = [3]string{
	0: "status",
	1: "user",
	2: "until_date",
}

// Decode decodes ChatMemberBanned from json.
func (s *ChatMemberBanned) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatMemberBanned to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "until_date":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.UntilDate = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberBanned) {
					name = jsonFieldsNameOfChatMemberBanned[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChatMemberLeft) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChatMemberLeft = [2]string{
	0: "status",
	1: "user",
}

// Decode decodes ChatMemberLeft from json.
func (s *ChatMemberLeft) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatMemberLeft to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberLeft) {
					name = jsonFieldsNameOfChatMemberLeft[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChatMemberMember) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChatMemberMember = [2]string{
	0: "status",
	1: "user",
}

// Decode decodes ChatMemberMember from json.
func (s *ChatMemberMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatMemberMember to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberMember) {
					name = jsonFieldsNameOfChatMemberMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChatMemberOwner) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"is_anonymous\"" + ":")
		e.Bool(s.IsAnonymous)
	}
	{
		if s.CustomTitle.Set {
			e.Comma()
		}
		if s.CustomTitle.Set {
			e.RawStr("\"custom_title\"" + ":")
			s.CustomTitle.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChatMemberOwner = [4]string{
	0: "status",
	1: "user",
	2: "is_anonymous",
	3: "custom_title",
}

// Decode decodes ChatMemberOwner from json.
func (s *ChatMemberOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatMemberOwner to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "is_anonymous":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Bool()
			s.IsAnonymous = bool(v)
			if err != nil {
				return err
			}
		case "custom_title":
			s.CustomTitle.Reset()
			if err := s.CustomTitle.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberOwner) {
					name = jsonFieldsNameOfChatMemberOwner[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChatMemberRestricted) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"is_member\"" + ":")
		e.Bool(s.IsMember)
	}
	{
		e.Comma()

		e.RawStr("\"can_change_info\"" + ":")
		e.Bool(s.CanChangeInfo)
	}
	{
		e.Comma()

		e.RawStr("\"can_invite_users\"" + ":")
		e.Bool(s.CanInviteUsers)
	}
	{
		e.Comma()

		e.RawStr("\"can_pin_messages\"" + ":")
		e.Bool(s.CanPinMessages)
	}
	{
		e.Comma()

		e.RawStr("\"can_send_messages\"" + ":")
		e.Bool(s.CanSendMessages)
	}
	{
		e.Comma()

		e.RawStr("\"can_send_media_messages\"" + ":")
		e.Bool(s.CanSendMediaMessages)
	}
	{
		e.Comma()

		e.RawStr("\"can_send_polls\"" + ":")
		e.Bool(s.CanSendPolls)
	}
	{
		e.Comma()

		e.RawStr("\"can_send_other_messages\"" + ":")
		e.Bool(s.CanSendOtherMessages)
	}
	{
		e.Comma()

		e.RawStr("\"can_add_web_page_previews\"" + ":")
		e.Bool(s.CanAddWebPagePreviews)
	}
	{
		e.Comma()

		e.RawStr("\"until_date\"" + ":")
		e.Int(s.UntilDate)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChatMemberRestricted = [12]string{
	0:  "status",
	1:  "user",
	2:  "is_member",
	3:  "can_change_info",
	4:  "can_invite_users",
	5:  "can_pin_messages",
	6:  "can_send_messages",
	7:  "can_send_media_messages",
	8:  "can_send_polls",
	9:  "can_send_other_messages",
	10: "can_add_web_page_previews",
	11: "until_date",
}

// Decode decodes ChatMemberRestricted from json.
func (s *ChatMemberRestricted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatMemberRestricted to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "is_member":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Bool()
			s.IsMember = bool(v)
			if err != nil {
				return err
			}
		case "can_change_info":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Bool()
			s.CanChangeInfo = bool(v)
			if err != nil {
				return err
			}
		case "can_invite_users":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Bool()
			s.CanInviteUsers = bool(v)
			if err != nil {
				return err
			}
		case "can_pin_messages":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Bool()
			s.CanPinMessages = bool(v)
			if err != nil {
				return err
			}
		case "can_send_messages":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Bool()
			s.CanSendMessages = bool(v)
			if err != nil {
				return err
			}
		case "can_send_media_messages":
			requiredBitSet[0] |= 1 << 7
			v, err := d.Bool()
			s.CanSendMediaMessages = bool(v)
			if err != nil {
				return err
			}
		case "can_send_polls":
			requiredBitSet[1] |= 1 << 0
			v, err := d.Bool()
			s.CanSendPolls = bool(v)
			if err != nil {
				return err
			}
		case "can_send_other_messages":
			requiredBitSet[1] |= 1 << 1
			v, err := d.Bool()
			s.CanSendOtherMessages = bool(v)
			if err != nil {
				return err
			}
		case "can_add_web_page_previews":
			requiredBitSet[1] |= 1 << 2
			v, err := d.Bool()
			s.CanAddWebPagePreviews = bool(v)
			if err != nil {
				return err
			}
		case "until_date":
			requiredBitSet[1] |= 1 << 3
			v, err := d.Int()
			s.UntilDate = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberRestricted) {
					name = jsonFieldsNameOfChatMemberRestricted[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChatMemberUpdated) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat\"" + ":")
		s.Chat.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"from\"" + ":")
		s.From.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"date\"" + ":")
		e.Int(s.Date)
	}
	{
		e.Comma()

		e.RawStr("\"old_chat_member\"" + ":")
		s.OldChatMember.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"new_chat_member\"" + ":")
		s.NewChatMember.Encode(e)
	}
	{
		if s.InviteLink.Set {
			e.Comma()
		}
		if s.InviteLink.Set {
			e.RawStr("\"invite_link\"" + ":")
			s.InviteLink.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChatMemberUpdated = [6]string{
	0: "chat",
	1: "from",
	2: "date",
	3: "old_chat_member",
	4: "new_chat_member",
	5: "invite_link",
}

// Decode decodes ChatMemberUpdated from json.
func (s *ChatMemberUpdated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatMemberUpdated to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat":
			requiredBitSet[0] |= 1 << 0
			if err := s.Chat.Decode(d); err != nil {
				return err
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := s.From.Decode(d); err != nil {
				return err
			}
		case "date":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.Date = int(v)
			if err != nil {
				return err
			}
		case "old_chat_member":
			requiredBitSet[0] |= 1 << 3
			if err := s.OldChatMember.Decode(d); err != nil {
				return err
			}
		case "new_chat_member":
			requiredBitSet[0] |= 1 << 4
			if err := s.NewChatMember.Decode(d); err != nil {
				return err
			}
		case "invite_link":
			s.InviteLink.Reset()
			if err := s.InviteLink.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatMemberUpdated) {
					name = jsonFieldsNameOfChatMemberUpdated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChatPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CanSendMessages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CanSendMessages.Set {
			e.RawStr("\"can_send_messages\"" + ":")
			s.CanSendMessages.Encode(e)
		}
	}
	{
		if s.CanSendMediaMessages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CanSendMediaMessages.Set {
			e.RawStr("\"can_send_media_messages\"" + ":")
			s.CanSendMediaMessages.Encode(e)
		}
	}
	{
		if s.CanSendPolls.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CanSendPolls.Set {
			e.RawStr("\"can_send_polls\"" + ":")
			s.CanSendPolls.Encode(e)
		}
	}
	{
		if s.CanSendOtherMessages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CanSendOtherMessages.Set {
			e.RawStr("\"can_send_other_messages\"" + ":")
			s.CanSendOtherMessages.Encode(e)
		}
	}
	{
		if s.CanAddWebPagePreviews.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CanAddWebPagePreviews.Set {
			e.RawStr("\"can_add_web_page_previews\"" + ":")
			s.CanAddWebPagePreviews.Encode(e)
		}
	}
	{
		if s.CanChangeInfo.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CanChangeInfo.Set {
			e.RawStr("\"can_change_info\"" + ":")
			s.CanChangeInfo.Encode(e)
		}
	}
	{
		if s.CanInviteUsers.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CanInviteUsers.Set {
			e.RawStr("\"can_invite_users\"" + ":")
			s.CanInviteUsers.Encode(e)
		}
	}
	{
		if s.CanPinMessages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CanPinMessages.Set {
			e.RawStr("\"can_pin_messages\"" + ":")
			s.CanPinMessages.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChatPermissions = [8]string{
	0: "can_send_messages",
	1: "can_send_media_messages",
	2: "can_send_polls",
	3: "can_send_other_messages",
	4: "can_add_web_page_previews",
	5: "can_change_info",
	6: "can_invite_users",
	7: "can_pin_messages",
}

// Decode decodes ChatPermissions from json.
func (s *ChatPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatPermissions to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "can_send_messages":
			s.CanSendMessages.Reset()
			if err := s.CanSendMessages.Decode(d); err != nil {
				return err
			}
		case "can_send_media_messages":
			s.CanSendMediaMessages.Reset()
			if err := s.CanSendMediaMessages.Decode(d); err != nil {
				return err
			}
		case "can_send_polls":
			s.CanSendPolls.Reset()
			if err := s.CanSendPolls.Decode(d); err != nil {
				return err
			}
		case "can_send_other_messages":
			s.CanSendOtherMessages.Reset()
			if err := s.CanSendOtherMessages.Decode(d); err != nil {
				return err
			}
		case "can_add_web_page_previews":
			s.CanAddWebPagePreviews.Reset()
			if err := s.CanAddWebPagePreviews.Decode(d); err != nil {
				return err
			}
		case "can_change_info":
			s.CanChangeInfo.Reset()
			if err := s.CanChangeInfo.Decode(d); err != nil {
				return err
			}
		case "can_invite_users":
			s.CanInviteUsers.Reset()
			if err := s.CanInviteUsers.Decode(d); err != nil {
				return err
			}
		case "can_pin_messages":
			s.CanPinMessages.Reset()
			if err := s.CanPinMessages.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChatPhoto) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"small_file_id\"" + ":")
		e.Str(s.SmallFileID)
	}
	{
		e.Comma()

		e.RawStr("\"small_file_unique_id\"" + ":")
		e.Str(s.SmallFileUniqueID)
	}
	{
		e.Comma()

		e.RawStr("\"big_file_id\"" + ":")
		e.Str(s.BigFileID)
	}
	{
		e.Comma()

		e.RawStr("\"big_file_unique_id\"" + ":")
		e.Str(s.BigFileUniqueID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChatPhoto = [4]string{
	0: "small_file_id",
	1: "small_file_unique_id",
	2: "big_file_id",
	3: "big_file_unique_id",
}

// Decode decodes ChatPhoto from json.
func (s *ChatPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatPhoto to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "small_file_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.SmallFileID = string(v)
			if err != nil {
				return err
			}
		case "small_file_unique_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.SmallFileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "big_file_id":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.BigFileID = string(v)
			if err != nil {
				return err
			}
		case "big_file_unique_id":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.BigFileUniqueID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatPhoto) {
					name = jsonFieldsNameOfChatPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ChatType as json.
func (s ChatType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ChatType from json.
func (s *ChatType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChatType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ChatType(v) {
	case ChatTypePrivate:
		*s = ChatTypePrivate
	case ChatTypeGroup:
		*s = ChatTypeGroup
	case ChatTypeSupergroup:
		*s = ChatTypeSupergroup
	case ChatTypeChannel:
		*s = ChatTypeChannel
	default:
		*s = ChatType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChosenInlineResult) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"result_id\"" + ":")
		e.Str(s.ResultID)
	}
	{
		e.Comma()

		e.RawStr("\"from\"" + ":")
		s.From.Encode(e)
	}
	{
		if s.Location.Set {
			e.Comma()
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.Comma()
		}
		if s.InlineMessageID.Set {
			e.RawStr("\"inline_message_id\"" + ":")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"query\"" + ":")
		e.Str(s.Query)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChosenInlineResult = [5]string{
	0: "result_id",
	1: "from",
	2: "location",
	3: "inline_message_id",
	4: "query",
}

// Decode decodes ChosenInlineResult from json.
func (s *ChosenInlineResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChosenInlineResult to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.ResultID = string(v)
			if err != nil {
				return err
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := s.From.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		case "query":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Query = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChosenInlineResult) {
					name = jsonFieldsNameOfChosenInlineResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Contact) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"phone_number\"" + ":")
		e.Str(s.PhoneNumber)
	}
	{
		e.Comma()

		e.RawStr("\"first_name\"" + ":")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.Comma()
		}
		if s.LastName.Set {
			e.RawStr("\"last_name\"" + ":")
			s.LastName.Encode(e)
		}
	}
	{
		if s.UserID.Set {
			e.Comma()
		}
		if s.UserID.Set {
			e.RawStr("\"user_id\"" + ":")
			s.UserID.Encode(e)
		}
	}
	{
		if s.Vcard.Set {
			e.Comma()
		}
		if s.Vcard.Set {
			e.RawStr("\"vcard\"" + ":")
			s.Vcard.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfContact = [5]string{
	0: "phone_number",
	1: "first_name",
	2: "last_name",
	3: "user_id",
	4: "vcard",
}

// Decode decodes Contact from json.
func (s *Contact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Contact to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phone_number":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.PhoneNumber = string(v)
			if err != nil {
				return err
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.FirstName = string(v)
			if err != nil {
				return err
			}
		case "last_name":
			s.LastName.Reset()
			if err := s.LastName.Decode(d); err != nil {
				return err
			}
		case "user_id":
			s.UserID.Reset()
			if err := s.UserID.Decode(d); err != nil {
				return err
			}
		case "vcard":
			s.Vcard.Reset()
			if err := s.Vcard.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContact) {
					name = jsonFieldsNameOfContact[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CopyMessage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"from_chat_id\"" + ":")
		s.FromChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"message_id\"" + ":")
		e.Int(s.MessageID)
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCopyMessage = [11]string{
	0:  "chat_id",
	1:  "from_chat_id",
	2:  "message_id",
	3:  "caption",
	4:  "parse_mode",
	5:  "caption_entities",
	6:  "disable_notification",
	7:  "protect_content",
	8:  "reply_to_message_id",
	9:  "allow_sending_without_reply",
	10: "reply_markup",
}

// Decode decodes CopyMessage from json.
func (s *CopyMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CopyMessage to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "from_chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := s.FromChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.MessageID = int(v)
			if err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCopyMessage) {
					name = jsonFieldsNameOfCopyMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CreateChatInviteLink) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.ExpireDate.Set {
			e.Comma()
		}
		if s.ExpireDate.Set {
			e.RawStr("\"expire_date\"" + ":")
			s.ExpireDate.Encode(e)
		}
	}
	{
		if s.MemberLimit.Set {
			e.Comma()
		}
		if s.MemberLimit.Set {
			e.RawStr("\"member_limit\"" + ":")
			s.MemberLimit.Encode(e)
		}
	}
	{
		if s.CreatesJoinRequest.Set {
			e.Comma()
		}
		if s.CreatesJoinRequest.Set {
			e.RawStr("\"creates_join_request\"" + ":")
			s.CreatesJoinRequest.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCreateChatInviteLink = [5]string{
	0: "chat_id",
	1: "name",
	2: "expire_date",
	3: "member_limit",
	4: "creates_join_request",
}

// Decode decodes CreateChatInviteLink from json.
func (s *CreateChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CreateChatInviteLink to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "expire_date":
			s.ExpireDate.Reset()
			if err := s.ExpireDate.Decode(d); err != nil {
				return err
			}
		case "member_limit":
			s.MemberLimit.Reset()
			if err := s.MemberLimit.Decode(d); err != nil {
				return err
			}
		case "creates_join_request":
			s.CreatesJoinRequest.Reset()
			if err := s.CreatesJoinRequest.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateChatInviteLink) {
					name = jsonFieldsNameOfCreateChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CreateNewStickerSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		if s.PNGSticker.Set {
			e.Comma()
		}
		if s.PNGSticker.Set {
			e.RawStr("\"png_sticker\"" + ":")
			s.PNGSticker.Encode(e)
		}
	}
	{
		if s.TgsSticker.Set {
			e.Comma()
		}
		if s.TgsSticker.Set {
			e.RawStr("\"tgs_sticker\"" + ":")
			s.TgsSticker.Encode(e)
		}
	}
	{
		if s.WebmSticker.Set {
			e.Comma()
		}
		if s.WebmSticker.Set {
			e.RawStr("\"webm_sticker\"" + ":")
			s.WebmSticker.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"emojis\"" + ":")
		e.Str(s.Emojis)
	}
	{
		if s.ContainsMasks.Set {
			e.Comma()
		}
		if s.ContainsMasks.Set {
			e.RawStr("\"contains_masks\"" + ":")
			s.ContainsMasks.Encode(e)
		}
	}
	{
		if s.MaskPosition.Set {
			e.Comma()
		}
		if s.MaskPosition.Set {
			e.RawStr("\"mask_position\"" + ":")
			s.MaskPosition.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCreateNewStickerSet = [9]string{
	0: "user_id",
	1: "name",
	2: "title",
	3: "png_sticker",
	4: "tgs_sticker",
	5: "webm_sticker",
	6: "emojis",
	7: "contains_masks",
	8: "mask_position",
}

// Decode decodes CreateNewStickerSet from json.
func (s *CreateNewStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CreateNewStickerSet to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "png_sticker":
			s.PNGSticker.Reset()
			if err := s.PNGSticker.Decode(d); err != nil {
				return err
			}
		case "tgs_sticker":
			s.TgsSticker.Reset()
			if err := s.TgsSticker.Decode(d); err != nil {
				return err
			}
		case "webm_sticker":
			s.WebmSticker.Reset()
			if err := s.WebmSticker.Decode(d); err != nil {
				return err
			}
		case "emojis":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Str()
			s.Emojis = string(v)
			if err != nil {
				return err
			}
		case "contains_masks":
			s.ContainsMasks.Reset()
			if err := s.ContainsMasks.Decode(d); err != nil {
				return err
			}
		case "mask_position":
			s.MaskPosition.Reset()
			if err := s.MaskPosition.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNewStickerSet) {
					name = jsonFieldsNameOfCreateNewStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s DeclineChatJoinRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDeclineChatJoinRequest = [2]string{
	0: "chat_id",
	1: "user_id",
}

// Decode decodes DeclineChatJoinRequest from json.
func (s *DeclineChatJoinRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeclineChatJoinRequest to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeclineChatJoinRequest) {
					name = jsonFieldsNameOfDeclineChatJoinRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s DeleteChatPhoto) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDeleteChatPhoto = [1]string{
	0: "chat_id",
}

// Decode decodes DeleteChatPhoto from json.
func (s *DeleteChatPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeleteChatPhoto to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteChatPhoto) {
					name = jsonFieldsNameOfDeleteChatPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s DeleteChatStickerSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDeleteChatStickerSet = [1]string{
	0: "chat_id",
}

// Decode decodes DeleteChatStickerSet from json.
func (s *DeleteChatStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeleteChatStickerSet to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteChatStickerSet) {
					name = jsonFieldsNameOfDeleteChatStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s DeleteMessage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"message_id\"" + ":")
		e.Int(s.MessageID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDeleteMessage = [2]string{
	0: "chat_id",
	1: "message_id",
}

// Decode decodes DeleteMessage from json.
func (s *DeleteMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeleteMessage to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int()
			s.MessageID = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteMessage) {
					name = jsonFieldsNameOfDeleteMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s DeleteMyCommands) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Scope.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Scope.Set {
			e.RawStr("\"scope\"" + ":")
			s.Scope.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LanguageCode.Set {
			e.RawStr("\"language_code\"" + ":")
			s.LanguageCode.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDeleteMyCommands = [2]string{
	0: "scope",
	1: "language_code",
}

// Decode decodes DeleteMyCommands from json.
func (s *DeleteMyCommands) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeleteMyCommands to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scope":
			s.Scope.Reset()
			if err := s.Scope.Decode(d); err != nil {
				return err
			}
		case "language_code":
			s.LanguageCode.Reset()
			if err := s.LanguageCode.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s DeleteStickerFromSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sticker\"" + ":")
		e.Str(s.Sticker)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDeleteStickerFromSet = [1]string{
	0: "sticker",
}

// Decode decodes DeleteStickerFromSet from json.
func (s *DeleteStickerFromSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeleteStickerFromSet to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sticker":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Sticker = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteStickerFromSet) {
					name = jsonFieldsNameOfDeleteStickerFromSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s DeleteWebhook) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DropPendingUpdates.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DropPendingUpdates.Set {
			e.RawStr("\"drop_pending_updates\"" + ":")
			s.DropPendingUpdates.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDeleteWebhook = [1]string{
	0: "drop_pending_updates",
}

// Decode decodes DeleteWebhook from json.
func (s *DeleteWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeleteWebhook to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "drop_pending_updates":
			s.DropPendingUpdates.Reset()
			if err := s.DropPendingUpdates.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Dice) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"emoji\"" + ":")
		e.Str(s.Emoji)
	}
	{
		e.Comma()

		e.RawStr("\"value\"" + ":")
		e.Int(s.Value)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDice = [2]string{
	0: "emoji",
	1: "value",
}

// Decode decodes Dice from json.
func (s *Dice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Dice to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "emoji":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Emoji = string(v)
			if err != nil {
				return err
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int()
			s.Value = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDice) {
					name = jsonFieldsNameOfDice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Document) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"file_id\"" + ":")
		e.Str(s.FileID)
	}
	{
		e.Comma()

		e.RawStr("\"file_unique_id\"" + ":")
		e.Str(s.FileUniqueID)
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.FileName.Set {
			e.Comma()
		}
		if s.FileName.Set {
			e.RawStr("\"file_name\"" + ":")
			s.FileName.Encode(e)
		}
	}
	{
		if s.MimeType.Set {
			e.Comma()
		}
		if s.MimeType.Set {
			e.RawStr("\"mime_type\"" + ":")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.Comma()
		}
		if s.FileSize.Set {
			e.RawStr("\"file_size\"" + ":")
			s.FileSize.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDocument = [6]string{
	0: "file_id",
	1: "file_unique_id",
	2: "thumb",
	3: "file_name",
	4: "mime_type",
	5: "file_size",
}

// Decode decodes Document from json.
func (s *Document) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Document to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "file_name":
			s.FileName.Reset()
			if err := s.FileName.Decode(d); err != nil {
				return err
			}
		case "mime_type":
			s.MimeType.Reset()
			if err := s.MimeType.Decode(d); err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDocument) {
					name = jsonFieldsNameOfDocument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EditChatInviteLink) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"invite_link\"" + ":")
		e.Str(s.InviteLink)
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.ExpireDate.Set {
			e.Comma()
		}
		if s.ExpireDate.Set {
			e.RawStr("\"expire_date\"" + ":")
			s.ExpireDate.Encode(e)
		}
	}
	{
		if s.MemberLimit.Set {
			e.Comma()
		}
		if s.MemberLimit.Set {
			e.RawStr("\"member_limit\"" + ":")
			s.MemberLimit.Encode(e)
		}
	}
	{
		if s.CreatesJoinRequest.Set {
			e.Comma()
		}
		if s.CreatesJoinRequest.Set {
			e.RawStr("\"creates_join_request\"" + ":")
			s.CreatesJoinRequest.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEditChatInviteLink = [6]string{
	0: "chat_id",
	1: "invite_link",
	2: "name",
	3: "expire_date",
	4: "member_limit",
	5: "creates_join_request",
}

// Decode decodes EditChatInviteLink from json.
func (s *EditChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EditChatInviteLink to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "invite_link":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.InviteLink = string(v)
			if err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "expire_date":
			s.ExpireDate.Reset()
			if err := s.ExpireDate.Decode(d); err != nil {
				return err
			}
		case "member_limit":
			s.MemberLimit.Reset()
			if err := s.MemberLimit.Decode(d); err != nil {
				return err
			}
		case "creates_join_request":
			s.CreatesJoinRequest.Reset()
			if err := s.CreatesJoinRequest.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditChatInviteLink) {
					name = jsonFieldsNameOfEditChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EditMessageCaption) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ChatID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ChatID.Set {
			e.RawStr("\"chat_id\"" + ":")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MessageID.Set {
			e.RawStr("\"message_id\"" + ":")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InlineMessageID.Set {
			e.RawStr("\"inline_message_id\"" + ":")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEditMessageCaption = [7]string{
	0: "chat_id",
	1: "message_id",
	2: "inline_message_id",
	3: "caption",
	4: "parse_mode",
	5: "caption_entities",
	6: "reply_markup",
}

// Decode decodes EditMessageCaption from json.
func (s *EditMessageCaption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EditMessageCaption to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			s.ChatID.Reset()
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EditMessageLiveLocation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ChatID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ChatID.Set {
			e.RawStr("\"chat_id\"" + ":")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MessageID.Set {
			e.RawStr("\"message_id\"" + ":")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InlineMessageID.Set {
			e.RawStr("\"inline_message_id\"" + ":")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"latitude\"" + ":")
		e.Float64(s.Latitude)
	}
	{
		e.Comma()

		e.RawStr("\"longitude\"" + ":")
		e.Float64(s.Longitude)
	}
	{
		if s.HorizontalAccuracy.Set {
			e.Comma()
		}
		if s.HorizontalAccuracy.Set {
			e.RawStr("\"horizontal_accuracy\"" + ":")
			s.HorizontalAccuracy.Encode(e)
		}
	}
	{
		if s.Heading.Set {
			e.Comma()
		}
		if s.Heading.Set {
			e.RawStr("\"heading\"" + ":")
			s.Heading.Encode(e)
		}
	}
	{
		if s.ProximityAlertRadius.Set {
			e.Comma()
		}
		if s.ProximityAlertRadius.Set {
			e.RawStr("\"proximity_alert_radius\"" + ":")
			s.ProximityAlertRadius.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEditMessageLiveLocation = [9]string{
	0: "chat_id",
	1: "message_id",
	2: "inline_message_id",
	3: "latitude",
	4: "longitude",
	5: "horizontal_accuracy",
	6: "heading",
	7: "proximity_alert_radius",
	8: "reply_markup",
}

// Decode decodes EditMessageLiveLocation from json.
func (s *EditMessageLiveLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EditMessageLiveLocation to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			s.ChatID.Reset()
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Float64()
			s.Latitude = float64(v)
			if err != nil {
				return err
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Float64()
			s.Longitude = float64(v)
			if err != nil {
				return err
			}
		case "horizontal_accuracy":
			s.HorizontalAccuracy.Reset()
			if err := s.HorizontalAccuracy.Decode(d); err != nil {
				return err
			}
		case "heading":
			s.Heading.Reset()
			if err := s.Heading.Decode(d); err != nil {
				return err
			}
		case "proximity_alert_radius":
			s.ProximityAlertRadius.Reset()
			if err := s.ProximityAlertRadius.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditMessageLiveLocation) {
					name = jsonFieldsNameOfEditMessageLiveLocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EditMessageMedia) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ChatID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ChatID.Set {
			e.RawStr("\"chat_id\"" + ":")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MessageID.Set {
			e.RawStr("\"message_id\"" + ":")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InlineMessageID.Set {
			e.RawStr("\"inline_message_id\"" + ":")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"media\"" + ":")
		s.Media.Encode(e)
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEditMessageMedia = [5]string{
	0: "chat_id",
	1: "message_id",
	2: "inline_message_id",
	3: "media",
	4: "reply_markup",
}

// Decode decodes EditMessageMedia from json.
func (s *EditMessageMedia) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EditMessageMedia to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			s.ChatID.Reset()
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		case "media":
			requiredBitSet[0] |= 1 << 3
			if err := s.Media.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditMessageMedia) {
					name = jsonFieldsNameOfEditMessageMedia[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EditMessageReplyMarkup) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ChatID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ChatID.Set {
			e.RawStr("\"chat_id\"" + ":")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MessageID.Set {
			e.RawStr("\"message_id\"" + ":")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InlineMessageID.Set {
			e.RawStr("\"inline_message_id\"" + ":")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEditMessageReplyMarkup = [4]string{
	0: "chat_id",
	1: "message_id",
	2: "inline_message_id",
	3: "reply_markup",
}

// Decode decodes EditMessageReplyMarkup from json.
func (s *EditMessageReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EditMessageReplyMarkup to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			s.ChatID.Reset()
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EditMessageText) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ChatID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ChatID.Set {
			e.RawStr("\"chat_id\"" + ":")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MessageID.Set {
			e.RawStr("\"message_id\"" + ":")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InlineMessageID.Set {
			e.RawStr("\"inline_message_id\"" + ":")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"text\"" + ":")
		e.Str(s.Text)
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.Entities != nil {
			e.Comma()
		}
		if s.Entities != nil {
			e.RawStr("\"entities\"" + ":")
			e.ArrStart()
			if len(s.Entities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Entities[0]
					elem.Encode(e)
				}
				for _, elem := range s.Entities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableWebPagePreview.Set {
			e.Comma()
		}
		if s.DisableWebPagePreview.Set {
			e.RawStr("\"disable_web_page_preview\"" + ":")
			s.DisableWebPagePreview.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEditMessageText = [8]string{
	0: "chat_id",
	1: "message_id",
	2: "inline_message_id",
	3: "text",
	4: "parse_mode",
	5: "entities",
	6: "disable_web_page_preview",
	7: "reply_markup",
}

// Decode decodes EditMessageText from json.
func (s *EditMessageText) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EditMessageText to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			s.ChatID.Reset()
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		case "text":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Text = string(v)
			if err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "entities":
			s.Entities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Entities = append(s.Entities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_web_page_preview":
			s.DisableWebPagePreview.Reset()
			if err := s.DisableWebPagePreview.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditMessageText) {
					name = jsonFieldsNameOfEditMessageText[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EncryptedCredentials) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"data\"" + ":")
		e.Str(s.Data)
	}
	{
		e.Comma()

		e.RawStr("\"hash\"" + ":")
		e.Str(s.Hash)
	}
	{
		e.Comma()

		e.RawStr("\"secret\"" + ":")
		e.Str(s.Secret)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEncryptedCredentials = [3]string{
	0: "data",
	1: "hash",
	2: "secret",
}

// Decode decodes EncryptedCredentials from json.
func (s *EncryptedCredentials) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EncryptedCredentials to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Data = string(v)
			if err != nil {
				return err
			}
		case "hash":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Hash = string(v)
			if err != nil {
				return err
			}
		case "secret":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Secret = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEncryptedCredentials) {
					name = jsonFieldsNameOfEncryptedCredentials[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EncryptedPassportElement) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		if s.Data.Set {
			e.Comma()
		}
		if s.Data.Set {
			e.RawStr("\"data\"" + ":")
			s.Data.Encode(e)
		}
	}
	{
		if s.PhoneNumber.Set {
			e.Comma()
		}
		if s.PhoneNumber.Set {
			e.RawStr("\"phone_number\"" + ":")
			s.PhoneNumber.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.Comma()
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Files != nil {
			e.Comma()
		}
		if s.Files != nil {
			e.RawStr("\"files\"" + ":")
			e.ArrStart()
			if len(s.Files) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Files[0]
					elem.Encode(e)
				}
				for _, elem := range s.Files[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.FrontSide.Set {
			e.Comma()
		}
		if s.FrontSide.Set {
			e.RawStr("\"front_side\"" + ":")
			s.FrontSide.Encode(e)
		}
	}
	{
		if s.ReverseSide.Set {
			e.Comma()
		}
		if s.ReverseSide.Set {
			e.RawStr("\"reverse_side\"" + ":")
			s.ReverseSide.Encode(e)
		}
	}
	{
		if s.Selfie.Set {
			e.Comma()
		}
		if s.Selfie.Set {
			e.RawStr("\"selfie\"" + ":")
			s.Selfie.Encode(e)
		}
	}
	{
		if s.Translation != nil {
			e.Comma()
		}
		if s.Translation != nil {
			e.RawStr("\"translation\"" + ":")
			e.ArrStart()
			if len(s.Translation) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Translation[0]
					elem.Encode(e)
				}
				for _, elem := range s.Translation[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"hash\"" + ":")
		e.Str(s.Hash)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEncryptedPassportElement = [10]string{
	0: "type",
	1: "data",
	2: "phone_number",
	3: "email",
	4: "files",
	5: "front_side",
	6: "reverse_side",
	7: "selfie",
	8: "translation",
	9: "hash",
}

// Decode decodes EncryptedPassportElement from json.
func (s *EncryptedPassportElement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EncryptedPassportElement to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "data":
			s.Data.Reset()
			if err := s.Data.Decode(d); err != nil {
				return err
			}
		case "phone_number":
			s.PhoneNumber.Reset()
			if err := s.PhoneNumber.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "files":
			s.Files = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PassportFile
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Files = append(s.Files, elem)
				return nil
			}); err != nil {
				return err
			}
		case "front_side":
			s.FrontSide.Reset()
			if err := s.FrontSide.Decode(d); err != nil {
				return err
			}
		case "reverse_side":
			s.ReverseSide.Reset()
			if err := s.ReverseSide.Decode(d); err != nil {
				return err
			}
		case "selfie":
			s.Selfie.Reset()
			if err := s.Selfie.Decode(d); err != nil {
				return err
			}
		case "translation":
			s.Translation = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PassportFile
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Translation = append(s.Translation, elem)
				return nil
			}); err != nil {
				return err
			}
		case "hash":
			requiredBitSet[1] |= 1 << 1
			v, err := d.Str()
			s.Hash = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEncryptedPassportElement) {
					name = jsonFieldsNameOfEncryptedPassportElement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes EncryptedPassportElementType as json.
func (s EncryptedPassportElementType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes EncryptedPassportElementType from json.
func (s *EncryptedPassportElementType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EncryptedPassportElementType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EncryptedPassportElementType(v) {
	case EncryptedPassportElementTypePersonalDetails:
		*s = EncryptedPassportElementTypePersonalDetails
	case EncryptedPassportElementTypePassport:
		*s = EncryptedPassportElementTypePassport
	case EncryptedPassportElementTypeDriverLicense:
		*s = EncryptedPassportElementTypeDriverLicense
	case EncryptedPassportElementTypeIdentityCard:
		*s = EncryptedPassportElementTypeIdentityCard
	case EncryptedPassportElementTypeInternalPassport:
		*s = EncryptedPassportElementTypeInternalPassport
	case EncryptedPassportElementTypeAddress:
		*s = EncryptedPassportElementTypeAddress
	case EncryptedPassportElementTypeUtilityBill:
		*s = EncryptedPassportElementTypeUtilityBill
	case EncryptedPassportElementTypeBankStatement:
		*s = EncryptedPassportElementTypeBankStatement
	case EncryptedPassportElementTypeRentalAgreement:
		*s = EncryptedPassportElementTypeRentalAgreement
	case EncryptedPassportElementTypePassportRegistration:
		*s = EncryptedPassportElementTypePassportRegistration
	case EncryptedPassportElementTypeTemporaryRegistration:
		*s = EncryptedPassportElementTypeTemporaryRegistration
	case EncryptedPassportElementTypePhoneNumber:
		*s = EncryptedPassportElementTypePhoneNumber
	case EncryptedPassportElementTypeEmail:
		*s = EncryptedPassportElementTypeEmail
	default:
		*s = EncryptedPassportElementType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Error) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	{
		e.Comma()

		e.RawStr("\"error_code\"" + ":")
		e.Int(s.ErrorCode)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		if s.Parameters.Set {
			e.Comma()
		}
		if s.Parameters.Set {
			e.RawStr("\"parameters\"" + ":")
			s.Parameters.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfError = [4]string{
	0: "ok",
	1: "error_code",
	2: "description",
	3: "parameters",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Error to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ok":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		case "error_code":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int()
			s.ErrorCode = int(v)
			if err != nil {
				return err
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "parameters":
			s.Parameters.Reset()
			if err := s.Parameters.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ExportChatInviteLink) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfExportChatInviteLink = [1]string{
	0: "chat_id",
}

// Decode decodes ExportChatInviteLink from json.
func (s *ExportChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ExportChatInviteLink to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExportChatInviteLink) {
					name = jsonFieldsNameOfExportChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s File) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"file_id\"" + ":")
		e.Str(s.FileID)
	}
	{
		e.Comma()

		e.RawStr("\"file_unique_id\"" + ":")
		e.Str(s.FileUniqueID)
	}
	{
		if s.FileSize.Set {
			e.Comma()
		}
		if s.FileSize.Set {
			e.RawStr("\"file_size\"" + ":")
			s.FileSize.Encode(e)
		}
	}
	{
		if s.FilePath.Set {
			e.Comma()
		}
		if s.FilePath.Set {
			e.RawStr("\"file_path\"" + ":")
			s.FilePath.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFile = [4]string{
	0: "file_id",
	1: "file_unique_id",
	2: "file_size",
	3: "file_path",
}

// Decode decodes File from json.
func (s *File) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode File to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		case "file_path":
			s.FilePath.Reset()
			if err := s.FilePath.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFile) {
					name = jsonFieldsNameOfFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ForceReply) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"force_reply\"" + ":")
		e.Bool(s.ForceReply)
	}
	{
		if s.InputFieldPlaceholder.Set {
			e.Comma()
		}
		if s.InputFieldPlaceholder.Set {
			e.RawStr("\"input_field_placeholder\"" + ":")
			s.InputFieldPlaceholder.Encode(e)
		}
	}
	{
		if s.Selective.Set {
			e.Comma()
		}
		if s.Selective.Set {
			e.RawStr("\"selective\"" + ":")
			s.Selective.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfForceReply = [3]string{
	0: "force_reply",
	1: "input_field_placeholder",
	2: "selective",
}

// Decode decodes ForceReply from json.
func (s *ForceReply) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ForceReply to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "force_reply":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Bool()
			s.ForceReply = bool(v)
			if err != nil {
				return err
			}
		case "input_field_placeholder":
			s.InputFieldPlaceholder.Reset()
			if err := s.InputFieldPlaceholder.Decode(d); err != nil {
				return err
			}
		case "selective":
			s.Selective.Reset()
			if err := s.Selective.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfForceReply) {
					name = jsonFieldsNameOfForceReply[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ForwardMessage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"from_chat_id\"" + ":")
		s.FromChatID.Encode(e)
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"message_id\"" + ":")
		e.Int(s.MessageID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfForwardMessage = [5]string{
	0: "chat_id",
	1: "from_chat_id",
	2: "disable_notification",
	3: "protect_content",
	4: "message_id",
}

// Decode decodes ForwardMessage from json.
func (s *ForwardMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ForwardMessage to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "from_chat_id":
			requiredBitSet[0] |= 1 << 1
			if err := s.FromChatID.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Int()
			s.MessageID = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfForwardMessage) {
					name = jsonFieldsNameOfForwardMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Game) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"photo\"" + ":")
		e.ArrStart()
		if len(s.Photo) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Photo[0]
				elem.Encode(e)
			}
			for _, elem := range s.Photo[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Text.Set {
			e.Comma()
		}
		if s.Text.Set {
			e.RawStr("\"text\"" + ":")
			s.Text.Encode(e)
		}
	}
	{
		if s.TextEntities != nil {
			e.Comma()
		}
		if s.TextEntities != nil {
			e.RawStr("\"text_entities\"" + ":")
			e.ArrStart()
			if len(s.TextEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TextEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.TextEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Animation.Set {
			e.Comma()
		}
		if s.Animation.Set {
			e.RawStr("\"animation\"" + ":")
			s.Animation.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGame = [6]string{
	0: "title",
	1: "description",
	2: "photo",
	3: "text",
	4: "text_entities",
	5: "animation",
}

// Decode decodes Game from json.
func (s *Game) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Game to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "photo":
			requiredBitSet[0] |= 1 << 2
			s.Photo = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PhotoSize
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Photo = append(s.Photo, elem)
				return nil
			}); err != nil {
				return err
			}
		case "text":
			s.Text.Reset()
			if err := s.Text.Decode(d); err != nil {
				return err
			}
		case "text_entities":
			s.TextEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.TextEntities = append(s.TextEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "animation":
			s.Animation.Reset()
			if err := s.Animation.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGame) {
					name = jsonFieldsNameOfGame[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GameHighScore) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"position\"" + ":")
		e.Int(s.Position)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"score\"" + ":")
		e.Int(s.Score)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGameHighScore = [3]string{
	0: "position",
	1: "user",
	2: "score",
}

// Decode decodes GameHighScore from json.
func (s *GameHighScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GameHighScore to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "position":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.Position = int(v)
			if err != nil {
				return err
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "score":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.Score = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGameHighScore) {
					name = jsonFieldsNameOfGameHighScore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetChat) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGetChat = [1]string{
	0: "chat_id",
}

// Decode decodes GetChat from json.
func (s *GetChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetChat to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetChat) {
					name = jsonFieldsNameOfGetChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetChatAdministrators) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGetChatAdministrators = [1]string{
	0: "chat_id",
}

// Decode decodes GetChatAdministrators from json.
func (s *GetChatAdministrators) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetChatAdministrators to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetChatAdministrators) {
					name = jsonFieldsNameOfGetChatAdministrators[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetChatMember) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGetChatMember = [2]string{
	0: "chat_id",
	1: "user_id",
}

// Decode decodes GetChatMember from json.
func (s *GetChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetChatMember to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetChatMember) {
					name = jsonFieldsNameOfGetChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetChatMemberCount) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGetChatMemberCount = [1]string{
	0: "chat_id",
}

// Decode decodes GetChatMemberCount from json.
func (s *GetChatMemberCount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetChatMemberCount to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetChatMemberCount) {
					name = jsonFieldsNameOfGetChatMemberCount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetFile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"file_id\"" + ":")
		e.Str(s.FileID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGetFile = [1]string{
	0: "file_id",
}

// Decode decodes GetFile from json.
func (s *GetFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetFile to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetFile) {
					name = jsonFieldsNameOfGetFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetGameHighScores) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	{
		if s.ChatID.Set {
			e.Comma()
		}
		if s.ChatID.Set {
			e.RawStr("\"chat_id\"" + ":")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.Comma()
		}
		if s.MessageID.Set {
			e.RawStr("\"message_id\"" + ":")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.Comma()
		}
		if s.InlineMessageID.Set {
			e.RawStr("\"inline_message_id\"" + ":")
			s.InlineMessageID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGetGameHighScores = [4]string{
	0: "user_id",
	1: "chat_id",
	2: "message_id",
	3: "inline_message_id",
}

// Decode decodes GetGameHighScores from json.
func (s *GetGameHighScores) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetGameHighScores to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		case "chat_id":
			s.ChatID.Reset()
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetGameHighScores) {
					name = jsonFieldsNameOfGetGameHighScores[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetMyCommands) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Scope.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Scope.Set {
			e.RawStr("\"scope\"" + ":")
			s.Scope.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LanguageCode.Set {
			e.RawStr("\"language_code\"" + ":")
			s.LanguageCode.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGetMyCommands = [2]string{
	0: "scope",
	1: "language_code",
}

// Decode decodes GetMyCommands from json.
func (s *GetMyCommands) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetMyCommands to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scope":
			s.Scope.Reset()
			if err := s.Scope.Decode(d); err != nil {
				return err
			}
		case "language_code":
			s.LanguageCode.Reset()
			if err := s.LanguageCode.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetStickerSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGetStickerSet = [1]string{
	0: "name",
}

// Decode decodes GetStickerSet from json.
func (s *GetStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetStickerSet to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStickerSet) {
					name = jsonFieldsNameOfGetStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetUpdates) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Offset.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Offset.Set {
			e.RawStr("\"offset\"" + ":")
			s.Offset.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Limit.Set {
			e.RawStr("\"limit\"" + ":")
			s.Limit.Encode(e)
		}
	}
	{
		if s.Timeout.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Timeout.Set {
			e.RawStr("\"timeout\"" + ":")
			s.Timeout.Encode(e)
		}
	}
	{
		if s.AllowedUpdates != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowedUpdates != nil {
			e.RawStr("\"allowed_updates\"" + ":")
			e.ArrStart()
			if len(s.AllowedUpdates) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedUpdates[0]
					e.Str(elem)
				}
				for _, elem := range s.AllowedUpdates[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGetUpdates = [4]string{
	0: "offset",
	1: "limit",
	2: "timeout",
	3: "allowed_updates",
}

// Decode decodes GetUpdates from json.
func (s *GetUpdates) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetUpdates to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "offset":
			s.Offset.Reset()
			if err := s.Offset.Decode(d); err != nil {
				return err
			}
		case "limit":
			s.Limit.Reset()
			if err := s.Limit.Decode(d); err != nil {
				return err
			}
		case "timeout":
			s.Timeout.Reset()
			if err := s.Timeout.Decode(d); err != nil {
				return err
			}
		case "allowed_updates":
			s.AllowedUpdates = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AllowedUpdates = append(s.AllowedUpdates, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GetUserProfilePhotos) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	{
		if s.Offset.Set {
			e.Comma()
		}
		if s.Offset.Set {
			e.RawStr("\"offset\"" + ":")
			s.Offset.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			e.Comma()
		}
		if s.Limit.Set {
			e.RawStr("\"limit\"" + ":")
			s.Limit.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGetUserProfilePhotos = [3]string{
	0: "user_id",
	1: "offset",
	2: "limit",
}

// Decode decodes GetUserProfilePhotos from json.
func (s *GetUserProfilePhotos) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GetUserProfilePhotos to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		case "offset":
			s.Offset.Reset()
			if err := s.Offset.Decode(d); err != nil {
				return err
			}
		case "limit":
			s.Limit.Reset()
			if err := s.Limit.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserProfilePhotos) {
					name = jsonFieldsNameOfGetUserProfilePhotos[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ID as json.
func (s ID) Encode(e *jx.Writer) {
	switch s.Type {
	case StringID:
		e.Str(s.String)
	case Int64ID:
		e.Int64(s.Int64)
	}
}

// Decode decodes ID from json.
func (s *ID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ID to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringID
	case jx.Number:
		v, err := d.Int64()
		s.Int64 = int64(v)
		if err != nil {
			return err
		}
		s.Type = Int64ID
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s InlineKeyboardButton) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"text\"" + ":")
		e.Str(s.Text)
	}
	{
		if s.URL.Set {
			e.Comma()
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.LoginURL.Set {
			e.Comma()
		}
		if s.LoginURL.Set {
			e.RawStr("\"login_url\"" + ":")
			s.LoginURL.Encode(e)
		}
	}
	{
		if s.CallbackData.Set {
			e.Comma()
		}
		if s.CallbackData.Set {
			e.RawStr("\"callback_data\"" + ":")
			s.CallbackData.Encode(e)
		}
	}
	{
		if s.SwitchInlineQuery.Set {
			e.Comma()
		}
		if s.SwitchInlineQuery.Set {
			e.RawStr("\"switch_inline_query\"" + ":")
			s.SwitchInlineQuery.Encode(e)
		}
	}
	{
		if s.SwitchInlineQueryCurrentChat.Set {
			e.Comma()
		}
		if s.SwitchInlineQueryCurrentChat.Set {
			e.RawStr("\"switch_inline_query_current_chat\"" + ":")
			s.SwitchInlineQueryCurrentChat.Encode(e)
		}
	}
	{
		if s.CallbackGame != nil {
			e.Comma()
		}
		if s.CallbackGame != nil {
			e.RawStr("\"callback_game\"" + ":")
			s.CallbackGame.Encode(e)
		}
	}
	{
		if s.Pay.Set {
			e.Comma()
		}
		if s.Pay.Set {
			e.RawStr("\"pay\"" + ":")
			s.Pay.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineKeyboardButton = [8]string{
	0: "text",
	1: "url",
	2: "login_url",
	3: "callback_data",
	4: "switch_inline_query",
	5: "switch_inline_query_current_chat",
	6: "callback_game",
	7: "pay",
}

// Decode decodes InlineKeyboardButton from json.
func (s *InlineKeyboardButton) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineKeyboardButton to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Text = string(v)
			if err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "login_url":
			s.LoginURL.Reset()
			if err := s.LoginURL.Decode(d); err != nil {
				return err
			}
		case "callback_data":
			s.CallbackData.Reset()
			if err := s.CallbackData.Decode(d); err != nil {
				return err
			}
		case "switch_inline_query":
			s.SwitchInlineQuery.Reset()
			if err := s.SwitchInlineQuery.Decode(d); err != nil {
				return err
			}
		case "switch_inline_query_current_chat":
			s.SwitchInlineQueryCurrentChat.Reset()
			if err := s.SwitchInlineQueryCurrentChat.Decode(d); err != nil {
				return err
			}
		case "callback_game":
			s.CallbackGame = nil
			var elem CallbackGame
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.CallbackGame = &elem
		case "pay":
			s.Pay.Reset()
			if err := s.Pay.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineKeyboardButton) {
					name = jsonFieldsNameOfInlineKeyboardButton[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineKeyboardMarkup) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"inline_keyboard\"" + ":")
		e.ArrStart()
		if len(s.InlineKeyboard) >= 1 {
			// Encode first element without comma.
			{
				elem := s.InlineKeyboard[0]
				e.ArrStart()
				if len(elem) >= 1 {
					// Encode first element without comma.
					{
						elem := elem[0]
						elem.Encode(e)
					}
					for _, elem := range elem[1:] {
						e.Comma()
						elem.Encode(e)
					}
				}
				e.ArrEnd()
			}
			for _, elem := range s.InlineKeyboard[1:] {
				e.Comma()
				e.ArrStart()
				if len(elem) >= 1 {
					// Encode first element without comma.
					{
						elem := elem[0]
						elem.Encode(e)
					}
					for _, elem := range elem[1:] {
						e.Comma()
						elem.Encode(e)
					}
				}
				e.ArrEnd()
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineKeyboardMarkup = [1]string{
	0: "inline_keyboard",
}

// Decode decodes InlineKeyboardMarkup from json.
func (s *InlineKeyboardMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineKeyboardMarkup to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inline_keyboard":
			requiredBitSet[0] |= 1 << 0
			s.InlineKeyboard = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []InlineKeyboardButton
				elem = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem InlineKeyboardButton
					if err := elemElem.Decode(d); err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				s.InlineKeyboard = append(s.InlineKeyboard, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineKeyboardMarkup) {
					name = jsonFieldsNameOfInlineKeyboardMarkup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQuery) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"from\"" + ":")
		s.From.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"query\"" + ":")
		e.Str(s.Query)
	}
	{
		e.Comma()

		e.RawStr("\"offset\"" + ":")
		e.Str(s.Offset)
	}
	{
		if s.ChatType.Set {
			e.Comma()
		}
		if s.ChatType.Set {
			e.RawStr("\"chat_type\"" + ":")
			s.ChatType.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.Comma()
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQuery = [6]string{
	0: "id",
	1: "from",
	2: "query",
	3: "offset",
	4: "chat_type",
	5: "location",
}

// Decode decodes InlineQuery from json.
func (s *InlineQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQuery to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := s.From.Decode(d); err != nil {
				return err
			}
		case "query":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Query = string(v)
			if err != nil {
				return err
			}
		case "offset":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Offset = string(v)
			if err != nil {
				return err
			}
		case "chat_type":
			s.ChatType.Reset()
			if err := s.ChatType.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQuery) {
					name = jsonFieldsNameOfInlineQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes InlineQueryChatType as json.
func (s InlineQueryChatType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes InlineQueryChatType from json.
func (s *InlineQueryChatType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryChatType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InlineQueryChatType(v) {
	case InlineQueryChatTypeSender:
		*s = InlineQueryChatTypeSender
	case InlineQueryChatTypePrivate:
		*s = InlineQueryChatTypePrivate
	case InlineQueryChatTypeGroup:
		*s = InlineQueryChatTypeGroup
	case InlineQueryChatTypeSupergroup:
		*s = InlineQueryChatTypeSupergroup
	case InlineQueryChatTypeChannel:
		*s = InlineQueryChatTypeChannel
	default:
		*s = InlineQueryChatType(v)
	}

	return nil
}

// Encode encodes InlineQueryResult as json.
func (s InlineQueryResult) Encode(e *jx.Writer) {
	switch s.Type {
	case InlineQueryResultCachedAudioInlineQueryResult:
		s.InlineQueryResultCachedAudio.Encode(e)
	case InlineQueryResultCachedDocumentInlineQueryResult:
		s.InlineQueryResultCachedDocument.Encode(e)
	case InlineQueryResultCachedGifInlineQueryResult:
		s.InlineQueryResultCachedGif.Encode(e)
	case InlineQueryResultCachedMpeg4GifInlineQueryResult:
		s.InlineQueryResultCachedMpeg4Gif.Encode(e)
	case InlineQueryResultCachedPhotoInlineQueryResult:
		s.InlineQueryResultCachedPhoto.Encode(e)
	case InlineQueryResultCachedStickerInlineQueryResult:
		s.InlineQueryResultCachedSticker.Encode(e)
	case InlineQueryResultCachedVideoInlineQueryResult:
		s.InlineQueryResultCachedVideo.Encode(e)
	case InlineQueryResultCachedVoiceInlineQueryResult:
		s.InlineQueryResultCachedVoice.Encode(e)
	case InlineQueryResultArticleInlineQueryResult:
		s.InlineQueryResultArticle.Encode(e)
	case InlineQueryResultAudioInlineQueryResult:
		s.InlineQueryResultAudio.Encode(e)
	case InlineQueryResultContactInlineQueryResult:
		s.InlineQueryResultContact.Encode(e)
	case InlineQueryResultGameInlineQueryResult:
		s.InlineQueryResultGame.Encode(e)
	case InlineQueryResultDocumentInlineQueryResult:
		s.InlineQueryResultDocument.Encode(e)
	case InlineQueryResultGifInlineQueryResult:
		s.InlineQueryResultGif.Encode(e)
	case InlineQueryResultLocationInlineQueryResult:
		s.InlineQueryResultLocation.Encode(e)
	case InlineQueryResultMpeg4GifInlineQueryResult:
		s.InlineQueryResultMpeg4Gif.Encode(e)
	case InlineQueryResultPhotoInlineQueryResult:
		s.InlineQueryResultPhoto.Encode(e)
	case InlineQueryResultVenueInlineQueryResult:
		s.InlineQueryResultVenue.Encode(e)
	case InlineQueryResultVideoInlineQueryResult:
		s.InlineQueryResultVideo.Encode(e)
	case InlineQueryResultVoiceInlineQueryResult:
		s.InlineQueryResultVoice.Encode(e)
	}
}

// Decode decodes InlineQueryResult from json.
func (s *InlineQueryResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResult to nil`)
	}
	// Sum type discriminator.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "article":
					s.Type = InlineQueryResultArticleInlineQueryResult
					found = true
				case "audio":
					s.Type = InlineQueryResultAudioInlineQueryResult
					found = true
				case "contact":
					s.Type = InlineQueryResultContactInlineQueryResult
					found = true
				case "document":
					s.Type = InlineQueryResultDocumentInlineQueryResult
					found = true
				case "game":
					s.Type = InlineQueryResultGameInlineQueryResult
					found = true
				case "gif":
					s.Type = InlineQueryResultGifInlineQueryResult
					found = true
				case "location":
					s.Type = InlineQueryResultLocationInlineQueryResult
					found = true
				case "mpeg4_gif":
					s.Type = InlineQueryResultMpeg4GifInlineQueryResult
					found = true
				case "photo":
					s.Type = InlineQueryResultPhotoInlineQueryResult
					found = true
				case "sticker":
					s.Type = InlineQueryResultCachedStickerInlineQueryResult
					found = true
				case "venue":
					s.Type = InlineQueryResultVenueInlineQueryResult
					found = true
				case "video":
					s.Type = InlineQueryResultVideoInlineQueryResult
					found = true
				case "voice":
					s.Type = InlineQueryResultVoiceInlineQueryResult
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineQueryResultCachedAudioInlineQueryResult:
		if err := s.InlineQueryResultCachedAudio.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedDocumentInlineQueryResult:
		if err := s.InlineQueryResultCachedDocument.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedGifInlineQueryResult:
		if err := s.InlineQueryResultCachedGif.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedMpeg4GifInlineQueryResult:
		if err := s.InlineQueryResultCachedMpeg4Gif.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedPhotoInlineQueryResult:
		if err := s.InlineQueryResultCachedPhoto.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedStickerInlineQueryResult:
		if err := s.InlineQueryResultCachedSticker.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedVideoInlineQueryResult:
		if err := s.InlineQueryResultCachedVideo.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultCachedVoiceInlineQueryResult:
		if err := s.InlineQueryResultCachedVoice.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultArticleInlineQueryResult:
		if err := s.InlineQueryResultArticle.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultAudioInlineQueryResult:
		if err := s.InlineQueryResultAudio.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultContactInlineQueryResult:
		if err := s.InlineQueryResultContact.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultGameInlineQueryResult:
		if err := s.InlineQueryResultGame.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultDocumentInlineQueryResult:
		if err := s.InlineQueryResultDocument.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultGifInlineQueryResult:
		if err := s.InlineQueryResultGif.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultLocationInlineQueryResult:
		if err := s.InlineQueryResultLocation.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultMpeg4GifInlineQueryResult:
		if err := s.InlineQueryResultMpeg4Gif.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultPhotoInlineQueryResult:
		if err := s.InlineQueryResultPhoto.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultVenueInlineQueryResult:
		if err := s.InlineQueryResultVenue.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultVideoInlineQueryResult:
		if err := s.InlineQueryResultVideo.Decode(d); err != nil {
			return err
		}
	case InlineQueryResultVoiceInlineQueryResult:
		if err := s.InlineQueryResultVoice.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultArticle) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"input_message_content\"" + ":")
		s.InputMessageContent.Encode(e)
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.Comma()
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HideURL.Set {
			e.Comma()
		}
		if s.HideURL.Set {
			e.RawStr("\"hide_url\"" + ":")
			s.HideURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.ThumbURL.Set {
			e.Comma()
		}
		if s.ThumbURL.Set {
			e.RawStr("\"thumb_url\"" + ":")
			s.ThumbURL.Encode(e)
		}
	}
	{
		if s.ThumbWidth.Set {
			e.Comma()
		}
		if s.ThumbWidth.Set {
			e.RawStr("\"thumb_width\"" + ":")
			s.ThumbWidth.Encode(e)
		}
	}
	{
		if s.ThumbHeight.Set {
			e.Comma()
		}
		if s.ThumbHeight.Set {
			e.RawStr("\"thumb_height\"" + ":")
			s.ThumbHeight.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultArticle = [11]string{
	0:  "type",
	1:  "id",
	2:  "title",
	3:  "input_message_content",
	4:  "reply_markup",
	5:  "url",
	6:  "hide_url",
	7:  "description",
	8:  "thumb_url",
	9:  "thumb_width",
	10: "thumb_height",
}

// Decode decodes InlineQueryResultArticle from json.
func (s *InlineQueryResultArticle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultArticle to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "input_message_content":
			requiredBitSet[0] |= 1 << 3
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "hide_url":
			s.HideURL.Reset()
			if err := s.HideURL.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "thumb_url":
			s.ThumbURL.Reset()
			if err := s.ThumbURL.Decode(d); err != nil {
				return err
			}
		case "thumb_width":
			s.ThumbWidth.Reset()
			if err := s.ThumbWidth.Decode(d); err != nil {
				return err
			}
		case "thumb_height":
			s.ThumbHeight.Reset()
			if err := s.ThumbHeight.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultArticle) {
					name = jsonFieldsNameOfInlineQueryResultArticle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultAudio) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"audio_url\"" + ":")
		e.Str(s.AudioURL)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Performer.Set {
			e.Comma()
		}
		if s.Performer.Set {
			e.RawStr("\"performer\"" + ":")
			s.Performer.Encode(e)
		}
	}
	{
		if s.AudioDuration.Set {
			e.Comma()
		}
		if s.AudioDuration.Set {
			e.RawStr("\"audio_duration\"" + ":")
			s.AudioDuration.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultAudio = [11]string{
	0:  "type",
	1:  "id",
	2:  "audio_url",
	3:  "title",
	4:  "caption",
	5:  "parse_mode",
	6:  "caption_entities",
	7:  "performer",
	8:  "audio_duration",
	9:  "reply_markup",
	10: "input_message_content",
}

// Decode decodes InlineQueryResultAudio from json.
func (s *InlineQueryResultAudio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultAudio to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "audio_url":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.AudioURL = string(v)
			if err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "performer":
			s.Performer.Reset()
			if err := s.Performer.Decode(d); err != nil {
				return err
			}
		case "audio_duration":
			s.AudioDuration.Reset()
			if err := s.AudioDuration.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultAudio) {
					name = jsonFieldsNameOfInlineQueryResultAudio[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultCachedAudio) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"audio_file_id\"" + ":")
		e.Str(s.AudioFileID)
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultCachedAudio = [8]string{
	0: "type",
	1: "id",
	2: "audio_file_id",
	3: "caption",
	4: "parse_mode",
	5: "caption_entities",
	6: "reply_markup",
	7: "input_message_content",
}

// Decode decodes InlineQueryResultCachedAudio from json.
func (s *InlineQueryResultCachedAudio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultCachedAudio to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "audio_file_id":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.AudioFileID = string(v)
			if err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedAudio) {
					name = jsonFieldsNameOfInlineQueryResultCachedAudio[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultCachedDocument) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"document_file_id\"" + ":")
		e.Str(s.DocumentFileID)
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultCachedDocument = [10]string{
	0: "type",
	1: "id",
	2: "title",
	3: "document_file_id",
	4: "description",
	5: "caption",
	6: "parse_mode",
	7: "caption_entities",
	8: "reply_markup",
	9: "input_message_content",
}

// Decode decodes InlineQueryResultCachedDocument from json.
func (s *InlineQueryResultCachedDocument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultCachedDocument to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "document_file_id":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.DocumentFileID = string(v)
			if err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedDocument) {
					name = jsonFieldsNameOfInlineQueryResultCachedDocument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultCachedGif) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"gif_file_id\"" + ":")
		e.Str(s.GIFFileID)
	}
	{
		if s.Title.Set {
			e.Comma()
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultCachedGif = [9]string{
	0: "type",
	1: "id",
	2: "gif_file_id",
	3: "title",
	4: "caption",
	5: "parse_mode",
	6: "caption_entities",
	7: "reply_markup",
	8: "input_message_content",
}

// Decode decodes InlineQueryResultCachedGif from json.
func (s *InlineQueryResultCachedGif) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultCachedGif to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "gif_file_id":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.GIFFileID = string(v)
			if err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedGif) {
					name = jsonFieldsNameOfInlineQueryResultCachedGif[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultCachedMpeg4Gif) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"mpeg4_file_id\"" + ":")
		e.Str(s.Mpeg4FileID)
	}
	{
		if s.Title.Set {
			e.Comma()
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultCachedMpeg4Gif = [9]string{
	0: "type",
	1: "id",
	2: "mpeg4_file_id",
	3: "title",
	4: "caption",
	5: "parse_mode",
	6: "caption_entities",
	7: "reply_markup",
	8: "input_message_content",
}

// Decode decodes InlineQueryResultCachedMpeg4Gif from json.
func (s *InlineQueryResultCachedMpeg4Gif) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultCachedMpeg4Gif to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "mpeg4_file_id":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Mpeg4FileID = string(v)
			if err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedMpeg4Gif) {
					name = jsonFieldsNameOfInlineQueryResultCachedMpeg4Gif[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultCachedPhoto) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"photo_file_id\"" + ":")
		e.Str(s.PhotoFileID)
	}
	{
		if s.Title.Set {
			e.Comma()
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultCachedPhoto = [10]string{
	0: "type",
	1: "id",
	2: "photo_file_id",
	3: "title",
	4: "description",
	5: "caption",
	6: "parse_mode",
	7: "caption_entities",
	8: "reply_markup",
	9: "input_message_content",
}

// Decode decodes InlineQueryResultCachedPhoto from json.
func (s *InlineQueryResultCachedPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultCachedPhoto to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "photo_file_id":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.PhotoFileID = string(v)
			if err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedPhoto) {
					name = jsonFieldsNameOfInlineQueryResultCachedPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultCachedSticker) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"sticker_file_id\"" + ":")
		e.Str(s.StickerFileID)
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultCachedSticker = [5]string{
	0: "type",
	1: "id",
	2: "sticker_file_id",
	3: "reply_markup",
	4: "input_message_content",
}

// Decode decodes InlineQueryResultCachedSticker from json.
func (s *InlineQueryResultCachedSticker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultCachedSticker to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "sticker_file_id":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.StickerFileID = string(v)
			if err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedSticker) {
					name = jsonFieldsNameOfInlineQueryResultCachedSticker[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultCachedVideo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"video_file_id\"" + ":")
		e.Str(s.VideoFileID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultCachedVideo = [10]string{
	0: "type",
	1: "id",
	2: "video_file_id",
	3: "title",
	4: "description",
	5: "caption",
	6: "parse_mode",
	7: "caption_entities",
	8: "reply_markup",
	9: "input_message_content",
}

// Decode decodes InlineQueryResultCachedVideo from json.
func (s *InlineQueryResultCachedVideo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultCachedVideo to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "video_file_id":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.VideoFileID = string(v)
			if err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedVideo) {
					name = jsonFieldsNameOfInlineQueryResultCachedVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultCachedVoice) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"voice_file_id\"" + ":")
		e.Str(s.VoiceFileID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultCachedVoice = [9]string{
	0: "type",
	1: "id",
	2: "voice_file_id",
	3: "title",
	4: "caption",
	5: "parse_mode",
	6: "caption_entities",
	7: "reply_markup",
	8: "input_message_content",
}

// Decode decodes InlineQueryResultCachedVoice from json.
func (s *InlineQueryResultCachedVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultCachedVoice to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "voice_file_id":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.VoiceFileID = string(v)
			if err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultCachedVoice) {
					name = jsonFieldsNameOfInlineQueryResultCachedVoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultContact) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"phone_number\"" + ":")
		e.Str(s.PhoneNumber)
	}
	{
		e.Comma()

		e.RawStr("\"first_name\"" + ":")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.Comma()
		}
		if s.LastName.Set {
			e.RawStr("\"last_name\"" + ":")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Vcard.Set {
			e.Comma()
		}
		if s.Vcard.Set {
			e.RawStr("\"vcard\"" + ":")
			s.Vcard.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	{
		if s.ThumbURL.Set {
			e.Comma()
		}
		if s.ThumbURL.Set {
			e.RawStr("\"thumb_url\"" + ":")
			s.ThumbURL.Encode(e)
		}
	}
	{
		if s.ThumbWidth.Set {
			e.Comma()
		}
		if s.ThumbWidth.Set {
			e.RawStr("\"thumb_width\"" + ":")
			s.ThumbWidth.Encode(e)
		}
	}
	{
		if s.ThumbHeight.Set {
			e.Comma()
		}
		if s.ThumbHeight.Set {
			e.RawStr("\"thumb_height\"" + ":")
			s.ThumbHeight.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultContact = [11]string{
	0:  "type",
	1:  "id",
	2:  "phone_number",
	3:  "first_name",
	4:  "last_name",
	5:  "vcard",
	6:  "reply_markup",
	7:  "input_message_content",
	8:  "thumb_url",
	9:  "thumb_width",
	10: "thumb_height",
}

// Decode decodes InlineQueryResultContact from json.
func (s *InlineQueryResultContact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultContact to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "phone_number":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.PhoneNumber = string(v)
			if err != nil {
				return err
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.FirstName = string(v)
			if err != nil {
				return err
			}
		case "last_name":
			s.LastName.Reset()
			if err := s.LastName.Decode(d); err != nil {
				return err
			}
		case "vcard":
			s.Vcard.Reset()
			if err := s.Vcard.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		case "thumb_url":
			s.ThumbURL.Reset()
			if err := s.ThumbURL.Decode(d); err != nil {
				return err
			}
		case "thumb_width":
			s.ThumbWidth.Reset()
			if err := s.ThumbWidth.Decode(d); err != nil {
				return err
			}
		case "thumb_height":
			s.ThumbHeight.Reset()
			if err := s.ThumbHeight.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultContact) {
					name = jsonFieldsNameOfInlineQueryResultContact[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultDocument) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"document_url\"" + ":")
		e.Str(s.DocumentURL)
	}
	{
		e.Comma()

		e.RawStr("\"mime_type\"" + ":")
		e.Str(s.MimeType)
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	{
		if s.ThumbURL.Set {
			e.Comma()
		}
		if s.ThumbURL.Set {
			e.RawStr("\"thumb_url\"" + ":")
			s.ThumbURL.Encode(e)
		}
	}
	{
		if s.ThumbWidth.Set {
			e.Comma()
		}
		if s.ThumbWidth.Set {
			e.RawStr("\"thumb_width\"" + ":")
			s.ThumbWidth.Encode(e)
		}
	}
	{
		if s.ThumbHeight.Set {
			e.Comma()
		}
		if s.ThumbHeight.Set {
			e.RawStr("\"thumb_height\"" + ":")
			s.ThumbHeight.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultDocument = [14]string{
	0:  "type",
	1:  "id",
	2:  "title",
	3:  "caption",
	4:  "parse_mode",
	5:  "caption_entities",
	6:  "document_url",
	7:  "mime_type",
	8:  "description",
	9:  "reply_markup",
	10: "input_message_content",
	11: "thumb_url",
	12: "thumb_width",
	13: "thumb_height",
}

// Decode decodes InlineQueryResultDocument from json.
func (s *InlineQueryResultDocument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultDocument to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "document_url":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Str()
			s.DocumentURL = string(v)
			if err != nil {
				return err
			}
		case "mime_type":
			requiredBitSet[0] |= 1 << 7
			v, err := d.Str()
			s.MimeType = string(v)
			if err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		case "thumb_url":
			s.ThumbURL.Reset()
			if err := s.ThumbURL.Decode(d); err != nil {
				return err
			}
		case "thumb_width":
			s.ThumbWidth.Reset()
			if err := s.ThumbWidth.Decode(d); err != nil {
				return err
			}
		case "thumb_height":
			s.ThumbHeight.Reset()
			if err := s.ThumbHeight.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultDocument) {
					name = jsonFieldsNameOfInlineQueryResultDocument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultGame) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"game_short_name\"" + ":")
		e.Str(s.GameShortName)
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultGame = [4]string{
	0: "type",
	1: "id",
	2: "game_short_name",
	3: "reply_markup",
}

// Decode decodes InlineQueryResultGame from json.
func (s *InlineQueryResultGame) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultGame to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "game_short_name":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.GameShortName = string(v)
			if err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultGame) {
					name = jsonFieldsNameOfInlineQueryResultGame[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultGif) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"gif_url\"" + ":")
		e.Str(s.GIFURL)
	}
	{
		if s.GIFWidth.Set {
			e.Comma()
		}
		if s.GIFWidth.Set {
			e.RawStr("\"gif_width\"" + ":")
			s.GIFWidth.Encode(e)
		}
	}
	{
		if s.GIFHeight.Set {
			e.Comma()
		}
		if s.GIFHeight.Set {
			e.RawStr("\"gif_height\"" + ":")
			s.GIFHeight.Encode(e)
		}
	}
	{
		if s.GIFDuration.Set {
			e.Comma()
		}
		if s.GIFDuration.Set {
			e.RawStr("\"gif_duration\"" + ":")
			s.GIFDuration.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"thumb_url\"" + ":")
		e.Str(s.ThumbURL)
	}
	{
		if s.ThumbMimeType.Set {
			e.Comma()
		}
		if s.ThumbMimeType.Set {
			e.RawStr("\"thumb_mime_type\"" + ":")
			s.ThumbMimeType.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.Comma()
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultGif = [14]string{
	0:  "type",
	1:  "id",
	2:  "gif_url",
	3:  "gif_width",
	4:  "gif_height",
	5:  "gif_duration",
	6:  "thumb_url",
	7:  "thumb_mime_type",
	8:  "title",
	9:  "caption",
	10: "parse_mode",
	11: "caption_entities",
	12: "reply_markup",
	13: "input_message_content",
}

// Decode decodes InlineQueryResultGif from json.
func (s *InlineQueryResultGif) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultGif to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "gif_url":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.GIFURL = string(v)
			if err != nil {
				return err
			}
		case "gif_width":
			s.GIFWidth.Reset()
			if err := s.GIFWidth.Decode(d); err != nil {
				return err
			}
		case "gif_height":
			s.GIFHeight.Reset()
			if err := s.GIFHeight.Decode(d); err != nil {
				return err
			}
		case "gif_duration":
			s.GIFDuration.Reset()
			if err := s.GIFDuration.Decode(d); err != nil {
				return err
			}
		case "thumb_url":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Str()
			s.ThumbURL = string(v)
			if err != nil {
				return err
			}
		case "thumb_mime_type":
			s.ThumbMimeType.Reset()
			if err := s.ThumbMimeType.Decode(d); err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultGif) {
					name = jsonFieldsNameOfInlineQueryResultGif[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultLocation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"latitude\"" + ":")
		e.Float64(s.Latitude)
	}
	{
		e.Comma()

		e.RawStr("\"longitude\"" + ":")
		e.Float64(s.Longitude)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		if s.HorizontalAccuracy.Set {
			e.Comma()
		}
		if s.HorizontalAccuracy.Set {
			e.RawStr("\"horizontal_accuracy\"" + ":")
			s.HorizontalAccuracy.Encode(e)
		}
	}
	{
		if s.LivePeriod.Set {
			e.Comma()
		}
		if s.LivePeriod.Set {
			e.RawStr("\"live_period\"" + ":")
			s.LivePeriod.Encode(e)
		}
	}
	{
		if s.Heading.Set {
			e.Comma()
		}
		if s.Heading.Set {
			e.RawStr("\"heading\"" + ":")
			s.Heading.Encode(e)
		}
	}
	{
		if s.ProximityAlertRadius.Set {
			e.Comma()
		}
		if s.ProximityAlertRadius.Set {
			e.RawStr("\"proximity_alert_radius\"" + ":")
			s.ProximityAlertRadius.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	{
		if s.ThumbURL.Set {
			e.Comma()
		}
		if s.ThumbURL.Set {
			e.RawStr("\"thumb_url\"" + ":")
			s.ThumbURL.Encode(e)
		}
	}
	{
		if s.ThumbWidth.Set {
			e.Comma()
		}
		if s.ThumbWidth.Set {
			e.RawStr("\"thumb_width\"" + ":")
			s.ThumbWidth.Encode(e)
		}
	}
	{
		if s.ThumbHeight.Set {
			e.Comma()
		}
		if s.ThumbHeight.Set {
			e.RawStr("\"thumb_height\"" + ":")
			s.ThumbHeight.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultLocation = [14]string{
	0:  "type",
	1:  "id",
	2:  "latitude",
	3:  "longitude",
	4:  "title",
	5:  "horizontal_accuracy",
	6:  "live_period",
	7:  "heading",
	8:  "proximity_alert_radius",
	9:  "reply_markup",
	10: "input_message_content",
	11: "thumb_url",
	12: "thumb_width",
	13: "thumb_height",
}

// Decode decodes InlineQueryResultLocation from json.
func (s *InlineQueryResultLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultLocation to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Float64()
			s.Latitude = float64(v)
			if err != nil {
				return err
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Float64()
			s.Longitude = float64(v)
			if err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "horizontal_accuracy":
			s.HorizontalAccuracy.Reset()
			if err := s.HorizontalAccuracy.Decode(d); err != nil {
				return err
			}
		case "live_period":
			s.LivePeriod.Reset()
			if err := s.LivePeriod.Decode(d); err != nil {
				return err
			}
		case "heading":
			s.Heading.Reset()
			if err := s.Heading.Decode(d); err != nil {
				return err
			}
		case "proximity_alert_radius":
			s.ProximityAlertRadius.Reset()
			if err := s.ProximityAlertRadius.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		case "thumb_url":
			s.ThumbURL.Reset()
			if err := s.ThumbURL.Decode(d); err != nil {
				return err
			}
		case "thumb_width":
			s.ThumbWidth.Reset()
			if err := s.ThumbWidth.Decode(d); err != nil {
				return err
			}
		case "thumb_height":
			s.ThumbHeight.Reset()
			if err := s.ThumbHeight.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultLocation) {
					name = jsonFieldsNameOfInlineQueryResultLocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultMpeg4Gif) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"mpeg4_url\"" + ":")
		e.Str(s.Mpeg4URL)
	}
	{
		if s.Mpeg4Width.Set {
			e.Comma()
		}
		if s.Mpeg4Width.Set {
			e.RawStr("\"mpeg4_width\"" + ":")
			s.Mpeg4Width.Encode(e)
		}
	}
	{
		if s.Mpeg4Height.Set {
			e.Comma()
		}
		if s.Mpeg4Height.Set {
			e.RawStr("\"mpeg4_height\"" + ":")
			s.Mpeg4Height.Encode(e)
		}
	}
	{
		if s.Mpeg4Duration.Set {
			e.Comma()
		}
		if s.Mpeg4Duration.Set {
			e.RawStr("\"mpeg4_duration\"" + ":")
			s.Mpeg4Duration.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"thumb_url\"" + ":")
		e.Str(s.ThumbURL)
	}
	{
		if s.ThumbMimeType.Set {
			e.Comma()
		}
		if s.ThumbMimeType.Set {
			e.RawStr("\"thumb_mime_type\"" + ":")
			s.ThumbMimeType.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.Comma()
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultMpeg4Gif = [14]string{
	0:  "type",
	1:  "id",
	2:  "mpeg4_url",
	3:  "mpeg4_width",
	4:  "mpeg4_height",
	5:  "mpeg4_duration",
	6:  "thumb_url",
	7:  "thumb_mime_type",
	8:  "title",
	9:  "caption",
	10: "parse_mode",
	11: "caption_entities",
	12: "reply_markup",
	13: "input_message_content",
}

// Decode decodes InlineQueryResultMpeg4Gif from json.
func (s *InlineQueryResultMpeg4Gif) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultMpeg4Gif to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "mpeg4_url":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Mpeg4URL = string(v)
			if err != nil {
				return err
			}
		case "mpeg4_width":
			s.Mpeg4Width.Reset()
			if err := s.Mpeg4Width.Decode(d); err != nil {
				return err
			}
		case "mpeg4_height":
			s.Mpeg4Height.Reset()
			if err := s.Mpeg4Height.Decode(d); err != nil {
				return err
			}
		case "mpeg4_duration":
			s.Mpeg4Duration.Reset()
			if err := s.Mpeg4Duration.Decode(d); err != nil {
				return err
			}
		case "thumb_url":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Str()
			s.ThumbURL = string(v)
			if err != nil {
				return err
			}
		case "thumb_mime_type":
			s.ThumbMimeType.Reset()
			if err := s.ThumbMimeType.Decode(d); err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultMpeg4Gif) {
					name = jsonFieldsNameOfInlineQueryResultMpeg4Gif[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultPhoto) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"photo_url\"" + ":")
		e.Str(s.PhotoURL)
	}
	{
		e.Comma()

		e.RawStr("\"thumb_url\"" + ":")
		e.Str(s.ThumbURL)
	}
	{
		if s.PhotoWidth.Set {
			e.Comma()
		}
		if s.PhotoWidth.Set {
			e.RawStr("\"photo_width\"" + ":")
			s.PhotoWidth.Encode(e)
		}
	}
	{
		if s.PhotoHeight.Set {
			e.Comma()
		}
		if s.PhotoHeight.Set {
			e.RawStr("\"photo_height\"" + ":")
			s.PhotoHeight.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.Comma()
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultPhoto = [13]string{
	0:  "type",
	1:  "id",
	2:  "photo_url",
	3:  "thumb_url",
	4:  "photo_width",
	5:  "photo_height",
	6:  "title",
	7:  "description",
	8:  "caption",
	9:  "parse_mode",
	10: "caption_entities",
	11: "reply_markup",
	12: "input_message_content",
}

// Decode decodes InlineQueryResultPhoto from json.
func (s *InlineQueryResultPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultPhoto to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "photo_url":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.PhotoURL = string(v)
			if err != nil {
				return err
			}
		case "thumb_url":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.ThumbURL = string(v)
			if err != nil {
				return err
			}
		case "photo_width":
			s.PhotoWidth.Reset()
			if err := s.PhotoWidth.Decode(d); err != nil {
				return err
			}
		case "photo_height":
			s.PhotoHeight.Reset()
			if err := s.PhotoHeight.Decode(d); err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultPhoto) {
					name = jsonFieldsNameOfInlineQueryResultPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultVenue) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"latitude\"" + ":")
		e.Float64(s.Latitude)
	}
	{
		e.Comma()

		e.RawStr("\"longitude\"" + ":")
		e.Float64(s.Longitude)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"address\"" + ":")
		e.Str(s.Address)
	}
	{
		if s.FoursquareID.Set {
			e.Comma()
		}
		if s.FoursquareID.Set {
			e.RawStr("\"foursquare_id\"" + ":")
			s.FoursquareID.Encode(e)
		}
	}
	{
		if s.FoursquareType.Set {
			e.Comma()
		}
		if s.FoursquareType.Set {
			e.RawStr("\"foursquare_type\"" + ":")
			s.FoursquareType.Encode(e)
		}
	}
	{
		if s.GooglePlaceID.Set {
			e.Comma()
		}
		if s.GooglePlaceID.Set {
			e.RawStr("\"google_place_id\"" + ":")
			s.GooglePlaceID.Encode(e)
		}
	}
	{
		if s.GooglePlaceType.Set {
			e.Comma()
		}
		if s.GooglePlaceType.Set {
			e.RawStr("\"google_place_type\"" + ":")
			s.GooglePlaceType.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	{
		if s.ThumbURL.Set {
			e.Comma()
		}
		if s.ThumbURL.Set {
			e.RawStr("\"thumb_url\"" + ":")
			s.ThumbURL.Encode(e)
		}
	}
	{
		if s.ThumbWidth.Set {
			e.Comma()
		}
		if s.ThumbWidth.Set {
			e.RawStr("\"thumb_width\"" + ":")
			s.ThumbWidth.Encode(e)
		}
	}
	{
		if s.ThumbHeight.Set {
			e.Comma()
		}
		if s.ThumbHeight.Set {
			e.RawStr("\"thumb_height\"" + ":")
			s.ThumbHeight.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultVenue = [15]string{
	0:  "type",
	1:  "id",
	2:  "latitude",
	3:  "longitude",
	4:  "title",
	5:  "address",
	6:  "foursquare_id",
	7:  "foursquare_type",
	8:  "google_place_id",
	9:  "google_place_type",
	10: "reply_markup",
	11: "input_message_content",
	12: "thumb_url",
	13: "thumb_width",
	14: "thumb_height",
}

// Decode decodes InlineQueryResultVenue from json.
func (s *InlineQueryResultVenue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultVenue to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Float64()
			s.Latitude = float64(v)
			if err != nil {
				return err
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Float64()
			s.Longitude = float64(v)
			if err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "address":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Address = string(v)
			if err != nil {
				return err
			}
		case "foursquare_id":
			s.FoursquareID.Reset()
			if err := s.FoursquareID.Decode(d); err != nil {
				return err
			}
		case "foursquare_type":
			s.FoursquareType.Reset()
			if err := s.FoursquareType.Decode(d); err != nil {
				return err
			}
		case "google_place_id":
			s.GooglePlaceID.Reset()
			if err := s.GooglePlaceID.Decode(d); err != nil {
				return err
			}
		case "google_place_type":
			s.GooglePlaceType.Reset()
			if err := s.GooglePlaceType.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		case "thumb_url":
			s.ThumbURL.Reset()
			if err := s.ThumbURL.Decode(d); err != nil {
				return err
			}
		case "thumb_width":
			s.ThumbWidth.Reset()
			if err := s.ThumbWidth.Decode(d); err != nil {
				return err
			}
		case "thumb_height":
			s.ThumbHeight.Reset()
			if err := s.ThumbHeight.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultVenue) {
					name = jsonFieldsNameOfInlineQueryResultVenue[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultVideo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"video_url\"" + ":")
		e.Str(s.VideoURL)
	}
	{
		e.Comma()

		e.RawStr("\"mime_type\"" + ":")
		e.Str(s.MimeType)
	}
	{
		e.Comma()

		e.RawStr("\"thumb_url\"" + ":")
		e.Str(s.ThumbURL)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.VideoWidth.Set {
			e.Comma()
		}
		if s.VideoWidth.Set {
			e.RawStr("\"video_width\"" + ":")
			s.VideoWidth.Encode(e)
		}
	}
	{
		if s.VideoHeight.Set {
			e.Comma()
		}
		if s.VideoHeight.Set {
			e.RawStr("\"video_height\"" + ":")
			s.VideoHeight.Encode(e)
		}
	}
	{
		if s.VideoDuration.Set {
			e.Comma()
		}
		if s.VideoDuration.Set {
			e.RawStr("\"video_duration\"" + ":")
			s.VideoDuration.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultVideo = [15]string{
	0:  "type",
	1:  "id",
	2:  "video_url",
	3:  "mime_type",
	4:  "thumb_url",
	5:  "title",
	6:  "caption",
	7:  "parse_mode",
	8:  "caption_entities",
	9:  "video_width",
	10: "video_height",
	11: "video_duration",
	12: "description",
	13: "reply_markup",
	14: "input_message_content",
}

// Decode decodes InlineQueryResultVideo from json.
func (s *InlineQueryResultVideo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultVideo to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "video_url":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.VideoURL = string(v)
			if err != nil {
				return err
			}
		case "mime_type":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.MimeType = string(v)
			if err != nil {
				return err
			}
		case "thumb_url":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.ThumbURL = string(v)
			if err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "video_width":
			s.VideoWidth.Reset()
			if err := s.VideoWidth.Decode(d); err != nil {
				return err
			}
		case "video_height":
			s.VideoHeight.Reset()
			if err := s.VideoHeight.Decode(d); err != nil {
				return err
			}
		case "video_duration":
			s.VideoDuration.Reset()
			if err := s.VideoDuration.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultVideo) {
					name = jsonFieldsNameOfInlineQueryResultVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InlineQueryResultVoice) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"voice_url\"" + ":")
		e.Str(s.VoiceURL)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.VoiceDuration.Set {
			e.Comma()
		}
		if s.VoiceDuration.Set {
			e.RawStr("\"voice_duration\"" + ":")
			s.VoiceDuration.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.InputMessageContent.Set {
			e.Comma()
		}
		if s.InputMessageContent.Set {
			e.RawStr("\"input_message_content\"" + ":")
			s.InputMessageContent.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInlineQueryResultVoice = [10]string{
	0: "type",
	1: "id",
	2: "voice_url",
	3: "title",
	4: "caption",
	5: "parse_mode",
	6: "caption_entities",
	7: "voice_duration",
	8: "reply_markup",
	9: "input_message_content",
}

// Decode decodes InlineQueryResultVoice from json.
func (s *InlineQueryResultVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InlineQueryResultVoice to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "voice_url":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.VoiceURL = string(v)
			if err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "voice_duration":
			s.VoiceDuration.Reset()
			if err := s.VoiceDuration.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "input_message_content":
			s.InputMessageContent.Reset()
			if err := s.InputMessageContent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInlineQueryResultVoice) {
					name = jsonFieldsNameOfInlineQueryResultVoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InputContactMessageContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"phone_number\"" + ":")
		e.Str(s.PhoneNumber)
	}
	{
		e.Comma()

		e.RawStr("\"first_name\"" + ":")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.Comma()
		}
		if s.LastName.Set {
			e.RawStr("\"last_name\"" + ":")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Vcard.Set {
			e.Comma()
		}
		if s.Vcard.Set {
			e.RawStr("\"vcard\"" + ":")
			s.Vcard.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInputContactMessageContent = [4]string{
	0: "phone_number",
	1: "first_name",
	2: "last_name",
	3: "vcard",
}

// Decode decodes InputContactMessageContent from json.
func (s *InputContactMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputContactMessageContent to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phone_number":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.PhoneNumber = string(v)
			if err != nil {
				return err
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.FirstName = string(v)
			if err != nil {
				return err
			}
		case "last_name":
			s.LastName.Reset()
			if err := s.LastName.Decode(d); err != nil {
				return err
			}
		case "vcard":
			s.Vcard.Reset()
			if err := s.Vcard.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputContactMessageContent) {
					name = jsonFieldsNameOfInputContactMessageContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InputInvoiceMessageContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		e.Str(s.Payload)
	}
	{
		e.Comma()

		e.RawStr("\"provider_token\"" + ":")
		e.Str(s.ProviderToken)
	}
	{
		e.Comma()

		e.RawStr("\"currency\"" + ":")
		e.Str(s.Currency)
	}
	{
		e.Comma()

		e.RawStr("\"prices\"" + ":")
		e.ArrStart()
		if len(s.Prices) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Prices[0]
				elem.Encode(e)
			}
			for _, elem := range s.Prices[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.MaxTipAmount.Set {
			e.Comma()
		}
		if s.MaxTipAmount.Set {
			e.RawStr("\"max_tip_amount\"" + ":")
			s.MaxTipAmount.Encode(e)
		}
	}
	{
		if s.SuggestedTipAmounts != nil {
			e.Comma()
		}
		if s.SuggestedTipAmounts != nil {
			e.RawStr("\"suggested_tip_amounts\"" + ":")
			e.ArrStart()
			if len(s.SuggestedTipAmounts) >= 1 {
				// Encode first element without comma.
				{
					elem := s.SuggestedTipAmounts[0]
					e.Int64(elem)
				}
				for _, elem := range s.SuggestedTipAmounts[1:] {
					e.Comma()
					e.Int64(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ProviderData.Set {
			e.Comma()
		}
		if s.ProviderData.Set {
			e.RawStr("\"provider_data\"" + ":")
			s.ProviderData.Encode(e)
		}
	}
	{
		if s.PhotoURL.Set {
			e.Comma()
		}
		if s.PhotoURL.Set {
			e.RawStr("\"photo_url\"" + ":")
			s.PhotoURL.Encode(e)
		}
	}
	{
		if s.PhotoSize.Set {
			e.Comma()
		}
		if s.PhotoSize.Set {
			e.RawStr("\"photo_size\"" + ":")
			s.PhotoSize.Encode(e)
		}
	}
	{
		if s.PhotoWidth.Set {
			e.Comma()
		}
		if s.PhotoWidth.Set {
			e.RawStr("\"photo_width\"" + ":")
			s.PhotoWidth.Encode(e)
		}
	}
	{
		if s.PhotoHeight.Set {
			e.Comma()
		}
		if s.PhotoHeight.Set {
			e.RawStr("\"photo_height\"" + ":")
			s.PhotoHeight.Encode(e)
		}
	}
	{
		if s.NeedName.Set {
			e.Comma()
		}
		if s.NeedName.Set {
			e.RawStr("\"need_name\"" + ":")
			s.NeedName.Encode(e)
		}
	}
	{
		if s.NeedPhoneNumber.Set {
			e.Comma()
		}
		if s.NeedPhoneNumber.Set {
			e.RawStr("\"need_phone_number\"" + ":")
			s.NeedPhoneNumber.Encode(e)
		}
	}
	{
		if s.NeedEmail.Set {
			e.Comma()
		}
		if s.NeedEmail.Set {
			e.RawStr("\"need_email\"" + ":")
			s.NeedEmail.Encode(e)
		}
	}
	{
		if s.NeedShippingAddress.Set {
			e.Comma()
		}
		if s.NeedShippingAddress.Set {
			e.RawStr("\"need_shipping_address\"" + ":")
			s.NeedShippingAddress.Encode(e)
		}
	}
	{
		if s.SendPhoneNumberToProvider.Set {
			e.Comma()
		}
		if s.SendPhoneNumberToProvider.Set {
			e.RawStr("\"send_phone_number_to_provider\"" + ":")
			s.SendPhoneNumberToProvider.Encode(e)
		}
	}
	{
		if s.SendEmailToProvider.Set {
			e.Comma()
		}
		if s.SendEmailToProvider.Set {
			e.RawStr("\"send_email_to_provider\"" + ":")
			s.SendEmailToProvider.Encode(e)
		}
	}
	{
		if s.IsFlexible.Set {
			e.Comma()
		}
		if s.IsFlexible.Set {
			e.RawStr("\"is_flexible\"" + ":")
			s.IsFlexible.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInputInvoiceMessageContent = [20]string{
	0:  "title",
	1:  "description",
	2:  "payload",
	3:  "provider_token",
	4:  "currency",
	5:  "prices",
	6:  "max_tip_amount",
	7:  "suggested_tip_amounts",
	8:  "provider_data",
	9:  "photo_url",
	10: "photo_size",
	11: "photo_width",
	12: "photo_height",
	13: "need_name",
	14: "need_phone_number",
	15: "need_email",
	16: "need_shipping_address",
	17: "send_phone_number_to_provider",
	18: "send_email_to_provider",
	19: "is_flexible",
}

// Decode decodes InputInvoiceMessageContent from json.
func (s *InputInvoiceMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputInvoiceMessageContent to nil`)
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Payload = string(v)
			if err != nil {
				return err
			}
		case "provider_token":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.ProviderToken = string(v)
			if err != nil {
				return err
			}
		case "currency":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Currency = string(v)
			if err != nil {
				return err
			}
		case "prices":
			requiredBitSet[0] |= 1 << 5
			s.Prices = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem LabeledPrice
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Prices = append(s.Prices, elem)
				return nil
			}); err != nil {
				return err
			}
		case "max_tip_amount":
			s.MaxTipAmount.Reset()
			if err := s.MaxTipAmount.Decode(d); err != nil {
				return err
			}
		case "suggested_tip_amounts":
			s.SuggestedTipAmounts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				s.SuggestedTipAmounts = append(s.SuggestedTipAmounts, elem)
				return nil
			}); err != nil {
				return err
			}
		case "provider_data":
			s.ProviderData.Reset()
			if err := s.ProviderData.Decode(d); err != nil {
				return err
			}
		case "photo_url":
			s.PhotoURL.Reset()
			if err := s.PhotoURL.Decode(d); err != nil {
				return err
			}
		case "photo_size":
			s.PhotoSize.Reset()
			if err := s.PhotoSize.Decode(d); err != nil {
				return err
			}
		case "photo_width":
			s.PhotoWidth.Reset()
			if err := s.PhotoWidth.Decode(d); err != nil {
				return err
			}
		case "photo_height":
			s.PhotoHeight.Reset()
			if err := s.PhotoHeight.Decode(d); err != nil {
				return err
			}
		case "need_name":
			s.NeedName.Reset()
			if err := s.NeedName.Decode(d); err != nil {
				return err
			}
		case "need_phone_number":
			s.NeedPhoneNumber.Reset()
			if err := s.NeedPhoneNumber.Decode(d); err != nil {
				return err
			}
		case "need_email":
			s.NeedEmail.Reset()
			if err := s.NeedEmail.Decode(d); err != nil {
				return err
			}
		case "need_shipping_address":
			s.NeedShippingAddress.Reset()
			if err := s.NeedShippingAddress.Decode(d); err != nil {
				return err
			}
		case "send_phone_number_to_provider":
			s.SendPhoneNumberToProvider.Reset()
			if err := s.SendPhoneNumberToProvider.Decode(d); err != nil {
				return err
			}
		case "send_email_to_provider":
			s.SendEmailToProvider.Reset()
			if err := s.SendEmailToProvider.Decode(d); err != nil {
				return err
			}
		case "is_flexible":
			s.IsFlexible.Reset()
			if err := s.IsFlexible.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00111111,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputInvoiceMessageContent) {
					name = jsonFieldsNameOfInputInvoiceMessageContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InputLocationMessageContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"latitude\"" + ":")
		e.Float64(s.Latitude)
	}
	{
		e.Comma()

		e.RawStr("\"longitude\"" + ":")
		e.Float64(s.Longitude)
	}
	{
		if s.HorizontalAccuracy.Set {
			e.Comma()
		}
		if s.HorizontalAccuracy.Set {
			e.RawStr("\"horizontal_accuracy\"" + ":")
			s.HorizontalAccuracy.Encode(e)
		}
	}
	{
		if s.LivePeriod.Set {
			e.Comma()
		}
		if s.LivePeriod.Set {
			e.RawStr("\"live_period\"" + ":")
			s.LivePeriod.Encode(e)
		}
	}
	{
		if s.Heading.Set {
			e.Comma()
		}
		if s.Heading.Set {
			e.RawStr("\"heading\"" + ":")
			s.Heading.Encode(e)
		}
	}
	{
		if s.ProximityAlertRadius.Set {
			e.Comma()
		}
		if s.ProximityAlertRadius.Set {
			e.RawStr("\"proximity_alert_radius\"" + ":")
			s.ProximityAlertRadius.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInputLocationMessageContent = [6]string{
	0: "latitude",
	1: "longitude",
	2: "horizontal_accuracy",
	3: "live_period",
	4: "heading",
	5: "proximity_alert_radius",
}

// Decode decodes InputLocationMessageContent from json.
func (s *InputLocationMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputLocationMessageContent to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "latitude":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Float64()
			s.Latitude = float64(v)
			if err != nil {
				return err
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Float64()
			s.Longitude = float64(v)
			if err != nil {
				return err
			}
		case "horizontal_accuracy":
			s.HorizontalAccuracy.Reset()
			if err := s.HorizontalAccuracy.Decode(d); err != nil {
				return err
			}
		case "live_period":
			s.LivePeriod.Reset()
			if err := s.LivePeriod.Decode(d); err != nil {
				return err
			}
		case "heading":
			s.Heading.Reset()
			if err := s.Heading.Decode(d); err != nil {
				return err
			}
		case "proximity_alert_radius":
			s.ProximityAlertRadius.Reset()
			if err := s.ProximityAlertRadius.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputLocationMessageContent) {
					name = jsonFieldsNameOfInputLocationMessageContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes InputMedia as json.
func (s InputMedia) Encode(e *jx.Writer) {
	switch s.Type {
	case InputMediaAnimationInputMedia:
		s.InputMediaAnimation.Encode(e)
	case InputMediaDocumentInputMedia:
		s.InputMediaDocument.Encode(e)
	case InputMediaAudioInputMedia:
		s.InputMediaAudio.Encode(e)
	case InputMediaPhotoInputMedia:
		s.InputMediaPhoto.Encode(e)
	case InputMediaVideoInputMedia:
		s.InputMediaVideo.Encode(e)
	}
}

// Decode decodes InputMedia from json.
func (s *InputMedia) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputMedia to nil`)
	}
	// Sum type discriminator.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "animation":
					s.Type = InputMediaAnimationInputMedia
					found = true
				case "audio":
					s.Type = InputMediaAudioInputMedia
					found = true
				case "document":
					s.Type = InputMediaDocumentInputMedia
					found = true
				case "photo":
					s.Type = InputMediaPhotoInputMedia
					found = true
				case "video":
					s.Type = InputMediaVideoInputMedia
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InputMediaAnimationInputMedia:
		if err := s.InputMediaAnimation.Decode(d); err != nil {
			return err
		}
	case InputMediaDocumentInputMedia:
		if err := s.InputMediaDocument.Decode(d); err != nil {
			return err
		}
	case InputMediaAudioInputMedia:
		if err := s.InputMediaAudio.Decode(d); err != nil {
			return err
		}
	case InputMediaPhotoInputMedia:
		if err := s.InputMediaPhoto.Decode(d); err != nil {
			return err
		}
	case InputMediaVideoInputMedia:
		if err := s.InputMediaVideo.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s InputMediaAnimation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"media\"" + ":")
		e.Str(s.Media)
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Width.Set {
			e.Comma()
		}
		if s.Width.Set {
			e.RawStr("\"width\"" + ":")
			s.Width.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.Comma()
		}
		if s.Height.Set {
			e.RawStr("\"height\"" + ":")
			s.Height.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.Comma()
		}
		if s.Duration.Set {
			e.RawStr("\"duration\"" + ":")
			s.Duration.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInputMediaAnimation = [9]string{
	0: "type",
	1: "media",
	2: "thumb",
	3: "caption",
	4: "parse_mode",
	5: "caption_entities",
	6: "width",
	7: "height",
	8: "duration",
}

// Decode decodes InputMediaAnimation from json.
func (s *InputMediaAnimation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputMediaAnimation to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Media = string(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "width":
			s.Width.Reset()
			if err := s.Width.Decode(d); err != nil {
				return err
			}
		case "height":
			s.Height.Reset()
			if err := s.Height.Decode(d); err != nil {
				return err
			}
		case "duration":
			s.Duration.Reset()
			if err := s.Duration.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputMediaAnimation) {
					name = jsonFieldsNameOfInputMediaAnimation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InputMediaAudio) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"media\"" + ":")
		e.Str(s.Media)
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Duration.Set {
			e.Comma()
		}
		if s.Duration.Set {
			e.RawStr("\"duration\"" + ":")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Performer.Set {
			e.Comma()
		}
		if s.Performer.Set {
			e.RawStr("\"performer\"" + ":")
			s.Performer.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.Comma()
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInputMediaAudio = [9]string{
	0: "type",
	1: "media",
	2: "thumb",
	3: "caption",
	4: "parse_mode",
	5: "caption_entities",
	6: "duration",
	7: "performer",
	8: "title",
}

// Decode decodes InputMediaAudio from json.
func (s *InputMediaAudio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputMediaAudio to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Media = string(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "duration":
			s.Duration.Reset()
			if err := s.Duration.Decode(d); err != nil {
				return err
			}
		case "performer":
			s.Performer.Reset()
			if err := s.Performer.Decode(d); err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputMediaAudio) {
					name = jsonFieldsNameOfInputMediaAudio[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InputMediaDocument) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"media\"" + ":")
		e.Str(s.Media)
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableContentTypeDetection.Set {
			e.Comma()
		}
		if s.DisableContentTypeDetection.Set {
			e.RawStr("\"disable_content_type_detection\"" + ":")
			s.DisableContentTypeDetection.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInputMediaDocument = [7]string{
	0: "type",
	1: "media",
	2: "thumb",
	3: "caption",
	4: "parse_mode",
	5: "caption_entities",
	6: "disable_content_type_detection",
}

// Decode decodes InputMediaDocument from json.
func (s *InputMediaDocument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputMediaDocument to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Media = string(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_content_type_detection":
			s.DisableContentTypeDetection.Reset()
			if err := s.DisableContentTypeDetection.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputMediaDocument) {
					name = jsonFieldsNameOfInputMediaDocument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InputMediaPhoto) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"media\"" + ":")
		e.Str(s.Media)
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInputMediaPhoto = [5]string{
	0: "type",
	1: "media",
	2: "caption",
	3: "parse_mode",
	4: "caption_entities",
}

// Decode decodes InputMediaPhoto from json.
func (s *InputMediaPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputMediaPhoto to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Media = string(v)
			if err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputMediaPhoto) {
					name = jsonFieldsNameOfInputMediaPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InputMediaVideo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"media\"" + ":")
		e.Str(s.Media)
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Width.Set {
			e.Comma()
		}
		if s.Width.Set {
			e.RawStr("\"width\"" + ":")
			s.Width.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.Comma()
		}
		if s.Height.Set {
			e.RawStr("\"height\"" + ":")
			s.Height.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.Comma()
		}
		if s.Duration.Set {
			e.RawStr("\"duration\"" + ":")
			s.Duration.Encode(e)
		}
	}
	{
		if s.SupportsStreaming.Set {
			e.Comma()
		}
		if s.SupportsStreaming.Set {
			e.RawStr("\"supports_streaming\"" + ":")
			s.SupportsStreaming.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInputMediaVideo = [10]string{
	0: "type",
	1: "media",
	2: "thumb",
	3: "caption",
	4: "parse_mode",
	5: "caption_entities",
	6: "width",
	7: "height",
	8: "duration",
	9: "supports_streaming",
}

// Decode decodes InputMediaVideo from json.
func (s *InputMediaVideo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputMediaVideo to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Media = string(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "width":
			s.Width.Reset()
			if err := s.Width.Decode(d); err != nil {
				return err
			}
		case "height":
			s.Height.Reset()
			if err := s.Height.Decode(d); err != nil {
				return err
			}
		case "duration":
			s.Duration.Reset()
			if err := s.Duration.Decode(d); err != nil {
				return err
			}
		case "supports_streaming":
			s.SupportsStreaming.Reset()
			if err := s.SupportsStreaming.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputMediaVideo) {
					name = jsonFieldsNameOfInputMediaVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes InputMessageContent as json.
func (s InputMessageContent) Encode(e *jx.Writer) {
	switch s.Type {
	case InputTextMessageContentInputMessageContent:
		s.InputTextMessageContent.Encode(e)
	case InputLocationMessageContentInputMessageContent:
		s.InputLocationMessageContent.Encode(e)
	case InputVenueMessageContentInputMessageContent:
		s.InputVenueMessageContent.Encode(e)
	case InputContactMessageContentInputMessageContent:
		s.InputContactMessageContent.Encode(e)
	case InputInvoiceMessageContentInputMessageContent:
		s.InputInvoiceMessageContent.Encode(e)
	}
}

// Decode decodes InputMessageContent from json.
func (s *InputMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputMessageContent to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "message_text":
				found = true
				s.Type = InputTextMessageContentInputMessageContent
			case "parse_mode":
				found = true
				s.Type = InputTextMessageContentInputMessageContent
			case "entities":
				found = true
				s.Type = InputTextMessageContentInputMessageContent
			case "disable_web_page_preview":
				found = true
				s.Type = InputTextMessageContentInputMessageContent
			case "horizontal_accuracy":
				found = true
				s.Type = InputLocationMessageContentInputMessageContent
			case "live_period":
				found = true
				s.Type = InputLocationMessageContentInputMessageContent
			case "heading":
				found = true
				s.Type = InputLocationMessageContentInputMessageContent
			case "proximity_alert_radius":
				found = true
				s.Type = InputLocationMessageContentInputMessageContent
			case "address":
				found = true
				s.Type = InputVenueMessageContentInputMessageContent
			case "foursquare_id":
				found = true
				s.Type = InputVenueMessageContentInputMessageContent
			case "foursquare_type":
				found = true
				s.Type = InputVenueMessageContentInputMessageContent
			case "google_place_id":
				found = true
				s.Type = InputVenueMessageContentInputMessageContent
			case "google_place_type":
				found = true
				s.Type = InputVenueMessageContentInputMessageContent
			case "phone_number":
				found = true
				s.Type = InputContactMessageContentInputMessageContent
			case "first_name":
				found = true
				s.Type = InputContactMessageContentInputMessageContent
			case "last_name":
				found = true
				s.Type = InputContactMessageContentInputMessageContent
			case "vcard":
				found = true
				s.Type = InputContactMessageContentInputMessageContent
			case "description":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "payload":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "provider_token":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "currency":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "prices":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "max_tip_amount":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "suggested_tip_amounts":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "provider_data":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "photo_url":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "photo_size":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "photo_width":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "photo_height":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "need_name":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "need_phone_number":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "need_email":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "need_shipping_address":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "send_phone_number_to_provider":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "send_email_to_provider":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			case "is_flexible":
				found = true
				s.Type = InputInvoiceMessageContentInputMessageContent
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InputTextMessageContentInputMessageContent:
		if err := s.InputTextMessageContent.Decode(d); err != nil {
			return err
		}
	case InputLocationMessageContentInputMessageContent:
		if err := s.InputLocationMessageContent.Decode(d); err != nil {
			return err
		}
	case InputVenueMessageContentInputMessageContent:
		if err := s.InputVenueMessageContent.Decode(d); err != nil {
			return err
		}
	case InputContactMessageContentInputMessageContent:
		if err := s.InputContactMessageContent.Decode(d); err != nil {
			return err
		}
	case InputInvoiceMessageContentInputMessageContent:
		if err := s.InputInvoiceMessageContent.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s InputTextMessageContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message_text\"" + ":")
		e.Str(s.MessageText)
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.Entities != nil {
			e.Comma()
		}
		if s.Entities != nil {
			e.RawStr("\"entities\"" + ":")
			e.ArrStart()
			if len(s.Entities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Entities[0]
					elem.Encode(e)
				}
				for _, elem := range s.Entities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableWebPagePreview.Set {
			e.Comma()
		}
		if s.DisableWebPagePreview.Set {
			e.RawStr("\"disable_web_page_preview\"" + ":")
			s.DisableWebPagePreview.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInputTextMessageContent = [4]string{
	0: "message_text",
	1: "parse_mode",
	2: "entities",
	3: "disable_web_page_preview",
}

// Decode decodes InputTextMessageContent from json.
func (s *InputTextMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputTextMessageContent to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message_text":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.MessageText = string(v)
			if err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "entities":
			s.Entities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Entities = append(s.Entities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_web_page_preview":
			s.DisableWebPagePreview.Reset()
			if err := s.DisableWebPagePreview.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputTextMessageContent) {
					name = jsonFieldsNameOfInputTextMessageContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InputVenueMessageContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"latitude\"" + ":")
		e.Float64(s.Latitude)
	}
	{
		e.Comma()

		e.RawStr("\"longitude\"" + ":")
		e.Float64(s.Longitude)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"address\"" + ":")
		e.Str(s.Address)
	}
	{
		if s.FoursquareID.Set {
			e.Comma()
		}
		if s.FoursquareID.Set {
			e.RawStr("\"foursquare_id\"" + ":")
			s.FoursquareID.Encode(e)
		}
	}
	{
		if s.FoursquareType.Set {
			e.Comma()
		}
		if s.FoursquareType.Set {
			e.RawStr("\"foursquare_type\"" + ":")
			s.FoursquareType.Encode(e)
		}
	}
	{
		if s.GooglePlaceID.Set {
			e.Comma()
		}
		if s.GooglePlaceID.Set {
			e.RawStr("\"google_place_id\"" + ":")
			s.GooglePlaceID.Encode(e)
		}
	}
	{
		if s.GooglePlaceType.Set {
			e.Comma()
		}
		if s.GooglePlaceType.Set {
			e.RawStr("\"google_place_type\"" + ":")
			s.GooglePlaceType.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInputVenueMessageContent = [8]string{
	0: "latitude",
	1: "longitude",
	2: "title",
	3: "address",
	4: "foursquare_id",
	5: "foursquare_type",
	6: "google_place_id",
	7: "google_place_type",
}

// Decode decodes InputVenueMessageContent from json.
func (s *InputVenueMessageContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InputVenueMessageContent to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "latitude":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Float64()
			s.Latitude = float64(v)
			if err != nil {
				return err
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Float64()
			s.Longitude = float64(v)
			if err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Address = string(v)
			if err != nil {
				return err
			}
		case "foursquare_id":
			s.FoursquareID.Reset()
			if err := s.FoursquareID.Decode(d); err != nil {
				return err
			}
		case "foursquare_type":
			s.FoursquareType.Reset()
			if err := s.FoursquareType.Decode(d); err != nil {
				return err
			}
		case "google_place_id":
			s.GooglePlaceID.Reset()
			if err := s.GooglePlaceID.Decode(d); err != nil {
				return err
			}
		case "google_place_type":
			s.GooglePlaceType.Reset()
			if err := s.GooglePlaceType.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInputVenueMessageContent) {
					name = jsonFieldsNameOfInputVenueMessageContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Invoice) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"start_parameter\"" + ":")
		e.Str(s.StartParameter)
	}
	{
		e.Comma()

		e.RawStr("\"currency\"" + ":")
		e.Str(s.Currency)
	}
	{
		e.Comma()

		e.RawStr("\"total_amount\"" + ":")
		e.Int(s.TotalAmount)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInvoice = [5]string{
	0: "title",
	1: "description",
	2: "start_parameter",
	3: "currency",
	4: "total_amount",
}

// Decode decodes Invoice from json.
func (s *Invoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Invoice to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "start_parameter":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.StartParameter = string(v)
			if err != nil {
				return err
			}
		case "currency":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Currency = string(v)
			if err != nil {
				return err
			}
		case "total_amount":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Int()
			s.TotalAmount = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvoice) {
					name = jsonFieldsNameOfInvoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes KeyboardButton as json.
func (s KeyboardButton) Encode(e *jx.Writer) {
	switch s.Type {
	case StringKeyboardButton:
		e.Str(s.String)
	case KeyboardButtonObjectKeyboardButton:
		s.KeyboardButtonObject.Encode(e)
	}
}

// Decode decodes KeyboardButton from json.
func (s *KeyboardButton) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode KeyboardButton to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringKeyboardButton
	case jx.Object:
		if err := s.KeyboardButtonObject.Decode(d); err != nil {
			return err
		}
		s.Type = KeyboardButtonObjectKeyboardButton
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s KeyboardButtonObject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"text\"" + ":")
		e.Str(s.Text)
	}
	{
		if s.RequestContact.Set {
			e.Comma()
		}
		if s.RequestContact.Set {
			e.RawStr("\"request_contact\"" + ":")
			s.RequestContact.Encode(e)
		}
	}
	{
		if s.RequestLocation.Set {
			e.Comma()
		}
		if s.RequestLocation.Set {
			e.RawStr("\"request_location\"" + ":")
			s.RequestLocation.Encode(e)
		}
	}
	{
		if s.RequestPoll.Set {
			e.Comma()
		}
		if s.RequestPoll.Set {
			e.RawStr("\"request_poll\"" + ":")
			s.RequestPoll.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfKeyboardButtonObject = [4]string{
	0: "text",
	1: "request_contact",
	2: "request_location",
	3: "request_poll",
}

// Decode decodes KeyboardButtonObject from json.
func (s *KeyboardButtonObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode KeyboardButtonObject to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Text = string(v)
			if err != nil {
				return err
			}
		case "request_contact":
			s.RequestContact.Reset()
			if err := s.RequestContact.Decode(d); err != nil {
				return err
			}
		case "request_location":
			s.RequestLocation.Reset()
			if err := s.RequestLocation.Decode(d); err != nil {
				return err
			}
		case "request_poll":
			s.RequestPoll.Reset()
			if err := s.RequestPoll.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfKeyboardButtonObject) {
					name = jsonFieldsNameOfKeyboardButtonObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s KeyboardButtonPollType) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfKeyboardButtonPollType = [1]string{
	0: "type",
}

// Decode decodes KeyboardButtonPollType from json.
func (s *KeyboardButtonPollType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode KeyboardButtonPollType to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s LabeledPrice) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"label\"" + ":")
		e.Str(s.Label)
	}
	{
		e.Comma()

		e.RawStr("\"amount\"" + ":")
		e.Int(s.Amount)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfLabeledPrice = [2]string{
	0: "label",
	1: "amount",
}

// Decode decodes LabeledPrice from json.
func (s *LabeledPrice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LabeledPrice to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Label = string(v)
			if err != nil {
				return err
			}
		case "amount":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int()
			s.Amount = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLabeledPrice) {
					name = jsonFieldsNameOfLabeledPrice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s LeaveChat) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfLeaveChat = [1]string{
	0: "chat_id",
}

// Decode decodes LeaveChat from json.
func (s *LeaveChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LeaveChat to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeaveChat) {
					name = jsonFieldsNameOfLeaveChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Location) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"longitude\"" + ":")
		e.Float64(s.Longitude)
	}
	{
		e.Comma()

		e.RawStr("\"latitude\"" + ":")
		e.Float64(s.Latitude)
	}
	{
		if s.HorizontalAccuracy.Set {
			e.Comma()
		}
		if s.HorizontalAccuracy.Set {
			e.RawStr("\"horizontal_accuracy\"" + ":")
			s.HorizontalAccuracy.Encode(e)
		}
	}
	{
		if s.LivePeriod.Set {
			e.Comma()
		}
		if s.LivePeriod.Set {
			e.RawStr("\"live_period\"" + ":")
			s.LivePeriod.Encode(e)
		}
	}
	{
		if s.Heading.Set {
			e.Comma()
		}
		if s.Heading.Set {
			e.RawStr("\"heading\"" + ":")
			s.Heading.Encode(e)
		}
	}
	{
		if s.ProximityAlertRadius.Set {
			e.Comma()
		}
		if s.ProximityAlertRadius.Set {
			e.RawStr("\"proximity_alert_radius\"" + ":")
			s.ProximityAlertRadius.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfLocation = [6]string{
	0: "longitude",
	1: "latitude",
	2: "horizontal_accuracy",
	3: "live_period",
	4: "heading",
	5: "proximity_alert_radius",
}

// Decode decodes Location from json.
func (s *Location) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Location to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "longitude":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Float64()
			s.Longitude = float64(v)
			if err != nil {
				return err
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Float64()
			s.Latitude = float64(v)
			if err != nil {
				return err
			}
		case "horizontal_accuracy":
			s.HorizontalAccuracy.Reset()
			if err := s.HorizontalAccuracy.Decode(d); err != nil {
				return err
			}
		case "live_period":
			s.LivePeriod.Reset()
			if err := s.LivePeriod.Decode(d); err != nil {
				return err
			}
		case "heading":
			s.Heading.Reset()
			if err := s.Heading.Decode(d); err != nil {
				return err
			}
		case "proximity_alert_radius":
			s.ProximityAlertRadius.Reset()
			if err := s.ProximityAlertRadius.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLocation) {
					name = jsonFieldsNameOfLocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s LoginUrl) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		if s.ForwardText.Set {
			e.Comma()
		}
		if s.ForwardText.Set {
			e.RawStr("\"forward_text\"" + ":")
			s.ForwardText.Encode(e)
		}
	}
	{
		if s.BotUsername.Set {
			e.Comma()
		}
		if s.BotUsername.Set {
			e.RawStr("\"bot_username\"" + ":")
			s.BotUsername.Encode(e)
		}
	}
	{
		if s.RequestWriteAccess.Set {
			e.Comma()
		}
		if s.RequestWriteAccess.Set {
			e.RawStr("\"request_write_access\"" + ":")
			s.RequestWriteAccess.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfLoginUrl = [4]string{
	0: "url",
	1: "forward_text",
	2: "bot_username",
	3: "request_write_access",
}

// Decode decodes LoginUrl from json.
func (s *LoginUrl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LoginUrl to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "forward_text":
			s.ForwardText.Reset()
			if err := s.ForwardText.Decode(d); err != nil {
				return err
			}
		case "bot_username":
			s.BotUsername.Reset()
			if err := s.BotUsername.Decode(d); err != nil {
				return err
			}
		case "request_write_access":
			s.RequestWriteAccess.Reset()
			if err := s.RequestWriteAccess.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginUrl) {
					name = jsonFieldsNameOfLoginUrl[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MaskPosition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"point\"" + ":")
		e.Str(s.Point)
	}
	{
		e.Comma()

		e.RawStr("\"x_shift\"" + ":")
		e.Float64(s.XShift)
	}
	{
		e.Comma()

		e.RawStr("\"y_shift\"" + ":")
		e.Float64(s.YShift)
	}
	{
		e.Comma()

		e.RawStr("\"scale\"" + ":")
		e.Float64(s.Scale)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMaskPosition = [4]string{
	0: "point",
	1: "x_shift",
	2: "y_shift",
	3: "scale",
}

// Decode decodes MaskPosition from json.
func (s *MaskPosition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MaskPosition to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "point":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Point = string(v)
			if err != nil {
				return err
			}
		case "x_shift":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Float64()
			s.XShift = float64(v)
			if err != nil {
				return err
			}
		case "y_shift":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Float64()
			s.YShift = float64(v)
			if err != nil {
				return err
			}
		case "scale":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Float64()
			s.Scale = float64(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMaskPosition) {
					name = jsonFieldsNameOfMaskPosition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Message) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message_id\"" + ":")
		e.Int(s.MessageID)
	}
	{
		if s.From.Set {
			e.Comma()
		}
		if s.From.Set {
			e.RawStr("\"from\"" + ":")
			s.From.Encode(e)
		}
	}
	{
		if s.SenderChat.Set {
			e.Comma()
		}
		if s.SenderChat.Set {
			e.RawStr("\"sender_chat\"" + ":")
			s.SenderChat.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"date\"" + ":")
		e.Int(s.Date)
	}
	{
		e.Comma()

		e.RawStr("\"chat\"" + ":")
		s.Chat.Encode(e)
	}
	{
		if s.ForwardFrom.Set {
			e.Comma()
		}
		if s.ForwardFrom.Set {
			e.RawStr("\"forward_from\"" + ":")
			s.ForwardFrom.Encode(e)
		}
	}
	{
		if s.ForwardFromChat.Set {
			e.Comma()
		}
		if s.ForwardFromChat.Set {
			e.RawStr("\"forward_from_chat\"" + ":")
			s.ForwardFromChat.Encode(e)
		}
	}
	{
		if s.ForwardFromMessageID.Set {
			e.Comma()
		}
		if s.ForwardFromMessageID.Set {
			e.RawStr("\"forward_from_message_id\"" + ":")
			s.ForwardFromMessageID.Encode(e)
		}
	}
	{
		if s.ForwardSignature.Set {
			e.Comma()
		}
		if s.ForwardSignature.Set {
			e.RawStr("\"forward_signature\"" + ":")
			s.ForwardSignature.Encode(e)
		}
	}
	{
		if s.ForwardSenderName.Set {
			e.Comma()
		}
		if s.ForwardSenderName.Set {
			e.RawStr("\"forward_sender_name\"" + ":")
			s.ForwardSenderName.Encode(e)
		}
	}
	{
		if s.ForwardDate.Set {
			e.Comma()
		}
		if s.ForwardDate.Set {
			e.RawStr("\"forward_date\"" + ":")
			s.ForwardDate.Encode(e)
		}
	}
	{
		if s.IsAutomaticForward.Set {
			e.Comma()
		}
		if s.IsAutomaticForward.Set {
			e.RawStr("\"is_automatic_forward\"" + ":")
			s.IsAutomaticForward.Encode(e)
		}
	}
	{
		if s.ReplyToMessage != nil {
			e.Comma()
		}
		if s.ReplyToMessage != nil {
			e.RawStr("\"reply_to_message\"" + ":")
			s.ReplyToMessage.Encode(e)
		}
	}
	{
		if s.ViaBot.Set {
			e.Comma()
		}
		if s.ViaBot.Set {
			e.RawStr("\"via_bot\"" + ":")
			s.ViaBot.Encode(e)
		}
	}
	{
		if s.EditDate.Set {
			e.Comma()
		}
		if s.EditDate.Set {
			e.RawStr("\"edit_date\"" + ":")
			s.EditDate.Encode(e)
		}
	}
	{
		if s.HasProtectedContent.Set {
			e.Comma()
		}
		if s.HasProtectedContent.Set {
			e.RawStr("\"has_protected_content\"" + ":")
			s.HasProtectedContent.Encode(e)
		}
	}
	{
		if s.MediaGroupID.Set {
			e.Comma()
		}
		if s.MediaGroupID.Set {
			e.RawStr("\"media_group_id\"" + ":")
			s.MediaGroupID.Encode(e)
		}
	}
	{
		if s.AuthorSignature.Set {
			e.Comma()
		}
		if s.AuthorSignature.Set {
			e.RawStr("\"author_signature\"" + ":")
			s.AuthorSignature.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.Comma()
		}
		if s.Text.Set {
			e.RawStr("\"text\"" + ":")
			s.Text.Encode(e)
		}
	}
	{
		if s.Entities != nil {
			e.Comma()
		}
		if s.Entities != nil {
			e.RawStr("\"entities\"" + ":")
			e.ArrStart()
			if len(s.Entities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Entities[0]
					elem.Encode(e)
				}
				for _, elem := range s.Entities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Animation.Set {
			e.Comma()
		}
		if s.Animation.Set {
			e.RawStr("\"animation\"" + ":")
			s.Animation.Encode(e)
		}
	}
	{
		if s.Audio.Set {
			e.Comma()
		}
		if s.Audio.Set {
			e.RawStr("\"audio\"" + ":")
			s.Audio.Encode(e)
		}
	}
	{
		if s.Document.Set {
			e.Comma()
		}
		if s.Document.Set {
			e.RawStr("\"document\"" + ":")
			s.Document.Encode(e)
		}
	}
	{
		if s.Photo != nil {
			e.Comma()
		}
		if s.Photo != nil {
			e.RawStr("\"photo\"" + ":")
			e.ArrStart()
			if len(s.Photo) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Photo[0]
					elem.Encode(e)
				}
				for _, elem := range s.Photo[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Sticker.Set {
			e.Comma()
		}
		if s.Sticker.Set {
			e.RawStr("\"sticker\"" + ":")
			s.Sticker.Encode(e)
		}
	}
	{
		if s.Video.Set {
			e.Comma()
		}
		if s.Video.Set {
			e.RawStr("\"video\"" + ":")
			s.Video.Encode(e)
		}
	}
	{
		if s.VideoNote.Set {
			e.Comma()
		}
		if s.VideoNote.Set {
			e.RawStr("\"video_note\"" + ":")
			s.VideoNote.Encode(e)
		}
	}
	{
		if s.Voice.Set {
			e.Comma()
		}
		if s.Voice.Set {
			e.RawStr("\"voice\"" + ":")
			s.Voice.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Contact.Set {
			e.Comma()
		}
		if s.Contact.Set {
			e.RawStr("\"contact\"" + ":")
			s.Contact.Encode(e)
		}
	}
	{
		if s.Dice.Set {
			e.Comma()
		}
		if s.Dice.Set {
			e.RawStr("\"dice\"" + ":")
			s.Dice.Encode(e)
		}
	}
	{
		if s.Game.Set {
			e.Comma()
		}
		if s.Game.Set {
			e.RawStr("\"game\"" + ":")
			s.Game.Encode(e)
		}
	}
	{
		if s.Poll.Set {
			e.Comma()
		}
		if s.Poll.Set {
			e.RawStr("\"poll\"" + ":")
			s.Poll.Encode(e)
		}
	}
	{
		if s.Venue.Set {
			e.Comma()
		}
		if s.Venue.Set {
			e.RawStr("\"venue\"" + ":")
			s.Venue.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.Comma()
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	{
		if s.NewChatMembers != nil {
			e.Comma()
		}
		if s.NewChatMembers != nil {
			e.RawStr("\"new_chat_members\"" + ":")
			e.ArrStart()
			if len(s.NewChatMembers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.NewChatMembers[0]
					elem.Encode(e)
				}
				for _, elem := range s.NewChatMembers[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.LeftChatMember.Set {
			e.Comma()
		}
		if s.LeftChatMember.Set {
			e.RawStr("\"left_chat_member\"" + ":")
			s.LeftChatMember.Encode(e)
		}
	}
	{
		if s.NewChatTitle.Set {
			e.Comma()
		}
		if s.NewChatTitle.Set {
			e.RawStr("\"new_chat_title\"" + ":")
			s.NewChatTitle.Encode(e)
		}
	}
	{
		if s.NewChatPhoto != nil {
			e.Comma()
		}
		if s.NewChatPhoto != nil {
			e.RawStr("\"new_chat_photo\"" + ":")
			e.ArrStart()
			if len(s.NewChatPhoto) >= 1 {
				// Encode first element without comma.
				{
					elem := s.NewChatPhoto[0]
					elem.Encode(e)
				}
				for _, elem := range s.NewChatPhoto[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DeleteChatPhoto.Set {
			e.Comma()
		}
		if s.DeleteChatPhoto.Set {
			e.RawStr("\"delete_chat_photo\"" + ":")
			s.DeleteChatPhoto.Encode(e)
		}
	}
	{
		if s.GroupChatCreated.Set {
			e.Comma()
		}
		if s.GroupChatCreated.Set {
			e.RawStr("\"group_chat_created\"" + ":")
			s.GroupChatCreated.Encode(e)
		}
	}
	{
		if s.SupergroupChatCreated.Set {
			e.Comma()
		}
		if s.SupergroupChatCreated.Set {
			e.RawStr("\"supergroup_chat_created\"" + ":")
			s.SupergroupChatCreated.Encode(e)
		}
	}
	{
		if s.ChannelChatCreated.Set {
			e.Comma()
		}
		if s.ChannelChatCreated.Set {
			e.RawStr("\"channel_chat_created\"" + ":")
			s.ChannelChatCreated.Encode(e)
		}
	}
	{
		if s.MessageAutoDeleteTimerChanged.Set {
			e.Comma()
		}
		if s.MessageAutoDeleteTimerChanged.Set {
			e.RawStr("\"message_auto_delete_timer_changed\"" + ":")
			s.MessageAutoDeleteTimerChanged.Encode(e)
		}
	}
	{
		if s.MigrateToChatID.Set {
			e.Comma()
		}
		if s.MigrateToChatID.Set {
			e.RawStr("\"migrate_to_chat_id\"" + ":")
			s.MigrateToChatID.Encode(e)
		}
	}
	{
		if s.MigrateFromChatID.Set {
			e.Comma()
		}
		if s.MigrateFromChatID.Set {
			e.RawStr("\"migrate_from_chat_id\"" + ":")
			s.MigrateFromChatID.Encode(e)
		}
	}
	{
		if s.PinnedMessage != nil {
			e.Comma()
		}
		if s.PinnedMessage != nil {
			e.RawStr("\"pinned_message\"" + ":")
			s.PinnedMessage.Encode(e)
		}
	}
	{
		if s.Invoice.Set {
			e.Comma()
		}
		if s.Invoice.Set {
			e.RawStr("\"invoice\"" + ":")
			s.Invoice.Encode(e)
		}
	}
	{
		if s.SuccessfulPayment.Set {
			e.Comma()
		}
		if s.SuccessfulPayment.Set {
			e.RawStr("\"successful_payment\"" + ":")
			s.SuccessfulPayment.Encode(e)
		}
	}
	{
		if s.ConnectedWebsite.Set {
			e.Comma()
		}
		if s.ConnectedWebsite.Set {
			e.RawStr("\"connected_website\"" + ":")
			s.ConnectedWebsite.Encode(e)
		}
	}
	{
		if s.PassportData.Set {
			e.Comma()
		}
		if s.PassportData.Set {
			e.RawStr("\"passport_data\"" + ":")
			s.PassportData.Encode(e)
		}
	}
	{
		if s.ProximityAlertTriggered.Set {
			e.Comma()
		}
		if s.ProximityAlertTriggered.Set {
			e.RawStr("\"proximity_alert_triggered\"" + ":")
			s.ProximityAlertTriggered.Encode(e)
		}
	}
	{
		if s.VoiceChatScheduled.Set {
			e.Comma()
		}
		if s.VoiceChatScheduled.Set {
			e.RawStr("\"voice_chat_scheduled\"" + ":")
			s.VoiceChatScheduled.Encode(e)
		}
	}
	{
		if s.VoiceChatStarted != nil {
			e.Comma()
		}
		if s.VoiceChatStarted != nil {
			e.RawStr("\"voice_chat_started\"" + ":")
			s.VoiceChatStarted.Encode(e)
		}
	}
	{
		if s.VoiceChatEnded.Set {
			e.Comma()
		}
		if s.VoiceChatEnded.Set {
			e.RawStr("\"voice_chat_ended\"" + ":")
			s.VoiceChatEnded.Encode(e)
		}
	}
	{
		if s.VoiceChatParticipantsInvited.Set {
			e.Comma()
		}
		if s.VoiceChatParticipantsInvited.Set {
			e.RawStr("\"voice_chat_participants_invited\"" + ":")
			s.VoiceChatParticipantsInvited.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	{
		if s.NewChatMember.Set {
			e.Comma()
		}
		if s.NewChatMember.Set {
			e.RawStr("\"new_chat_member\"" + ":")
			s.NewChatMember.Encode(e)
		}
	}
	{
		if s.NewChatParticipant.Set {
			e.Comma()
		}
		if s.NewChatParticipant.Set {
			e.RawStr("\"new_chat_participant\"" + ":")
			s.NewChatParticipant.Encode(e)
		}
	}
	{
		if s.LeftChatParticipant.Set {
			e.Comma()
		}
		if s.LeftChatParticipant.Set {
			e.RawStr("\"left_chat_participant\"" + ":")
			s.LeftChatParticipant.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMessage = [61]string{
	0:  "message_id",
	1:  "from",
	2:  "sender_chat",
	3:  "date",
	4:  "chat",
	5:  "forward_from",
	6:  "forward_from_chat",
	7:  "forward_from_message_id",
	8:  "forward_signature",
	9:  "forward_sender_name",
	10: "forward_date",
	11: "is_automatic_forward",
	12: "reply_to_message",
	13: "via_bot",
	14: "edit_date",
	15: "has_protected_content",
	16: "media_group_id",
	17: "author_signature",
	18: "text",
	19: "entities",
	20: "animation",
	21: "audio",
	22: "document",
	23: "photo",
	24: "sticker",
	25: "video",
	26: "video_note",
	27: "voice",
	28: "caption",
	29: "caption_entities",
	30: "contact",
	31: "dice",
	32: "game",
	33: "poll",
	34: "venue",
	35: "location",
	36: "new_chat_members",
	37: "left_chat_member",
	38: "new_chat_title",
	39: "new_chat_photo",
	40: "delete_chat_photo",
	41: "group_chat_created",
	42: "supergroup_chat_created",
	43: "channel_chat_created",
	44: "message_auto_delete_timer_changed",
	45: "migrate_to_chat_id",
	46: "migrate_from_chat_id",
	47: "pinned_message",
	48: "invoice",
	49: "successful_payment",
	50: "connected_website",
	51: "passport_data",
	52: "proximity_alert_triggered",
	53: "voice_chat_scheduled",
	54: "voice_chat_started",
	55: "voice_chat_ended",
	56: "voice_chat_participants_invited",
	57: "reply_markup",
	58: "new_chat_member",
	59: "new_chat_participant",
	60: "left_chat_participant",
}

// Decode decodes Message from json.
func (s *Message) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Message to nil`)
	}
	var requiredBitSet [8]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.MessageID = int(v)
			if err != nil {
				return err
			}
		case "from":
			s.From.Reset()
			if err := s.From.Decode(d); err != nil {
				return err
			}
		case "sender_chat":
			s.SenderChat.Reset()
			if err := s.SenderChat.Decode(d); err != nil {
				return err
			}
		case "date":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Int()
			s.Date = int(v)
			if err != nil {
				return err
			}
		case "chat":
			requiredBitSet[0] |= 1 << 4
			if err := s.Chat.Decode(d); err != nil {
				return err
			}
		case "forward_from":
			s.ForwardFrom.Reset()
			if err := s.ForwardFrom.Decode(d); err != nil {
				return err
			}
		case "forward_from_chat":
			s.ForwardFromChat.Reset()
			if err := s.ForwardFromChat.Decode(d); err != nil {
				return err
			}
		case "forward_from_message_id":
			s.ForwardFromMessageID.Reset()
			if err := s.ForwardFromMessageID.Decode(d); err != nil {
				return err
			}
		case "forward_signature":
			s.ForwardSignature.Reset()
			if err := s.ForwardSignature.Decode(d); err != nil {
				return err
			}
		case "forward_sender_name":
			s.ForwardSenderName.Reset()
			if err := s.ForwardSenderName.Decode(d); err != nil {
				return err
			}
		case "forward_date":
			s.ForwardDate.Reset()
			if err := s.ForwardDate.Decode(d); err != nil {
				return err
			}
		case "is_automatic_forward":
			s.IsAutomaticForward.Reset()
			if err := s.IsAutomaticForward.Decode(d); err != nil {
				return err
			}
		case "reply_to_message":
			s.ReplyToMessage = nil
			var elem Message
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ReplyToMessage = &elem
		case "via_bot":
			s.ViaBot.Reset()
			if err := s.ViaBot.Decode(d); err != nil {
				return err
			}
		case "edit_date":
			s.EditDate.Reset()
			if err := s.EditDate.Decode(d); err != nil {
				return err
			}
		case "has_protected_content":
			s.HasProtectedContent.Reset()
			if err := s.HasProtectedContent.Decode(d); err != nil {
				return err
			}
		case "media_group_id":
			s.MediaGroupID.Reset()
			if err := s.MediaGroupID.Decode(d); err != nil {
				return err
			}
		case "author_signature":
			s.AuthorSignature.Reset()
			if err := s.AuthorSignature.Decode(d); err != nil {
				return err
			}
		case "text":
			s.Text.Reset()
			if err := s.Text.Decode(d); err != nil {
				return err
			}
		case "entities":
			s.Entities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Entities = append(s.Entities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "animation":
			s.Animation.Reset()
			if err := s.Animation.Decode(d); err != nil {
				return err
			}
		case "audio":
			s.Audio.Reset()
			if err := s.Audio.Decode(d); err != nil {
				return err
			}
		case "document":
			s.Document.Reset()
			if err := s.Document.Decode(d); err != nil {
				return err
			}
		case "photo":
			s.Photo = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PhotoSize
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Photo = append(s.Photo, elem)
				return nil
			}); err != nil {
				return err
			}
		case "sticker":
			s.Sticker.Reset()
			if err := s.Sticker.Decode(d); err != nil {
				return err
			}
		case "video":
			s.Video.Reset()
			if err := s.Video.Decode(d); err != nil {
				return err
			}
		case "video_note":
			s.VideoNote.Reset()
			if err := s.VideoNote.Decode(d); err != nil {
				return err
			}
		case "voice":
			s.Voice.Reset()
			if err := s.Voice.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "contact":
			s.Contact.Reset()
			if err := s.Contact.Decode(d); err != nil {
				return err
			}
		case "dice":
			s.Dice.Reset()
			if err := s.Dice.Decode(d); err != nil {
				return err
			}
		case "game":
			s.Game.Reset()
			if err := s.Game.Decode(d); err != nil {
				return err
			}
		case "poll":
			s.Poll.Reset()
			if err := s.Poll.Decode(d); err != nil {
				return err
			}
		case "venue":
			s.Venue.Reset()
			if err := s.Venue.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "new_chat_members":
			s.NewChatMembers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem User
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.NewChatMembers = append(s.NewChatMembers, elem)
				return nil
			}); err != nil {
				return err
			}
		case "left_chat_member":
			s.LeftChatMember.Reset()
			if err := s.LeftChatMember.Decode(d); err != nil {
				return err
			}
		case "new_chat_title":
			s.NewChatTitle.Reset()
			if err := s.NewChatTitle.Decode(d); err != nil {
				return err
			}
		case "new_chat_photo":
			s.NewChatPhoto = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PhotoSize
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.NewChatPhoto = append(s.NewChatPhoto, elem)
				return nil
			}); err != nil {
				return err
			}
		case "delete_chat_photo":
			s.DeleteChatPhoto.Reset()
			if err := s.DeleteChatPhoto.Decode(d); err != nil {
				return err
			}
		case "group_chat_created":
			s.GroupChatCreated.Reset()
			if err := s.GroupChatCreated.Decode(d); err != nil {
				return err
			}
		case "supergroup_chat_created":
			s.SupergroupChatCreated.Reset()
			if err := s.SupergroupChatCreated.Decode(d); err != nil {
				return err
			}
		case "channel_chat_created":
			s.ChannelChatCreated.Reset()
			if err := s.ChannelChatCreated.Decode(d); err != nil {
				return err
			}
		case "message_auto_delete_timer_changed":
			s.MessageAutoDeleteTimerChanged.Reset()
			if err := s.MessageAutoDeleteTimerChanged.Decode(d); err != nil {
				return err
			}
		case "migrate_to_chat_id":
			s.MigrateToChatID.Reset()
			if err := s.MigrateToChatID.Decode(d); err != nil {
				return err
			}
		case "migrate_from_chat_id":
			s.MigrateFromChatID.Reset()
			if err := s.MigrateFromChatID.Decode(d); err != nil {
				return err
			}
		case "pinned_message":
			s.PinnedMessage = nil
			var elem Message
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.PinnedMessage = &elem
		case "invoice":
			s.Invoice.Reset()
			if err := s.Invoice.Decode(d); err != nil {
				return err
			}
		case "successful_payment":
			s.SuccessfulPayment.Reset()
			if err := s.SuccessfulPayment.Decode(d); err != nil {
				return err
			}
		case "connected_website":
			s.ConnectedWebsite.Reset()
			if err := s.ConnectedWebsite.Decode(d); err != nil {
				return err
			}
		case "passport_data":
			s.PassportData.Reset()
			if err := s.PassportData.Decode(d); err != nil {
				return err
			}
		case "proximity_alert_triggered":
			s.ProximityAlertTriggered.Reset()
			if err := s.ProximityAlertTriggered.Decode(d); err != nil {
				return err
			}
		case "voice_chat_scheduled":
			s.VoiceChatScheduled.Reset()
			if err := s.VoiceChatScheduled.Decode(d); err != nil {
				return err
			}
		case "voice_chat_started":
			s.VoiceChatStarted = nil
			var elem VoiceChatStarted
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.VoiceChatStarted = &elem
		case "voice_chat_ended":
			s.VoiceChatEnded.Reset()
			if err := s.VoiceChatEnded.Decode(d); err != nil {
				return err
			}
		case "voice_chat_participants_invited":
			s.VoiceChatParticipantsInvited.Reset()
			if err := s.VoiceChatParticipantsInvited.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		case "new_chat_member":
			s.NewChatMember.Reset()
			if err := s.NewChatMember.Decode(d); err != nil {
				return err
			}
		case "new_chat_participant":
			s.NewChatParticipant.Reset()
			if err := s.NewChatParticipant.Decode(d); err != nil {
				return err
			}
		case "left_chat_participant":
			s.LeftChatParticipant.Reset()
			if err := s.LeftChatParticipant.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [8]uint8{
		0b00011001,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessage) {
					name = jsonFieldsNameOfMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MessageAutoDeleteTimerChanged) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message_auto_delete_time\"" + ":")
		e.Int(s.MessageAutoDeleteTime)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMessageAutoDeleteTimerChanged = [1]string{
	0: "message_auto_delete_time",
}

// Decode decodes MessageAutoDeleteTimerChanged from json.
func (s *MessageAutoDeleteTimerChanged) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MessageAutoDeleteTimerChanged to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message_auto_delete_time":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.MessageAutoDeleteTime = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageAutoDeleteTimerChanged) {
					name = jsonFieldsNameOfMessageAutoDeleteTimerChanged[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MessageEntity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"offset\"" + ":")
		e.Int(s.Offset)
	}
	{
		e.Comma()

		e.RawStr("\"length\"" + ":")
		e.Int(s.Length)
	}
	{
		if s.URL.Set {
			e.Comma()
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.Comma()
		}
		if s.Language.Set {
			e.RawStr("\"language\"" + ":")
			s.Language.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMessageEntity = [6]string{
	0: "type",
	1: "offset",
	2: "length",
	3: "url",
	4: "user",
	5: "language",
}

// Decode decodes MessageEntity from json.
func (s *MessageEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MessageEntity to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "offset":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int()
			s.Offset = int(v)
			if err != nil {
				return err
			}
		case "length":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.Length = int(v)
			if err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "language":
			s.Language.Reset()
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageEntity) {
					name = jsonFieldsNameOfMessageEntity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes MessageEntityType as json.
func (s MessageEntityType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MessageEntityType from json.
func (s *MessageEntityType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MessageEntityType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MessageEntityType(v) {
	case MessageEntityTypeMention:
		*s = MessageEntityTypeMention
	case MessageEntityTypeHashtag:
		*s = MessageEntityTypeHashtag
	case MessageEntityTypeCashtag:
		*s = MessageEntityTypeCashtag
	case MessageEntityTypeBotCommand:
		*s = MessageEntityTypeBotCommand
	case MessageEntityTypeURL:
		*s = MessageEntityTypeURL
	case MessageEntityTypeEmail:
		*s = MessageEntityTypeEmail
	case MessageEntityTypePhoneNumber:
		*s = MessageEntityTypePhoneNumber
	case MessageEntityTypeBold:
		*s = MessageEntityTypeBold
	case MessageEntityTypeItalic:
		*s = MessageEntityTypeItalic
	case MessageEntityTypeUnderline:
		*s = MessageEntityTypeUnderline
	case MessageEntityTypeStrikethrough:
		*s = MessageEntityTypeStrikethrough
	case MessageEntityTypeSpoiler:
		*s = MessageEntityTypeSpoiler
	case MessageEntityTypeCode:
		*s = MessageEntityTypeCode
	case MessageEntityTypePre:
		*s = MessageEntityTypePre
	case MessageEntityTypeTextLink:
		*s = MessageEntityTypeTextLink
	case MessageEntityTypeTextMention:
		*s = MessageEntityTypeTextMention
	default:
		*s = MessageEntityType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MessageId) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message_id\"" + ":")
		e.Int(s.MessageID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMessageId = [1]string{
	0: "message_id",
}

// Decode decodes MessageId from json.
func (s *MessageId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MessageId to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.MessageID = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageId) {
					name = jsonFieldsNameOfMessageId[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes Animation as json.
func (o OptAnimation) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Animation from json.
func (o *OptAnimation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAnimation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAnimation`, d.Next())
	}
}

// Encode encodes Audio as json.
func (o OptAudio) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Audio from json.
func (o *OptAudio) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAudio to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAudio`, d.Next())
	}
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBool to nil`)
	}
	switch d.Next() {
	case jx.Bool:
		o.Set = true
		v, err := d.Bool()
		if err != nil {
			return err
		}
		o.Value = bool(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBool`, d.Next())
	}
}

// Encode encodes BotCommandScope as json.
func (o OptBotCommandScope) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BotCommandScope from json.
func (o *OptBotCommandScope) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBotCommandScope to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBotCommandScope`, d.Next())
	}
}

// Encode encodes CallbackQuery as json.
func (o OptCallbackQuery) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallbackQuery from json.
func (o *OptCallbackQuery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCallbackQuery to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCallbackQuery`, d.Next())
	}
}

// Encode encodes Chat as json.
func (o OptChat) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Chat from json.
func (o *OptChat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChat to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChat`, d.Next())
	}
}

// Encode encodes ChatInviteLink as json.
func (o OptChatInviteLink) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatInviteLink from json.
func (o *OptChatInviteLink) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChatInviteLink to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChatInviteLink`, d.Next())
	}
}

// Encode encodes ChatJoinRequest as json.
func (o OptChatJoinRequest) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatJoinRequest from json.
func (o *OptChatJoinRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChatJoinRequest to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChatJoinRequest`, d.Next())
	}
}

// Encode encodes ChatLocation as json.
func (o OptChatLocation) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatLocation from json.
func (o *OptChatLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChatLocation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChatLocation`, d.Next())
	}
}

// Encode encodes ChatMember as json.
func (o OptChatMember) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatMember from json.
func (o *OptChatMember) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChatMember to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChatMember`, d.Next())
	}
}

// Encode encodes ChatMemberUpdated as json.
func (o OptChatMemberUpdated) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatMemberUpdated from json.
func (o *OptChatMemberUpdated) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChatMemberUpdated to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChatMemberUpdated`, d.Next())
	}
}

// Encode encodes ChatPermissions as json.
func (o OptChatPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatPermissions from json.
func (o *OptChatPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChatPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChatPermissions`, d.Next())
	}
}

// Encode encodes ChatPhoto as json.
func (o OptChatPhoto) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatPhoto from json.
func (o *OptChatPhoto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChatPhoto to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChatPhoto`, d.Next())
	}
}

// Encode encodes ChosenInlineResult as json.
func (o OptChosenInlineResult) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChosenInlineResult from json.
func (o *OptChosenInlineResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChosenInlineResult to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChosenInlineResult`, d.Next())
	}
}

// Encode encodes Contact as json.
func (o OptContact) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Contact from json.
func (o *OptContact) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptContact to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptContact`, d.Next())
	}
}

// Encode encodes DeleteMyCommands as json.
func (o OptDeleteMyCommands) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeleteMyCommands from json.
func (o *OptDeleteMyCommands) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptDeleteMyCommands to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptDeleteMyCommands`, d.Next())
	}
}

// Encode encodes DeleteWebhook as json.
func (o OptDeleteWebhook) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeleteWebhook from json.
func (o *OptDeleteWebhook) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptDeleteWebhook to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptDeleteWebhook`, d.Next())
	}
}

// Encode encodes Dice as json.
func (o OptDice) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Dice from json.
func (o *OptDice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptDice to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptDice`, d.Next())
	}
}

// Encode encodes Document as json.
func (o OptDocument) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Document from json.
func (o *OptDocument) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptDocument to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptDocument`, d.Next())
	}
}

// Encode encodes File as json.
func (o OptFile) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes File from json.
func (o *OptFile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFile to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFile`, d.Next())
	}
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFloat64 to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Float64()
		if err != nil {
			return err
		}
		o.Value = float64(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFloat64`, d.Next())
	}
}

// Encode encodes Game as json.
func (o OptGame) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Game from json.
func (o *OptGame) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGame to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGame`, d.Next())
	}
}

// Encode encodes GetMyCommands as json.
func (o OptGetMyCommands) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetMyCommands from json.
func (o *OptGetMyCommands) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGetMyCommands to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGetMyCommands`, d.Next())
	}
}

// Encode encodes GetUpdates as json.
func (o OptGetUpdates) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetUpdates from json.
func (o *OptGetUpdates) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGetUpdates to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGetUpdates`, d.Next())
	}
}

// Encode encodes ID as json.
func (o OptID) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ID from json.
func (o *OptID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptID to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptID`, d.Next())
	}
}

// Encode encodes InlineKeyboardMarkup as json.
func (o OptInlineKeyboardMarkup) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InlineKeyboardMarkup from json.
func (o *OptInlineKeyboardMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInlineKeyboardMarkup to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInlineKeyboardMarkup`, d.Next())
	}
}

// Encode encodes InlineQuery as json.
func (o OptInlineQuery) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InlineQuery from json.
func (o *OptInlineQuery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInlineQuery to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInlineQuery`, d.Next())
	}
}

// Encode encodes InlineQueryChatType as json.
func (o OptInlineQueryChatType) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InlineQueryChatType from json.
func (o *OptInlineQueryChatType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInlineQueryChatType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInlineQueryChatType`, d.Next())
	}
}

// Encode encodes InputMessageContent as json.
func (o OptInputMessageContent) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InputMessageContent from json.
func (o *OptInputMessageContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInputMessageContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInputMessageContent`, d.Next())
	}
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInt to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int()
		if err != nil {
			return err
		}
		o.Value = int(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInt`, d.Next())
	}
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInt64 to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int64()
		if err != nil {
			return err
		}
		o.Value = int64(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInt64`, d.Next())
	}
}

// Encode encodes Invoice as json.
func (o OptInvoice) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Invoice from json.
func (o *OptInvoice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInvoice to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInvoice`, d.Next())
	}
}

// Encode encodes KeyboardButtonPollType as json.
func (o OptKeyboardButtonPollType) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes KeyboardButtonPollType from json.
func (o *OptKeyboardButtonPollType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptKeyboardButtonPollType to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptKeyboardButtonPollType`, d.Next())
	}
}

// Encode encodes Location as json.
func (o OptLocation) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Location from json.
func (o *OptLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptLocation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptLocation`, d.Next())
	}
}

// Encode encodes LoginUrl as json.
func (o OptLoginUrl) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LoginUrl from json.
func (o *OptLoginUrl) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptLoginUrl to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptLoginUrl`, d.Next())
	}
}

// Encode encodes MaskPosition as json.
func (o OptMaskPosition) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MaskPosition from json.
func (o *OptMaskPosition) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMaskPosition to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMaskPosition`, d.Next())
	}
}

// Encode encodes Message as json.
func (o OptMessage) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Message from json.
func (o *OptMessage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMessage to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMessage`, d.Next())
	}
}

// Encode encodes MessageAutoDeleteTimerChanged as json.
func (o OptMessageAutoDeleteTimerChanged) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MessageAutoDeleteTimerChanged from json.
func (o *OptMessageAutoDeleteTimerChanged) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMessageAutoDeleteTimerChanged to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMessageAutoDeleteTimerChanged`, d.Next())
	}
}

// Encode encodes MessageId as json.
func (o OptMessageId) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MessageId from json.
func (o *OptMessageId) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMessageId to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMessageId`, d.Next())
	}
}

// Encode encodes OrderInfo as json.
func (o OptOrderInfo) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrderInfo from json.
func (o *OptOrderInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrderInfo to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrderInfo`, d.Next())
	}
}

// Encode encodes PassportData as json.
func (o OptPassportData) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PassportData from json.
func (o *OptPassportData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPassportData to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPassportData`, d.Next())
	}
}

// Encode encodes PassportFile as json.
func (o OptPassportFile) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PassportFile from json.
func (o *OptPassportFile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPassportFile to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPassportFile`, d.Next())
	}
}

// Encode encodes PhotoSize as json.
func (o OptPhotoSize) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PhotoSize from json.
func (o *OptPhotoSize) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPhotoSize to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPhotoSize`, d.Next())
	}
}

// Encode encodes Poll as json.
func (o OptPoll) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Poll from json.
func (o *OptPoll) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPoll to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPoll`, d.Next())
	}
}

// Encode encodes PollAnswer as json.
func (o OptPollAnswer) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PollAnswer from json.
func (o *OptPollAnswer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPollAnswer to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPollAnswer`, d.Next())
	}
}

// Encode encodes PreCheckoutQuery as json.
func (o OptPreCheckoutQuery) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PreCheckoutQuery from json.
func (o *OptPreCheckoutQuery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPreCheckoutQuery to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPreCheckoutQuery`, d.Next())
	}
}

// Encode encodes ProximityAlertTriggered as json.
func (o OptProximityAlertTriggered) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProximityAlertTriggered from json.
func (o *OptProximityAlertTriggered) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProximityAlertTriggered to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProximityAlertTriggered`, d.Next())
	}
}

// Encode encodes Response as json.
func (o OptResponse) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Response from json.
func (o *OptResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptResponse to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptResponse`, d.Next())
	}
}

// Encode encodes ResultMessageOrBooleanResult as json.
func (o OptResultMessageOrBooleanResult) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResultMessageOrBooleanResult from json.
func (o *OptResultMessageOrBooleanResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptResultMessageOrBooleanResult to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptResultMessageOrBooleanResult`, d.Next())
	}
}

// Encode encodes SendReplyMarkup as json.
func (o OptSendReplyMarkup) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendReplyMarkup from json.
func (o *OptSendReplyMarkup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSendReplyMarkup to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSendReplyMarkup`, d.Next())
	}
}

// Encode encodes ShippingAddress as json.
func (o OptShippingAddress) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ShippingAddress from json.
func (o *OptShippingAddress) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptShippingAddress to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptShippingAddress`, d.Next())
	}
}

// Encode encodes ShippingQuery as json.
func (o OptShippingQuery) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ShippingQuery from json.
func (o *OptShippingQuery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptShippingQuery to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptShippingQuery`, d.Next())
	}
}

// Encode encodes Sticker as json.
func (o OptSticker) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Sticker from json.
func (o *OptSticker) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSticker to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSticker`, d.Next())
	}
}

// Encode encodes StickerSet as json.
func (o OptStickerSet) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes StickerSet from json.
func (o *OptStickerSet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptStickerSet to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptStickerSet`, d.Next())
	}
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptString to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptString`, d.Next())
	}
}

// Encode encodes SuccessfulPayment as json.
func (o OptSuccessfulPayment) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessfulPayment from json.
func (o *OptSuccessfulPayment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSuccessfulPayment to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSuccessfulPayment`, d.Next())
	}
}

// Encode encodes User as json.
func (o OptUser) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes User from json.
func (o *OptUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptUser to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptUser`, d.Next())
	}
}

// Encode encodes UserProfilePhotos as json.
func (o OptUserProfilePhotos) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserProfilePhotos from json.
func (o *OptUserProfilePhotos) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptUserProfilePhotos to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptUserProfilePhotos`, d.Next())
	}
}

// Encode encodes Venue as json.
func (o OptVenue) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Venue from json.
func (o *OptVenue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptVenue to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptVenue`, d.Next())
	}
}

// Encode encodes Video as json.
func (o OptVideo) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Video from json.
func (o *OptVideo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptVideo to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptVideo`, d.Next())
	}
}

// Encode encodes VideoNote as json.
func (o OptVideoNote) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VideoNote from json.
func (o *OptVideoNote) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptVideoNote to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptVideoNote`, d.Next())
	}
}

// Encode encodes Voice as json.
func (o OptVoice) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Voice from json.
func (o *OptVoice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptVoice to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptVoice`, d.Next())
	}
}

// Encode encodes VoiceChatEnded as json.
func (o OptVoiceChatEnded) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VoiceChatEnded from json.
func (o *OptVoiceChatEnded) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptVoiceChatEnded to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptVoiceChatEnded`, d.Next())
	}
}

// Encode encodes VoiceChatParticipantsInvited as json.
func (o OptVoiceChatParticipantsInvited) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VoiceChatParticipantsInvited from json.
func (o *OptVoiceChatParticipantsInvited) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptVoiceChatParticipantsInvited to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptVoiceChatParticipantsInvited`, d.Next())
	}
}

// Encode encodes VoiceChatScheduled as json.
func (o OptVoiceChatScheduled) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VoiceChatScheduled from json.
func (o *OptVoiceChatScheduled) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptVoiceChatScheduled to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptVoiceChatScheduled`, d.Next())
	}
}

// Encode encodes WebhookInfo as json.
func (o OptWebhookInfo) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookInfo from json.
func (o *OptWebhookInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptWebhookInfo to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptWebhookInfo`, d.Next())
	}
}

// Encode implements json.Marshaler.
func (s OrderInfo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.PhoneNumber.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PhoneNumber.Set {
			e.RawStr("\"phone_number\"" + ":")
			s.PhoneNumber.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.ShippingAddress.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ShippingAddress.Set {
			e.RawStr("\"shipping_address\"" + ":")
			s.ShippingAddress.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrderInfo = [4]string{
	0: "name",
	1: "phone_number",
	2: "email",
	3: "shipping_address",
}

// Decode decodes OrderInfo from json.
func (s *OrderInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrderInfo to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "phone_number":
			s.PhoneNumber.Reset()
			if err := s.PhoneNumber.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "shipping_address":
			s.ShippingAddress.Reset()
			if err := s.ShippingAddress.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PassportData) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"data\"" + ":")
		e.ArrStart()
		if len(s.Data) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Data[0]
				elem.Encode(e)
			}
			for _, elem := range s.Data[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"credentials\"" + ":")
		s.Credentials.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPassportData = [2]string{
	0: "data",
	1: "credentials",
}

// Decode decodes PassportData from json.
func (s *PassportData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportData to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			s.Data = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EncryptedPassportElement
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Data = append(s.Data, elem)
				return nil
			}); err != nil {
				return err
			}
		case "credentials":
			requiredBitSet[0] |= 1 << 1
			if err := s.Credentials.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportData) {
					name = jsonFieldsNameOfPassportData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PassportElementError as json.
func (s PassportElementError) Encode(e *jx.Writer) {
	switch s.Type {
	case PassportElementErrorDataFieldPassportElementError:
		s.PassportElementErrorDataField.Encode(e)
	case PassportElementErrorFrontSidePassportElementError:
		s.PassportElementErrorFrontSide.Encode(e)
	case PassportElementErrorReverseSidePassportElementError:
		s.PassportElementErrorReverseSide.Encode(e)
	case PassportElementErrorSelfiePassportElementError:
		s.PassportElementErrorSelfie.Encode(e)
	case PassportElementErrorFilePassportElementError:
		s.PassportElementErrorFile.Encode(e)
	case PassportElementErrorFilesPassportElementError:
		s.PassportElementErrorFiles.Encode(e)
	case PassportElementErrorTranslationFilePassportElementError:
		s.PassportElementErrorTranslationFile.Encode(e)
	case PassportElementErrorTranslationFilesPassportElementError:
		s.PassportElementErrorTranslationFiles.Encode(e)
	case PassportElementErrorUnspecifiedPassportElementError:
		s.PassportElementErrorUnspecified.Encode(e)
	}
}

// Decode decodes PassportElementError from json.
func (s *PassportElementError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementError to nil`)
	}
	// Sum type discriminator.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "data":
					s.Type = PassportElementErrorDataFieldPassportElementError
					found = true
				case "file":
					s.Type = PassportElementErrorFilePassportElementError
					found = true
				case "files":
					s.Type = PassportElementErrorFilesPassportElementError
					found = true
				case "front_side":
					s.Type = PassportElementErrorFrontSidePassportElementError
					found = true
				case "reverse_side":
					s.Type = PassportElementErrorReverseSidePassportElementError
					found = true
				case "selfie":
					s.Type = PassportElementErrorSelfiePassportElementError
					found = true
				case "translation_file":
					s.Type = PassportElementErrorTranslationFilePassportElementError
					found = true
				case "translation_files":
					s.Type = PassportElementErrorTranslationFilesPassportElementError
					found = true
				case "unspecified":
					s.Type = PassportElementErrorUnspecifiedPassportElementError
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PassportElementErrorDataFieldPassportElementError:
		if err := s.PassportElementErrorDataField.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorFrontSidePassportElementError:
		if err := s.PassportElementErrorFrontSide.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorReverseSidePassportElementError:
		if err := s.PassportElementErrorReverseSide.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorSelfiePassportElementError:
		if err := s.PassportElementErrorSelfie.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorFilePassportElementError:
		if err := s.PassportElementErrorFile.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorFilesPassportElementError:
		if err := s.PassportElementErrorFiles.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorTranslationFilePassportElementError:
		if err := s.PassportElementErrorTranslationFile.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorTranslationFilesPassportElementError:
		if err := s.PassportElementErrorTranslationFiles.Decode(d); err != nil {
			return err
		}
	case PassportElementErrorUnspecifiedPassportElementError:
		if err := s.PassportElementErrorUnspecified.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s PassportElementErrorDataField) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"source\"" + ":")
		e.Str(s.Source)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"field_name\"" + ":")
		e.Str(s.FieldName)
	}
	{
		e.Comma()

		e.RawStr("\"data_hash\"" + ":")
		e.Str(s.DataHash)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPassportElementErrorDataField = [5]string{
	0: "source",
	1: "type",
	2: "field_name",
	3: "data_hash",
	4: "message",
}

// Decode decodes PassportElementErrorDataField from json.
func (s *PassportElementErrorDataField) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorDataField to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "field_name":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.FieldName = string(v)
			if err != nil {
				return err
			}
		case "data_hash":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.DataHash = string(v)
			if err != nil {
				return err
			}
		case "message":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorDataField) {
					name = jsonFieldsNameOfPassportElementErrorDataField[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PassportElementErrorDataFieldType as json.
func (s PassportElementErrorDataFieldType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorDataFieldType from json.
func (s *PassportElementErrorDataFieldType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorDataFieldType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorDataFieldType(v) {
	case PassportElementErrorDataFieldTypePersonalDetails:
		*s = PassportElementErrorDataFieldTypePersonalDetails
	case PassportElementErrorDataFieldTypePassport:
		*s = PassportElementErrorDataFieldTypePassport
	case PassportElementErrorDataFieldTypeDriverLicense:
		*s = PassportElementErrorDataFieldTypeDriverLicense
	case PassportElementErrorDataFieldTypeIdentityCard:
		*s = PassportElementErrorDataFieldTypeIdentityCard
	case PassportElementErrorDataFieldTypeInternalPassport:
		*s = PassportElementErrorDataFieldTypeInternalPassport
	case PassportElementErrorDataFieldTypeAddress:
		*s = PassportElementErrorDataFieldTypeAddress
	default:
		*s = PassportElementErrorDataFieldType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PassportElementErrorFile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"source\"" + ":")
		e.Str(s.Source)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"file_hash\"" + ":")
		e.Str(s.FileHash)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPassportElementErrorFile = [4]string{
	0: "source",
	1: "type",
	2: "file_hash",
	3: "message",
}

// Decode decodes PassportElementErrorFile from json.
func (s *PassportElementErrorFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorFile to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "file_hash":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.FileHash = string(v)
			if err != nil {
				return err
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorFile) {
					name = jsonFieldsNameOfPassportElementErrorFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PassportElementErrorFileType as json.
func (s PassportElementErrorFileType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorFileType from json.
func (s *PassportElementErrorFileType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorFileType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorFileType(v) {
	case PassportElementErrorFileTypeUtilityBill:
		*s = PassportElementErrorFileTypeUtilityBill
	case PassportElementErrorFileTypeBankStatement:
		*s = PassportElementErrorFileTypeBankStatement
	case PassportElementErrorFileTypeRentalAgreement:
		*s = PassportElementErrorFileTypeRentalAgreement
	case PassportElementErrorFileTypePassportRegistration:
		*s = PassportElementErrorFileTypePassportRegistration
	case PassportElementErrorFileTypeTemporaryRegistration:
		*s = PassportElementErrorFileTypeTemporaryRegistration
	default:
		*s = PassportElementErrorFileType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PassportElementErrorFiles) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"source\"" + ":")
		e.Str(s.Source)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"file_hashes\"" + ":")
		e.ArrStart()
		if len(s.FileHashes) >= 1 {
			// Encode first element without comma.
			{
				elem := s.FileHashes[0]
				e.Str(elem)
			}
			for _, elem := range s.FileHashes[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPassportElementErrorFiles = [4]string{
	0: "source",
	1: "type",
	2: "file_hashes",
	3: "message",
}

// Decode decodes PassportElementErrorFiles from json.
func (s *PassportElementErrorFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorFiles to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "file_hashes":
			requiredBitSet[0] |= 1 << 2
			s.FileHashes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.FileHashes = append(s.FileHashes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorFiles) {
					name = jsonFieldsNameOfPassportElementErrorFiles[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PassportElementErrorFilesType as json.
func (s PassportElementErrorFilesType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorFilesType from json.
func (s *PassportElementErrorFilesType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorFilesType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorFilesType(v) {
	case PassportElementErrorFilesTypeUtilityBill:
		*s = PassportElementErrorFilesTypeUtilityBill
	case PassportElementErrorFilesTypeBankStatement:
		*s = PassportElementErrorFilesTypeBankStatement
	case PassportElementErrorFilesTypeRentalAgreement:
		*s = PassportElementErrorFilesTypeRentalAgreement
	case PassportElementErrorFilesTypePassportRegistration:
		*s = PassportElementErrorFilesTypePassportRegistration
	case PassportElementErrorFilesTypeTemporaryRegistration:
		*s = PassportElementErrorFilesTypeTemporaryRegistration
	default:
		*s = PassportElementErrorFilesType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PassportElementErrorFrontSide) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"source\"" + ":")
		e.Str(s.Source)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"file_hash\"" + ":")
		e.Str(s.FileHash)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPassportElementErrorFrontSide = [4]string{
	0: "source",
	1: "type",
	2: "file_hash",
	3: "message",
}

// Decode decodes PassportElementErrorFrontSide from json.
func (s *PassportElementErrorFrontSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorFrontSide to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "file_hash":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.FileHash = string(v)
			if err != nil {
				return err
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorFrontSide) {
					name = jsonFieldsNameOfPassportElementErrorFrontSide[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PassportElementErrorFrontSideType as json.
func (s PassportElementErrorFrontSideType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorFrontSideType from json.
func (s *PassportElementErrorFrontSideType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorFrontSideType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorFrontSideType(v) {
	case PassportElementErrorFrontSideTypePassport:
		*s = PassportElementErrorFrontSideTypePassport
	case PassportElementErrorFrontSideTypeDriverLicense:
		*s = PassportElementErrorFrontSideTypeDriverLicense
	case PassportElementErrorFrontSideTypeIdentityCard:
		*s = PassportElementErrorFrontSideTypeIdentityCard
	case PassportElementErrorFrontSideTypeInternalPassport:
		*s = PassportElementErrorFrontSideTypeInternalPassport
	default:
		*s = PassportElementErrorFrontSideType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PassportElementErrorReverseSide) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"source\"" + ":")
		e.Str(s.Source)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"file_hash\"" + ":")
		e.Str(s.FileHash)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPassportElementErrorReverseSide = [4]string{
	0: "source",
	1: "type",
	2: "file_hash",
	3: "message",
}

// Decode decodes PassportElementErrorReverseSide from json.
func (s *PassportElementErrorReverseSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorReverseSide to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "file_hash":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.FileHash = string(v)
			if err != nil {
				return err
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorReverseSide) {
					name = jsonFieldsNameOfPassportElementErrorReverseSide[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PassportElementErrorReverseSideType as json.
func (s PassportElementErrorReverseSideType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorReverseSideType from json.
func (s *PassportElementErrorReverseSideType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorReverseSideType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorReverseSideType(v) {
	case PassportElementErrorReverseSideTypeDriverLicense:
		*s = PassportElementErrorReverseSideTypeDriverLicense
	case PassportElementErrorReverseSideTypeIdentityCard:
		*s = PassportElementErrorReverseSideTypeIdentityCard
	default:
		*s = PassportElementErrorReverseSideType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PassportElementErrorSelfie) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"source\"" + ":")
		e.Str(s.Source)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"file_hash\"" + ":")
		e.Str(s.FileHash)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPassportElementErrorSelfie = [4]string{
	0: "source",
	1: "type",
	2: "file_hash",
	3: "message",
}

// Decode decodes PassportElementErrorSelfie from json.
func (s *PassportElementErrorSelfie) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorSelfie to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "file_hash":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.FileHash = string(v)
			if err != nil {
				return err
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorSelfie) {
					name = jsonFieldsNameOfPassportElementErrorSelfie[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PassportElementErrorSelfieType as json.
func (s PassportElementErrorSelfieType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorSelfieType from json.
func (s *PassportElementErrorSelfieType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorSelfieType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorSelfieType(v) {
	case PassportElementErrorSelfieTypePassport:
		*s = PassportElementErrorSelfieTypePassport
	case PassportElementErrorSelfieTypeDriverLicense:
		*s = PassportElementErrorSelfieTypeDriverLicense
	case PassportElementErrorSelfieTypeIdentityCard:
		*s = PassportElementErrorSelfieTypeIdentityCard
	case PassportElementErrorSelfieTypeInternalPassport:
		*s = PassportElementErrorSelfieTypeInternalPassport
	default:
		*s = PassportElementErrorSelfieType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PassportElementErrorTranslationFile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"source\"" + ":")
		e.Str(s.Source)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"file_hash\"" + ":")
		e.Str(s.FileHash)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPassportElementErrorTranslationFile = [4]string{
	0: "source",
	1: "type",
	2: "file_hash",
	3: "message",
}

// Decode decodes PassportElementErrorTranslationFile from json.
func (s *PassportElementErrorTranslationFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorTranslationFile to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "file_hash":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.FileHash = string(v)
			if err != nil {
				return err
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorTranslationFile) {
					name = jsonFieldsNameOfPassportElementErrorTranslationFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PassportElementErrorTranslationFileType as json.
func (s PassportElementErrorTranslationFileType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorTranslationFileType from json.
func (s *PassportElementErrorTranslationFileType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorTranslationFileType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorTranslationFileType(v) {
	case PassportElementErrorTranslationFileTypePassport:
		*s = PassportElementErrorTranslationFileTypePassport
	case PassportElementErrorTranslationFileTypeDriverLicense:
		*s = PassportElementErrorTranslationFileTypeDriverLicense
	case PassportElementErrorTranslationFileTypeIdentityCard:
		*s = PassportElementErrorTranslationFileTypeIdentityCard
	case PassportElementErrorTranslationFileTypeInternalPassport:
		*s = PassportElementErrorTranslationFileTypeInternalPassport
	case PassportElementErrorTranslationFileTypeUtilityBill:
		*s = PassportElementErrorTranslationFileTypeUtilityBill
	case PassportElementErrorTranslationFileTypeBankStatement:
		*s = PassportElementErrorTranslationFileTypeBankStatement
	case PassportElementErrorTranslationFileTypeRentalAgreement:
		*s = PassportElementErrorTranslationFileTypeRentalAgreement
	case PassportElementErrorTranslationFileTypePassportRegistration:
		*s = PassportElementErrorTranslationFileTypePassportRegistration
	case PassportElementErrorTranslationFileTypeTemporaryRegistration:
		*s = PassportElementErrorTranslationFileTypeTemporaryRegistration
	default:
		*s = PassportElementErrorTranslationFileType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PassportElementErrorTranslationFiles) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"source\"" + ":")
		e.Str(s.Source)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"file_hashes\"" + ":")
		e.ArrStart()
		if len(s.FileHashes) >= 1 {
			// Encode first element without comma.
			{
				elem := s.FileHashes[0]
				e.Str(elem)
			}
			for _, elem := range s.FileHashes[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPassportElementErrorTranslationFiles = [4]string{
	0: "source",
	1: "type",
	2: "file_hashes",
	3: "message",
}

// Decode decodes PassportElementErrorTranslationFiles from json.
func (s *PassportElementErrorTranslationFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorTranslationFiles to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "file_hashes":
			requiredBitSet[0] |= 1 << 2
			s.FileHashes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.FileHashes = append(s.FileHashes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorTranslationFiles) {
					name = jsonFieldsNameOfPassportElementErrorTranslationFiles[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PassportElementErrorTranslationFilesType as json.
func (s PassportElementErrorTranslationFilesType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PassportElementErrorTranslationFilesType from json.
func (s *PassportElementErrorTranslationFilesType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorTranslationFilesType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PassportElementErrorTranslationFilesType(v) {
	case PassportElementErrorTranslationFilesTypePassport:
		*s = PassportElementErrorTranslationFilesTypePassport
	case PassportElementErrorTranslationFilesTypeDriverLicense:
		*s = PassportElementErrorTranslationFilesTypeDriverLicense
	case PassportElementErrorTranslationFilesTypeIdentityCard:
		*s = PassportElementErrorTranslationFilesTypeIdentityCard
	case PassportElementErrorTranslationFilesTypeInternalPassport:
		*s = PassportElementErrorTranslationFilesTypeInternalPassport
	case PassportElementErrorTranslationFilesTypeUtilityBill:
		*s = PassportElementErrorTranslationFilesTypeUtilityBill
	case PassportElementErrorTranslationFilesTypeBankStatement:
		*s = PassportElementErrorTranslationFilesTypeBankStatement
	case PassportElementErrorTranslationFilesTypeRentalAgreement:
		*s = PassportElementErrorTranslationFilesTypeRentalAgreement
	case PassportElementErrorTranslationFilesTypePassportRegistration:
		*s = PassportElementErrorTranslationFilesTypePassportRegistration
	case PassportElementErrorTranslationFilesTypeTemporaryRegistration:
		*s = PassportElementErrorTranslationFilesTypeTemporaryRegistration
	default:
		*s = PassportElementErrorTranslationFilesType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PassportElementErrorUnspecified) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"source\"" + ":")
		e.Str(s.Source)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"element_hash\"" + ":")
		e.Str(s.ElementHash)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPassportElementErrorUnspecified = [4]string{
	0: "source",
	1: "type",
	2: "element_hash",
	3: "message",
}

// Decode decodes PassportElementErrorUnspecified from json.
func (s *PassportElementErrorUnspecified) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportElementErrorUnspecified to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "element_hash":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.ElementHash = string(v)
			if err != nil {
				return err
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportElementErrorUnspecified) {
					name = jsonFieldsNameOfPassportElementErrorUnspecified[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PassportFile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"file_id\"" + ":")
		e.Str(s.FileID)
	}
	{
		e.Comma()

		e.RawStr("\"file_unique_id\"" + ":")
		e.Str(s.FileUniqueID)
	}
	{
		e.Comma()

		e.RawStr("\"file_size\"" + ":")
		e.Int(s.FileSize)
	}
	{
		e.Comma()

		e.RawStr("\"file_date\"" + ":")
		e.Int(s.FileDate)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPassportFile = [4]string{
	0: "file_id",
	1: "file_unique_id",
	2: "file_size",
	3: "file_date",
}

// Decode decodes PassportFile from json.
func (s *PassportFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PassportFile to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "file_size":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.FileSize = int(v)
			if err != nil {
				return err
			}
		case "file_date":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Int()
			s.FileDate = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPassportFile) {
					name = jsonFieldsNameOfPassportFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PhotoSize) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"file_id\"" + ":")
		e.Str(s.FileID)
	}
	{
		e.Comma()

		e.RawStr("\"file_unique_id\"" + ":")
		e.Str(s.FileUniqueID)
	}
	{
		e.Comma()

		e.RawStr("\"width\"" + ":")
		e.Int(s.Width)
	}
	{
		e.Comma()

		e.RawStr("\"height\"" + ":")
		e.Int(s.Height)
	}
	{
		if s.FileSize.Set {
			e.Comma()
		}
		if s.FileSize.Set {
			e.RawStr("\"file_size\"" + ":")
			s.FileSize.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPhotoSize = [5]string{
	0: "file_id",
	1: "file_unique_id",
	2: "width",
	3: "height",
	4: "file_size",
}

// Decode decodes PhotoSize from json.
func (s *PhotoSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PhotoSize to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "width":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.Width = int(v)
			if err != nil {
				return err
			}
		case "height":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Int()
			s.Height = int(v)
			if err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPhotoSize) {
					name = jsonFieldsNameOfPhotoSize[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PinChatMessage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"message_id\"" + ":")
		e.Int(s.MessageID)
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPinChatMessage = [3]string{
	0: "chat_id",
	1: "message_id",
	2: "disable_notification",
}

// Decode decodes PinChatMessage from json.
func (s *PinChatMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PinChatMessage to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int()
			s.MessageID = int(v)
			if err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPinChatMessage) {
					name = jsonFieldsNameOfPinChatMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Poll) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"question\"" + ":")
		e.Str(s.Question)
	}
	{
		e.Comma()

		e.RawStr("\"options\"" + ":")
		e.ArrStart()
		if len(s.Options) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Options[0]
				elem.Encode(e)
			}
			for _, elem := range s.Options[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"total_voter_count\"" + ":")
		e.Int(s.TotalVoterCount)
	}
	{
		e.Comma()

		e.RawStr("\"is_closed\"" + ":")
		e.Bool(s.IsClosed)
	}
	{
		e.Comma()

		e.RawStr("\"is_anonymous\"" + ":")
		e.Bool(s.IsAnonymous)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"allows_multiple_answers\"" + ":")
		e.Bool(s.AllowsMultipleAnswers)
	}
	{
		if s.CorrectOptionID.Set {
			e.Comma()
		}
		if s.CorrectOptionID.Set {
			e.RawStr("\"correct_option_id\"" + ":")
			s.CorrectOptionID.Encode(e)
		}
	}
	{
		if s.Explanation.Set {
			e.Comma()
		}
		if s.Explanation.Set {
			e.RawStr("\"explanation\"" + ":")
			s.Explanation.Encode(e)
		}
	}
	{
		if s.ExplanationEntities != nil {
			e.Comma()
		}
		if s.ExplanationEntities != nil {
			e.RawStr("\"explanation_entities\"" + ":")
			e.ArrStart()
			if len(s.ExplanationEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ExplanationEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.ExplanationEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.OpenPeriod.Set {
			e.Comma()
		}
		if s.OpenPeriod.Set {
			e.RawStr("\"open_period\"" + ":")
			s.OpenPeriod.Encode(e)
		}
	}
	{
		if s.CloseDate.Set {
			e.Comma()
		}
		if s.CloseDate.Set {
			e.RawStr("\"close_date\"" + ":")
			s.CloseDate.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPoll = [13]string{
	0:  "id",
	1:  "question",
	2:  "options",
	3:  "total_voter_count",
	4:  "is_closed",
	5:  "is_anonymous",
	6:  "type",
	7:  "allows_multiple_answers",
	8:  "correct_option_id",
	9:  "explanation",
	10: "explanation_entities",
	11: "open_period",
	12: "close_date",
}

// Decode decodes Poll from json.
func (s *Poll) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Poll to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "question":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Question = string(v)
			if err != nil {
				return err
			}
		case "options":
			requiredBitSet[0] |= 1 << 2
			s.Options = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PollOption
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Options = append(s.Options, elem)
				return nil
			}); err != nil {
				return err
			}
		case "total_voter_count":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Int()
			s.TotalVoterCount = int(v)
			if err != nil {
				return err
			}
		case "is_closed":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Bool()
			s.IsClosed = bool(v)
			if err != nil {
				return err
			}
		case "is_anonymous":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Bool()
			s.IsAnonymous = bool(v)
			if err != nil {
				return err
			}
		case "type":
			requiredBitSet[0] |= 1 << 6
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "allows_multiple_answers":
			requiredBitSet[0] |= 1 << 7
			v, err := d.Bool()
			s.AllowsMultipleAnswers = bool(v)
			if err != nil {
				return err
			}
		case "correct_option_id":
			s.CorrectOptionID.Reset()
			if err := s.CorrectOptionID.Decode(d); err != nil {
				return err
			}
		case "explanation":
			s.Explanation.Reset()
			if err := s.Explanation.Decode(d); err != nil {
				return err
			}
		case "explanation_entities":
			s.ExplanationEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ExplanationEntities = append(s.ExplanationEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "open_period":
			s.OpenPeriod.Reset()
			if err := s.OpenPeriod.Decode(d); err != nil {
				return err
			}
		case "close_date":
			s.CloseDate.Reset()
			if err := s.CloseDate.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPoll) {
					name = jsonFieldsNameOfPoll[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PollAnswer) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"poll_id\"" + ":")
		e.Str(s.PollID)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"option_ids\"" + ":")
		e.ArrStart()
		if len(s.OptionIds) >= 1 {
			// Encode first element without comma.
			{
				elem := s.OptionIds[0]
				e.Int(elem)
			}
			for _, elem := range s.OptionIds[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPollAnswer = [3]string{
	0: "poll_id",
	1: "user",
	2: "option_ids",
}

// Decode decodes PollAnswer from json.
func (s *PollAnswer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PollAnswer to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "poll_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.PollID = string(v)
			if err != nil {
				return err
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "option_ids":
			requiredBitSet[0] |= 1 << 2
			s.OptionIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.OptionIds = append(s.OptionIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPollAnswer) {
					name = jsonFieldsNameOfPollAnswer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PollOption) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"text\"" + ":")
		e.Str(s.Text)
	}
	{
		e.Comma()

		e.RawStr("\"voter_count\"" + ":")
		e.Int(s.VoterCount)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPollOption = [2]string{
	0: "text",
	1: "voter_count",
}

// Decode decodes PollOption from json.
func (s *PollOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PollOption to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Text = string(v)
			if err != nil {
				return err
			}
		case "voter_count":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int()
			s.VoterCount = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPollOption) {
					name = jsonFieldsNameOfPollOption[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PollType as json.
func (s PollType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PollType from json.
func (s *PollType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PollType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PollType(v) {
	case PollTypeRegular:
		*s = PollTypeRegular
	case PollTypeQuiz:
		*s = PollTypeQuiz
	default:
		*s = PollType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PreCheckoutQuery) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"from\"" + ":")
		s.From.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"currency\"" + ":")
		e.Str(s.Currency)
	}
	{
		e.Comma()

		e.RawStr("\"total_amount\"" + ":")
		e.Int(s.TotalAmount)
	}
	{
		e.Comma()

		e.RawStr("\"invoice_payload\"" + ":")
		e.Str(s.InvoicePayload)
	}
	{
		if s.ShippingOptionID.Set {
			e.Comma()
		}
		if s.ShippingOptionID.Set {
			e.RawStr("\"shipping_option_id\"" + ":")
			s.ShippingOptionID.Encode(e)
		}
	}
	{
		if s.OrderInfo.Set {
			e.Comma()
		}
		if s.OrderInfo.Set {
			e.RawStr("\"order_info\"" + ":")
			s.OrderInfo.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPreCheckoutQuery = [7]string{
	0: "id",
	1: "from",
	2: "currency",
	3: "total_amount",
	4: "invoice_payload",
	5: "shipping_option_id",
	6: "order_info",
}

// Decode decodes PreCheckoutQuery from json.
func (s *PreCheckoutQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PreCheckoutQuery to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := s.From.Decode(d); err != nil {
				return err
			}
		case "currency":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Currency = string(v)
			if err != nil {
				return err
			}
		case "total_amount":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Int()
			s.TotalAmount = int(v)
			if err != nil {
				return err
			}
		case "invoice_payload":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.InvoicePayload = string(v)
			if err != nil {
				return err
			}
		case "shipping_option_id":
			s.ShippingOptionID.Reset()
			if err := s.ShippingOptionID.Decode(d); err != nil {
				return err
			}
		case "order_info":
			s.OrderInfo.Reset()
			if err := s.OrderInfo.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPreCheckoutQuery) {
					name = jsonFieldsNameOfPreCheckoutQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PromoteChatMember) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	{
		if s.IsAnonymous.Set {
			e.Comma()
		}
		if s.IsAnonymous.Set {
			e.RawStr("\"is_anonymous\"" + ":")
			s.IsAnonymous.Encode(e)
		}
	}
	{
		if s.CanManageChat.Set {
			e.Comma()
		}
		if s.CanManageChat.Set {
			e.RawStr("\"can_manage_chat\"" + ":")
			s.CanManageChat.Encode(e)
		}
	}
	{
		if s.CanPostMessages.Set {
			e.Comma()
		}
		if s.CanPostMessages.Set {
			e.RawStr("\"can_post_messages\"" + ":")
			s.CanPostMessages.Encode(e)
		}
	}
	{
		if s.CanEditMessages.Set {
			e.Comma()
		}
		if s.CanEditMessages.Set {
			e.RawStr("\"can_edit_messages\"" + ":")
			s.CanEditMessages.Encode(e)
		}
	}
	{
		if s.CanDeleteMessages.Set {
			e.Comma()
		}
		if s.CanDeleteMessages.Set {
			e.RawStr("\"can_delete_messages\"" + ":")
			s.CanDeleteMessages.Encode(e)
		}
	}
	{
		if s.CanManageVoiceChats.Set {
			e.Comma()
		}
		if s.CanManageVoiceChats.Set {
			e.RawStr("\"can_manage_voice_chats\"" + ":")
			s.CanManageVoiceChats.Encode(e)
		}
	}
	{
		if s.CanRestrictMembers.Set {
			e.Comma()
		}
		if s.CanRestrictMembers.Set {
			e.RawStr("\"can_restrict_members\"" + ":")
			s.CanRestrictMembers.Encode(e)
		}
	}
	{
		if s.CanPromoteMembers.Set {
			e.Comma()
		}
		if s.CanPromoteMembers.Set {
			e.RawStr("\"can_promote_members\"" + ":")
			s.CanPromoteMembers.Encode(e)
		}
	}
	{
		if s.CanChangeInfo.Set {
			e.Comma()
		}
		if s.CanChangeInfo.Set {
			e.RawStr("\"can_change_info\"" + ":")
			s.CanChangeInfo.Encode(e)
		}
	}
	{
		if s.CanInviteUsers.Set {
			e.Comma()
		}
		if s.CanInviteUsers.Set {
			e.RawStr("\"can_invite_users\"" + ":")
			s.CanInviteUsers.Encode(e)
		}
	}
	{
		if s.CanPinMessages.Set {
			e.Comma()
		}
		if s.CanPinMessages.Set {
			e.RawStr("\"can_pin_messages\"" + ":")
			s.CanPinMessages.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPromoteChatMember = [13]string{
	0:  "chat_id",
	1:  "user_id",
	2:  "is_anonymous",
	3:  "can_manage_chat",
	4:  "can_post_messages",
	5:  "can_edit_messages",
	6:  "can_delete_messages",
	7:  "can_manage_voice_chats",
	8:  "can_restrict_members",
	9:  "can_promote_members",
	10: "can_change_info",
	11: "can_invite_users",
	12: "can_pin_messages",
}

// Decode decodes PromoteChatMember from json.
func (s *PromoteChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PromoteChatMember to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		case "is_anonymous":
			s.IsAnonymous.Reset()
			if err := s.IsAnonymous.Decode(d); err != nil {
				return err
			}
		case "can_manage_chat":
			s.CanManageChat.Reset()
			if err := s.CanManageChat.Decode(d); err != nil {
				return err
			}
		case "can_post_messages":
			s.CanPostMessages.Reset()
			if err := s.CanPostMessages.Decode(d); err != nil {
				return err
			}
		case "can_edit_messages":
			s.CanEditMessages.Reset()
			if err := s.CanEditMessages.Decode(d); err != nil {
				return err
			}
		case "can_delete_messages":
			s.CanDeleteMessages.Reset()
			if err := s.CanDeleteMessages.Decode(d); err != nil {
				return err
			}
		case "can_manage_voice_chats":
			s.CanManageVoiceChats.Reset()
			if err := s.CanManageVoiceChats.Decode(d); err != nil {
				return err
			}
		case "can_restrict_members":
			s.CanRestrictMembers.Reset()
			if err := s.CanRestrictMembers.Decode(d); err != nil {
				return err
			}
		case "can_promote_members":
			s.CanPromoteMembers.Reset()
			if err := s.CanPromoteMembers.Decode(d); err != nil {
				return err
			}
		case "can_change_info":
			s.CanChangeInfo.Reset()
			if err := s.CanChangeInfo.Decode(d); err != nil {
				return err
			}
		case "can_invite_users":
			s.CanInviteUsers.Reset()
			if err := s.CanInviteUsers.Decode(d); err != nil {
				return err
			}
		case "can_pin_messages":
			s.CanPinMessages.Reset()
			if err := s.CanPinMessages.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromoteChatMember) {
					name = jsonFieldsNameOfPromoteChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProximityAlertTriggered) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"traveler\"" + ":")
		s.Traveler.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"watcher\"" + ":")
		s.Watcher.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"distance\"" + ":")
		e.Int(s.Distance)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProximityAlertTriggered = [3]string{
	0: "traveler",
	1: "watcher",
	2: "distance",
}

// Decode decodes ProximityAlertTriggered from json.
func (s *ProximityAlertTriggered) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProximityAlertTriggered to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "traveler":
			requiredBitSet[0] |= 1 << 0
			if err := s.Traveler.Decode(d); err != nil {
				return err
			}
		case "watcher":
			requiredBitSet[0] |= 1 << 1
			if err := s.Watcher.Decode(d); err != nil {
				return err
			}
		case "distance":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.Distance = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProximityAlertTriggered) {
					name = jsonFieldsNameOfProximityAlertTriggered[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReplyKeyboardMarkup) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"keyboard\"" + ":")
		e.ArrStart()
		if len(s.Keyboard) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Keyboard[0]
				e.ArrStart()
				if len(elem) >= 1 {
					// Encode first element without comma.
					{
						elem := elem[0]
						elem.Encode(e)
					}
					for _, elem := range elem[1:] {
						e.Comma()
						elem.Encode(e)
					}
				}
				e.ArrEnd()
			}
			for _, elem := range s.Keyboard[1:] {
				e.Comma()
				e.ArrStart()
				if len(elem) >= 1 {
					// Encode first element without comma.
					{
						elem := elem[0]
						elem.Encode(e)
					}
					for _, elem := range elem[1:] {
						e.Comma()
						elem.Encode(e)
					}
				}
				e.ArrEnd()
			}
		}
		e.ArrEnd()
	}
	{
		if s.ResizeKeyboard.Set {
			e.Comma()
		}
		if s.ResizeKeyboard.Set {
			e.RawStr("\"resize_keyboard\"" + ":")
			s.ResizeKeyboard.Encode(e)
		}
	}
	{
		if s.OneTimeKeyboard.Set {
			e.Comma()
		}
		if s.OneTimeKeyboard.Set {
			e.RawStr("\"one_time_keyboard\"" + ":")
			s.OneTimeKeyboard.Encode(e)
		}
	}
	{
		if s.InputFieldPlaceholder.Set {
			e.Comma()
		}
		if s.InputFieldPlaceholder.Set {
			e.RawStr("\"input_field_placeholder\"" + ":")
			s.InputFieldPlaceholder.Encode(e)
		}
	}
	{
		if s.Selective.Set {
			e.Comma()
		}
		if s.Selective.Set {
			e.RawStr("\"selective\"" + ":")
			s.Selective.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReplyKeyboardMarkup = [5]string{
	0: "keyboard",
	1: "resize_keyboard",
	2: "one_time_keyboard",
	3: "input_field_placeholder",
	4: "selective",
}

// Decode decodes ReplyKeyboardMarkup from json.
func (s *ReplyKeyboardMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReplyKeyboardMarkup to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "keyboard":
			requiredBitSet[0] |= 1 << 0
			s.Keyboard = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []KeyboardButton
				elem = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem KeyboardButton
					if err := elemElem.Decode(d); err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				s.Keyboard = append(s.Keyboard, elem)
				return nil
			}); err != nil {
				return err
			}
		case "resize_keyboard":
			s.ResizeKeyboard.Reset()
			if err := s.ResizeKeyboard.Decode(d); err != nil {
				return err
			}
		case "one_time_keyboard":
			s.OneTimeKeyboard.Reset()
			if err := s.OneTimeKeyboard.Decode(d); err != nil {
				return err
			}
		case "input_field_placeholder":
			s.InputFieldPlaceholder.Reset()
			if err := s.InputFieldPlaceholder.Decode(d); err != nil {
				return err
			}
		case "selective":
			s.Selective.Reset()
			if err := s.Selective.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReplyKeyboardMarkup) {
					name = jsonFieldsNameOfReplyKeyboardMarkup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReplyKeyboardRemove) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"remove_keyboard\"" + ":")
		e.Bool(s.RemoveKeyboard)
	}
	{
		if s.Selective.Set {
			e.Comma()
		}
		if s.Selective.Set {
			e.RawStr("\"selective\"" + ":")
			s.Selective.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReplyKeyboardRemove = [2]string{
	0: "remove_keyboard",
	1: "selective",
}

// Decode decodes ReplyKeyboardRemove from json.
func (s *ReplyKeyboardRemove) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReplyKeyboardRemove to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "remove_keyboard":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Bool()
			s.RemoveKeyboard = bool(v)
			if err != nil {
				return err
			}
		case "selective":
			s.Selective.Reset()
			if err := s.Selective.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReplyKeyboardRemove) {
					name = jsonFieldsNameOfReplyKeyboardRemove[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Response) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MigrateToChatID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MigrateToChatID.Set {
			e.RawStr("\"migrate_to_chat_id\"" + ":")
			s.MigrateToChatID.Encode(e)
		}
	}
	{
		if s.RetryAfter.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RetryAfter.Set {
			e.RawStr("\"retry_after\"" + ":")
			s.RetryAfter.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResponse = [2]string{
	0: "migrate_to_chat_id",
	1: "retry_after",
}

// Decode decodes Response from json.
func (s *Response) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Response to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "migrate_to_chat_id":
			s.MigrateToChatID.Reset()
			if err := s.MigrateToChatID.Decode(d); err != nil {
				return err
			}
		case "retry_after":
			s.RetryAfter.Reset()
			if err := s.RetryAfter.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RestrictChatMember) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	{
		e.Comma()

		e.RawStr("\"permissions\"" + ":")
		s.Permissions.Encode(e)
	}
	{
		if s.UntilDate.Set {
			e.Comma()
		}
		if s.UntilDate.Set {
			e.RawStr("\"until_date\"" + ":")
			s.UntilDate.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRestrictChatMember = [4]string{
	0: "chat_id",
	1: "user_id",
	2: "permissions",
	3: "until_date",
}

// Decode decodes RestrictChatMember from json.
func (s *RestrictChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RestrictChatMember to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 2
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "until_date":
			s.UntilDate.Reset()
			if err := s.UntilDate.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestrictChatMember) {
					name = jsonFieldsNameOfRestrictChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Result) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result.Set {
			e.RawStr("\"result\"" + ":")
			s.Result.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResult = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes Result from json.
func (s *Result) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Result to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResult) {
					name = jsonFieldsNameOfResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultArrayOfBotCommand) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result != nil {
			e.RawStr("\"result\"" + ":")
			e.ArrStart()
			if len(s.Result) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Result[0]
					elem.Encode(e)
				}
				for _, elem := range s.Result[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultArrayOfBotCommand = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfBotCommand from json.
func (s *ResultArrayOfBotCommand) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultArrayOfBotCommand to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem BotCommand
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Result = append(s.Result, elem)
				return nil
			}); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfBotCommand) {
					name = jsonFieldsNameOfResultArrayOfBotCommand[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultArrayOfChatMember) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result != nil {
			e.RawStr("\"result\"" + ":")
			e.ArrStart()
			if len(s.Result) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Result[0]
					elem.Encode(e)
				}
				for _, elem := range s.Result[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultArrayOfChatMember = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfChatMember from json.
func (s *ResultArrayOfChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultArrayOfChatMember to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ChatMember
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Result = append(s.Result, elem)
				return nil
			}); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfChatMember) {
					name = jsonFieldsNameOfResultArrayOfChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultArrayOfGameHighScore) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result != nil {
			e.RawStr("\"result\"" + ":")
			e.ArrStart()
			if len(s.Result) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Result[0]
					elem.Encode(e)
				}
				for _, elem := range s.Result[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultArrayOfGameHighScore = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfGameHighScore from json.
func (s *ResultArrayOfGameHighScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultArrayOfGameHighScore to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem GameHighScore
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Result = append(s.Result, elem)
				return nil
			}); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfGameHighScore) {
					name = jsonFieldsNameOfResultArrayOfGameHighScore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultArrayOfMessage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result != nil {
			e.RawStr("\"result\"" + ":")
			e.ArrStart()
			if len(s.Result) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Result[0]
					elem.Encode(e)
				}
				for _, elem := range s.Result[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultArrayOfMessage = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfMessage from json.
func (s *ResultArrayOfMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultArrayOfMessage to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Message
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Result = append(s.Result, elem)
				return nil
			}); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfMessage) {
					name = jsonFieldsNameOfResultArrayOfMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultArrayOfUpdate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result != nil {
			e.RawStr("\"result\"" + ":")
			e.ArrStart()
			if len(s.Result) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Result[0]
					elem.Encode(e)
				}
				for _, elem := range s.Result[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultArrayOfUpdate = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultArrayOfUpdate from json.
func (s *ResultArrayOfUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultArrayOfUpdate to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Update
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Result = append(s.Result, elem)
				return nil
			}); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultArrayOfUpdate) {
					name = jsonFieldsNameOfResultArrayOfUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultChat) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result.Set {
			e.RawStr("\"result\"" + ":")
			s.Result.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultChat = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultChat from json.
func (s *ResultChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultChat to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultChat) {
					name = jsonFieldsNameOfResultChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultChatInviteLink) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result.Set {
			e.RawStr("\"result\"" + ":")
			s.Result.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultChatInviteLink = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultChatInviteLink from json.
func (s *ResultChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultChatInviteLink to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultChatInviteLink) {
					name = jsonFieldsNameOfResultChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultChatMember) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result.Set {
			e.RawStr("\"result\"" + ":")
			s.Result.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultChatMember = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultChatMember from json.
func (s *ResultChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultChatMember to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultChatMember) {
					name = jsonFieldsNameOfResultChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultFile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result.Set {
			e.RawStr("\"result\"" + ":")
			s.Result.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultFile = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultFile from json.
func (s *ResultFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultFile to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultFile) {
					name = jsonFieldsNameOfResultFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultInt) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result.Set {
			e.RawStr("\"result\"" + ":")
			s.Result.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultInt = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultInt from json.
func (s *ResultInt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultInt to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultInt) {
					name = jsonFieldsNameOfResultInt[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultMessage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result.Set {
			e.RawStr("\"result\"" + ":")
			s.Result.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultMessage = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultMessage from json.
func (s *ResultMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultMessage to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultMessage) {
					name = jsonFieldsNameOfResultMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultMessageId) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result.Set {
			e.RawStr("\"result\"" + ":")
			s.Result.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultMessageId = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultMessageId from json.
func (s *ResultMessageId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultMessageId to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultMessageId) {
					name = jsonFieldsNameOfResultMessageId[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultMessageOrBoolean) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result.Set {
			e.RawStr("\"result\"" + ":")
			s.Result.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultMessageOrBoolean = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultMessageOrBoolean from json.
func (s *ResultMessageOrBoolean) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultMessageOrBoolean to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultMessageOrBoolean) {
					name = jsonFieldsNameOfResultMessageOrBoolean[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ResultMessageOrBooleanResult as json.
func (s ResultMessageOrBooleanResult) Encode(e *jx.Writer) {
	switch s.Type {
	case MessageResultMessageOrBooleanResult:
		s.Message.Encode(e)
	case BoolResultMessageOrBooleanResult:
		e.Bool(s.Bool)
	}
}

// Decode decodes ResultMessageOrBooleanResult from json.
func (s *ResultMessageOrBooleanResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultMessageOrBooleanResult to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.Message.Decode(d); err != nil {
			return err
		}
		s.Type = MessageResultMessageOrBooleanResult
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolResultMessageOrBooleanResult
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ResultPoll) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result.Set {
			e.RawStr("\"result\"" + ":")
			s.Result.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultPoll = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultPoll from json.
func (s *ResultPoll) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultPoll to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultPoll) {
					name = jsonFieldsNameOfResultPoll[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultStickerSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result.Set {
			e.RawStr("\"result\"" + ":")
			s.Result.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultStickerSet = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultStickerSet from json.
func (s *ResultStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultStickerSet to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultStickerSet) {
					name = jsonFieldsNameOfResultStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultString) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result.Set {
			e.RawStr("\"result\"" + ":")
			s.Result.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultString = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultString from json.
func (s *ResultString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultString to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultString) {
					name = jsonFieldsNameOfResultString[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result.Set {
			e.RawStr("\"result\"" + ":")
			s.Result.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultUser = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultUser from json.
func (s *ResultUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultUser to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultUser) {
					name = jsonFieldsNameOfResultUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultUserProfilePhotos) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result.Set {
			e.RawStr("\"result\"" + ":")
			s.Result.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultUserProfilePhotos = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultUserProfilePhotos from json.
func (s *ResultUserProfilePhotos) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultUserProfilePhotos to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultUserProfilePhotos) {
					name = jsonFieldsNameOfResultUserProfilePhotos[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ResultWebhookInfo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Result.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Result.Set {
			e.RawStr("\"result\"" + ":")
			s.Result.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ok\"" + ":")
		e.Bool(s.Ok)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfResultWebhookInfo = [2]string{
	0: "result",
	1: "ok",
}

// Decode decodes ResultWebhookInfo from json.
func (s *ResultWebhookInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ResultWebhookInfo to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			s.Result.Reset()
			if err := s.Result.Decode(d); err != nil {
				return err
			}
		case "ok":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.Ok = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultWebhookInfo) {
					name = jsonFieldsNameOfResultWebhookInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RevokeChatInviteLink) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"invite_link\"" + ":")
		e.Str(s.InviteLink)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRevokeChatInviteLink = [2]string{
	0: "chat_id",
	1: "invite_link",
}

// Decode decodes RevokeChatInviteLink from json.
func (s *RevokeChatInviteLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RevokeChatInviteLink to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "invite_link":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.InviteLink = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeChatInviteLink) {
					name = jsonFieldsNameOfRevokeChatInviteLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SendAnimation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"animation\"" + ":")
		e.Str(s.Animation)
	}
	{
		if s.Duration.Set {
			e.Comma()
		}
		if s.Duration.Set {
			e.RawStr("\"duration\"" + ":")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Width.Set {
			e.Comma()
		}
		if s.Width.Set {
			e.RawStr("\"width\"" + ":")
			s.Width.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.Comma()
		}
		if s.Height.Set {
			e.RawStr("\"height\"" + ":")
			s.Height.Encode(e)
		}
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendAnimation = [14]string{
	0:  "chat_id",
	1:  "animation",
	2:  "duration",
	3:  "width",
	4:  "height",
	5:  "thumb",
	6:  "caption",
	7:  "parse_mode",
	8:  "caption_entities",
	9:  "disable_notification",
	10: "protect_content",
	11: "reply_to_message_id",
	12: "allow_sending_without_reply",
	13: "reply_markup",
}

// Decode decodes SendAnimation from json.
func (s *SendAnimation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendAnimation to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "animation":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Animation = string(v)
			if err != nil {
				return err
			}
		case "duration":
			s.Duration.Reset()
			if err := s.Duration.Decode(d); err != nil {
				return err
			}
		case "width":
			s.Width.Reset()
			if err := s.Width.Decode(d); err != nil {
				return err
			}
		case "height":
			s.Height.Reset()
			if err := s.Height.Decode(d); err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendAnimation) {
					name = jsonFieldsNameOfSendAnimation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SendAudio) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"audio\"" + ":")
		e.Str(s.Audio)
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Duration.Set {
			e.Comma()
		}
		if s.Duration.Set {
			e.RawStr("\"duration\"" + ":")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Performer.Set {
			e.Comma()
		}
		if s.Performer.Set {
			e.RawStr("\"performer\"" + ":")
			s.Performer.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.Comma()
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendAudio = [14]string{
	0:  "chat_id",
	1:  "audio",
	2:  "caption",
	3:  "parse_mode",
	4:  "caption_entities",
	5:  "duration",
	6:  "performer",
	7:  "title",
	8:  "thumb",
	9:  "disable_notification",
	10: "protect_content",
	11: "reply_to_message_id",
	12: "allow_sending_without_reply",
	13: "reply_markup",
}

// Decode decodes SendAudio from json.
func (s *SendAudio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendAudio to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "audio":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Audio = string(v)
			if err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "duration":
			s.Duration.Reset()
			if err := s.Duration.Decode(d); err != nil {
				return err
			}
		case "performer":
			s.Performer.Reset()
			if err := s.Performer.Decode(d); err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendAudio) {
					name = jsonFieldsNameOfSendAudio[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SendChatAction) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"action\"" + ":")
		e.Str(s.Action)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendChatAction = [2]string{
	0: "chat_id",
	1: "action",
}

// Decode decodes SendChatAction from json.
func (s *SendChatAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendChatAction to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "action":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Action = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendChatAction) {
					name = jsonFieldsNameOfSendChatAction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SendContact) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"phone_number\"" + ":")
		e.Str(s.PhoneNumber)
	}
	{
		e.Comma()

		e.RawStr("\"first_name\"" + ":")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.Comma()
		}
		if s.LastName.Set {
			e.RawStr("\"last_name\"" + ":")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Vcard.Set {
			e.Comma()
		}
		if s.Vcard.Set {
			e.RawStr("\"vcard\"" + ":")
			s.Vcard.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendContact = [10]string{
	0: "chat_id",
	1: "phone_number",
	2: "first_name",
	3: "last_name",
	4: "vcard",
	5: "disable_notification",
	6: "protect_content",
	7: "reply_to_message_id",
	8: "allow_sending_without_reply",
	9: "reply_markup",
}

// Decode decodes SendContact from json.
func (s *SendContact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendContact to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "phone_number":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.PhoneNumber = string(v)
			if err != nil {
				return err
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.FirstName = string(v)
			if err != nil {
				return err
			}
		case "last_name":
			s.LastName.Reset()
			if err := s.LastName.Decode(d); err != nil {
				return err
			}
		case "vcard":
			s.Vcard.Reset()
			if err := s.Vcard.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendContact) {
					name = jsonFieldsNameOfSendContact[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SendDice) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		if s.Emoji.Set {
			e.Comma()
		}
		if s.Emoji.Set {
			e.RawStr("\"emoji\"" + ":")
			s.Emoji.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendDice = [7]string{
	0: "chat_id",
	1: "emoji",
	2: "disable_notification",
	3: "protect_content",
	4: "reply_to_message_id",
	5: "allow_sending_without_reply",
	6: "reply_markup",
}

// Decode decodes SendDice from json.
func (s *SendDice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendDice to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "emoji":
			s.Emoji.Reset()
			if err := s.Emoji.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendDice) {
					name = jsonFieldsNameOfSendDice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SendDocument) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"document\"" + ":")
		e.Str(s.Document)
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableContentTypeDetection.Set {
			e.Comma()
		}
		if s.DisableContentTypeDetection.Set {
			e.RawStr("\"disable_content_type_detection\"" + ":")
			s.DisableContentTypeDetection.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendDocument = [12]string{
	0:  "chat_id",
	1:  "document",
	2:  "thumb",
	3:  "caption",
	4:  "parse_mode",
	5:  "caption_entities",
	6:  "disable_content_type_detection",
	7:  "disable_notification",
	8:  "protect_content",
	9:  "reply_to_message_id",
	10: "allow_sending_without_reply",
	11: "reply_markup",
}

// Decode decodes SendDocument from json.
func (s *SendDocument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendDocument to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "document":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Document = string(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_content_type_detection":
			s.DisableContentTypeDetection.Reset()
			if err := s.DisableContentTypeDetection.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendDocument) {
					name = jsonFieldsNameOfSendDocument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SendGame) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		e.Int64(s.ChatID)
	}
	{
		e.Comma()

		e.RawStr("\"game_short_name\"" + ":")
		e.Str(s.GameShortName)
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendGame = [7]string{
	0: "chat_id",
	1: "game_short_name",
	2: "disable_notification",
	3: "protect_content",
	4: "reply_to_message_id",
	5: "allow_sending_without_reply",
	6: "reply_markup",
}

// Decode decodes SendGame from json.
func (s *SendGame) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendGame to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int64()
			s.ChatID = int64(v)
			if err != nil {
				return err
			}
		case "game_short_name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.GameShortName = string(v)
			if err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendGame) {
					name = jsonFieldsNameOfSendGame[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SendInvoice) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		e.Str(s.Payload)
	}
	{
		e.Comma()

		e.RawStr("\"provider_token\"" + ":")
		e.Str(s.ProviderToken)
	}
	{
		e.Comma()

		e.RawStr("\"currency\"" + ":")
		e.Str(s.Currency)
	}
	{
		e.Comma()

		e.RawStr("\"prices\"" + ":")
		e.ArrStart()
		if len(s.Prices) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Prices[0]
				elem.Encode(e)
			}
			for _, elem := range s.Prices[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.MaxTipAmount.Set {
			e.Comma()
		}
		if s.MaxTipAmount.Set {
			e.RawStr("\"max_tip_amount\"" + ":")
			s.MaxTipAmount.Encode(e)
		}
	}
	{
		if s.SuggestedTipAmounts != nil {
			e.Comma()
		}
		if s.SuggestedTipAmounts != nil {
			e.RawStr("\"suggested_tip_amounts\"" + ":")
			e.ArrStart()
			if len(s.SuggestedTipAmounts) >= 1 {
				// Encode first element without comma.
				{
					elem := s.SuggestedTipAmounts[0]
					e.Int64(elem)
				}
				for _, elem := range s.SuggestedTipAmounts[1:] {
					e.Comma()
					e.Int64(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.StartParameter.Set {
			e.Comma()
		}
		if s.StartParameter.Set {
			e.RawStr("\"start_parameter\"" + ":")
			s.StartParameter.Encode(e)
		}
	}
	{
		if s.ProviderData.Set {
			e.Comma()
		}
		if s.ProviderData.Set {
			e.RawStr("\"provider_data\"" + ":")
			s.ProviderData.Encode(e)
		}
	}
	{
		if s.PhotoURL.Set {
			e.Comma()
		}
		if s.PhotoURL.Set {
			e.RawStr("\"photo_url\"" + ":")
			s.PhotoURL.Encode(e)
		}
	}
	{
		if s.PhotoSize.Set {
			e.Comma()
		}
		if s.PhotoSize.Set {
			e.RawStr("\"photo_size\"" + ":")
			s.PhotoSize.Encode(e)
		}
	}
	{
		if s.PhotoWidth.Set {
			e.Comma()
		}
		if s.PhotoWidth.Set {
			e.RawStr("\"photo_width\"" + ":")
			s.PhotoWidth.Encode(e)
		}
	}
	{
		if s.PhotoHeight.Set {
			e.Comma()
		}
		if s.PhotoHeight.Set {
			e.RawStr("\"photo_height\"" + ":")
			s.PhotoHeight.Encode(e)
		}
	}
	{
		if s.NeedName.Set {
			e.Comma()
		}
		if s.NeedName.Set {
			e.RawStr("\"need_name\"" + ":")
			s.NeedName.Encode(e)
		}
	}
	{
		if s.NeedPhoneNumber.Set {
			e.Comma()
		}
		if s.NeedPhoneNumber.Set {
			e.RawStr("\"need_phone_number\"" + ":")
			s.NeedPhoneNumber.Encode(e)
		}
	}
	{
		if s.NeedEmail.Set {
			e.Comma()
		}
		if s.NeedEmail.Set {
			e.RawStr("\"need_email\"" + ":")
			s.NeedEmail.Encode(e)
		}
	}
	{
		if s.NeedShippingAddress.Set {
			e.Comma()
		}
		if s.NeedShippingAddress.Set {
			e.RawStr("\"need_shipping_address\"" + ":")
			s.NeedShippingAddress.Encode(e)
		}
	}
	{
		if s.SendPhoneNumberToProvider.Set {
			e.Comma()
		}
		if s.SendPhoneNumberToProvider.Set {
			e.RawStr("\"send_phone_number_to_provider\"" + ":")
			s.SendPhoneNumberToProvider.Encode(e)
		}
	}
	{
		if s.SendEmailToProvider.Set {
			e.Comma()
		}
		if s.SendEmailToProvider.Set {
			e.RawStr("\"send_email_to_provider\"" + ":")
			s.SendEmailToProvider.Encode(e)
		}
	}
	{
		if s.IsFlexible.Set {
			e.Comma()
		}
		if s.IsFlexible.Set {
			e.RawStr("\"is_flexible\"" + ":")
			s.IsFlexible.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendInvoice = [27]string{
	0:  "chat_id",
	1:  "title",
	2:  "description",
	3:  "payload",
	4:  "provider_token",
	5:  "currency",
	6:  "prices",
	7:  "max_tip_amount",
	8:  "suggested_tip_amounts",
	9:  "start_parameter",
	10: "provider_data",
	11: "photo_url",
	12: "photo_size",
	13: "photo_width",
	14: "photo_height",
	15: "need_name",
	16: "need_phone_number",
	17: "need_email",
	18: "need_shipping_address",
	19: "send_phone_number_to_provider",
	20: "send_email_to_provider",
	21: "is_flexible",
	22: "disable_notification",
	23: "protect_content",
	24: "reply_to_message_id",
	25: "allow_sending_without_reply",
	26: "reply_markup",
}

// Decode decodes SendInvoice from json.
func (s *SendInvoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendInvoice to nil`)
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "payload":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Payload = string(v)
			if err != nil {
				return err
			}
		case "provider_token":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.ProviderToken = string(v)
			if err != nil {
				return err
			}
		case "currency":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.Currency = string(v)
			if err != nil {
				return err
			}
		case "prices":
			requiredBitSet[0] |= 1 << 6
			s.Prices = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem LabeledPrice
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Prices = append(s.Prices, elem)
				return nil
			}); err != nil {
				return err
			}
		case "max_tip_amount":
			s.MaxTipAmount.Reset()
			if err := s.MaxTipAmount.Decode(d); err != nil {
				return err
			}
		case "suggested_tip_amounts":
			s.SuggestedTipAmounts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				s.SuggestedTipAmounts = append(s.SuggestedTipAmounts, elem)
				return nil
			}); err != nil {
				return err
			}
		case "start_parameter":
			s.StartParameter.Reset()
			if err := s.StartParameter.Decode(d); err != nil {
				return err
			}
		case "provider_data":
			s.ProviderData.Reset()
			if err := s.ProviderData.Decode(d); err != nil {
				return err
			}
		case "photo_url":
			s.PhotoURL.Reset()
			if err := s.PhotoURL.Decode(d); err != nil {
				return err
			}
		case "photo_size":
			s.PhotoSize.Reset()
			if err := s.PhotoSize.Decode(d); err != nil {
				return err
			}
		case "photo_width":
			s.PhotoWidth.Reset()
			if err := s.PhotoWidth.Decode(d); err != nil {
				return err
			}
		case "photo_height":
			s.PhotoHeight.Reset()
			if err := s.PhotoHeight.Decode(d); err != nil {
				return err
			}
		case "need_name":
			s.NeedName.Reset()
			if err := s.NeedName.Decode(d); err != nil {
				return err
			}
		case "need_phone_number":
			s.NeedPhoneNumber.Reset()
			if err := s.NeedPhoneNumber.Decode(d); err != nil {
				return err
			}
		case "need_email":
			s.NeedEmail.Reset()
			if err := s.NeedEmail.Decode(d); err != nil {
				return err
			}
		case "need_shipping_address":
			s.NeedShippingAddress.Reset()
			if err := s.NeedShippingAddress.Decode(d); err != nil {
				return err
			}
		case "send_phone_number_to_provider":
			s.SendPhoneNumberToProvider.Reset()
			if err := s.SendPhoneNumberToProvider.Decode(d); err != nil {
				return err
			}
		case "send_email_to_provider":
			s.SendEmailToProvider.Reset()
			if err := s.SendEmailToProvider.Decode(d); err != nil {
				return err
			}
		case "is_flexible":
			s.IsFlexible.Reset()
			if err := s.IsFlexible.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b01111111,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendInvoice) {
					name = jsonFieldsNameOfSendInvoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SendLocation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"latitude\"" + ":")
		e.Float64(s.Latitude)
	}
	{
		e.Comma()

		e.RawStr("\"longitude\"" + ":")
		e.Float64(s.Longitude)
	}
	{
		if s.HorizontalAccuracy.Set {
			e.Comma()
		}
		if s.HorizontalAccuracy.Set {
			e.RawStr("\"horizontal_accuracy\"" + ":")
			s.HorizontalAccuracy.Encode(e)
		}
	}
	{
		if s.LivePeriod.Set {
			e.Comma()
		}
		if s.LivePeriod.Set {
			e.RawStr("\"live_period\"" + ":")
			s.LivePeriod.Encode(e)
		}
	}
	{
		if s.Heading.Set {
			e.Comma()
		}
		if s.Heading.Set {
			e.RawStr("\"heading\"" + ":")
			s.Heading.Encode(e)
		}
	}
	{
		if s.ProximityAlertRadius.Set {
			e.Comma()
		}
		if s.ProximityAlertRadius.Set {
			e.RawStr("\"proximity_alert_radius\"" + ":")
			s.ProximityAlertRadius.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendLocation = [12]string{
	0:  "chat_id",
	1:  "latitude",
	2:  "longitude",
	3:  "horizontal_accuracy",
	4:  "live_period",
	5:  "heading",
	6:  "proximity_alert_radius",
	7:  "disable_notification",
	8:  "protect_content",
	9:  "reply_to_message_id",
	10: "allow_sending_without_reply",
	11: "reply_markup",
}

// Decode decodes SendLocation from json.
func (s *SendLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendLocation to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Float64()
			s.Latitude = float64(v)
			if err != nil {
				return err
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Float64()
			s.Longitude = float64(v)
			if err != nil {
				return err
			}
		case "horizontal_accuracy":
			s.HorizontalAccuracy.Reset()
			if err := s.HorizontalAccuracy.Decode(d); err != nil {
				return err
			}
		case "live_period":
			s.LivePeriod.Reset()
			if err := s.LivePeriod.Decode(d); err != nil {
				return err
			}
		case "heading":
			s.Heading.Reset()
			if err := s.Heading.Decode(d); err != nil {
				return err
			}
		case "proximity_alert_radius":
			s.ProximityAlertRadius.Reset()
			if err := s.ProximityAlertRadius.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendLocation) {
					name = jsonFieldsNameOfSendLocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SendMediaGroup) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"media\"" + ":")
		e.ArrStart()
		if len(s.Media) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Media[0]
				elem.Encode(e)
			}
			for _, elem := range s.Media[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendMediaGroup = [6]string{
	0: "chat_id",
	1: "media",
	2: "disable_notification",
	3: "protect_content",
	4: "reply_to_message_id",
	5: "allow_sending_without_reply",
}

// Decode decodes SendMediaGroup from json.
func (s *SendMediaGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendMediaGroup to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "media":
			requiredBitSet[0] |= 1 << 1
			s.Media = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem SendMediaGroupMediaItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Media = append(s.Media, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendMediaGroup) {
					name = jsonFieldsNameOfSendMediaGroup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes SendMediaGroupMediaItem as json.
func (s SendMediaGroupMediaItem) Encode(e *jx.Writer) {
	switch s.Type {
	case InputMediaAudioSendMediaGroupMediaItem:
		s.InputMediaAudio.Encode(e)
	case InputMediaDocumentSendMediaGroupMediaItem:
		s.InputMediaDocument.Encode(e)
	case InputMediaPhotoSendMediaGroupMediaItem:
		s.InputMediaPhoto.Encode(e)
	case InputMediaVideoSendMediaGroupMediaItem:
		s.InputMediaVideo.Encode(e)
	}
}

// Decode decodes SendMediaGroupMediaItem from json.
func (s *SendMediaGroupMediaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendMediaGroupMediaItem to nil`)
	}
	// Sum type discriminator.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "audio":
					s.Type = InputMediaAudioSendMediaGroupMediaItem
					found = true
				case "document":
					s.Type = InputMediaDocumentSendMediaGroupMediaItem
					found = true
				case "photo":
					s.Type = InputMediaPhotoSendMediaGroupMediaItem
					found = true
				case "video":
					s.Type = InputMediaVideoSendMediaGroupMediaItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InputMediaAudioSendMediaGroupMediaItem:
		if err := s.InputMediaAudio.Decode(d); err != nil {
			return err
		}
	case InputMediaDocumentSendMediaGroupMediaItem:
		if err := s.InputMediaDocument.Decode(d); err != nil {
			return err
		}
	case InputMediaPhotoSendMediaGroupMediaItem:
		if err := s.InputMediaPhoto.Decode(d); err != nil {
			return err
		}
	case InputMediaVideoSendMediaGroupMediaItem:
		if err := s.InputMediaVideo.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s SendMessage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"text\"" + ":")
		e.Str(s.Text)
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.Entities != nil {
			e.Comma()
		}
		if s.Entities != nil {
			e.RawStr("\"entities\"" + ":")
			e.ArrStart()
			if len(s.Entities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Entities[0]
					elem.Encode(e)
				}
				for _, elem := range s.Entities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableWebPagePreview.Set {
			e.Comma()
		}
		if s.DisableWebPagePreview.Set {
			e.RawStr("\"disable_web_page_preview\"" + ":")
			s.DisableWebPagePreview.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendMessage = [10]string{
	0: "chat_id",
	1: "text",
	2: "parse_mode",
	3: "entities",
	4: "disable_web_page_preview",
	5: "disable_notification",
	6: "protect_content",
	7: "reply_to_message_id",
	8: "allow_sending_without_reply",
	9: "reply_markup",
}

// Decode decodes SendMessage from json.
func (s *SendMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendMessage to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "text":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Text = string(v)
			if err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "entities":
			s.Entities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Entities = append(s.Entities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_web_page_preview":
			s.DisableWebPagePreview.Reset()
			if err := s.DisableWebPagePreview.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendMessage) {
					name = jsonFieldsNameOfSendMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SendPhoto) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"photo\"" + ":")
		e.Str(s.Photo)
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendPhoto = [10]string{
	0: "chat_id",
	1: "photo",
	2: "caption",
	3: "parse_mode",
	4: "caption_entities",
	5: "disable_notification",
	6: "protect_content",
	7: "reply_to_message_id",
	8: "allow_sending_without_reply",
	9: "reply_markup",
}

// Decode decodes SendPhoto from json.
func (s *SendPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendPhoto to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "photo":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Photo = string(v)
			if err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendPhoto) {
					name = jsonFieldsNameOfSendPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SendPoll) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"question\"" + ":")
		e.Str(s.Question)
	}
	{
		e.Comma()

		e.RawStr("\"options\"" + ":")
		e.ArrStart()
		if len(s.Options) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Options[0]
				e.Str(elem)
			}
			for _, elem := range s.Options[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.IsAnonymous.Set {
			e.Comma()
		}
		if s.IsAnonymous.Set {
			e.RawStr("\"is_anonymous\"" + ":")
			s.IsAnonymous.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.Comma()
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.AllowsMultipleAnswers.Set {
			e.Comma()
		}
		if s.AllowsMultipleAnswers.Set {
			e.RawStr("\"allows_multiple_answers\"" + ":")
			s.AllowsMultipleAnswers.Encode(e)
		}
	}
	{
		if s.CorrectOptionID.Set {
			e.Comma()
		}
		if s.CorrectOptionID.Set {
			e.RawStr("\"correct_option_id\"" + ":")
			s.CorrectOptionID.Encode(e)
		}
	}
	{
		if s.Explanation.Set {
			e.Comma()
		}
		if s.Explanation.Set {
			e.RawStr("\"explanation\"" + ":")
			s.Explanation.Encode(e)
		}
	}
	{
		if s.ExplanationParseMode.Set {
			e.Comma()
		}
		if s.ExplanationParseMode.Set {
			e.RawStr("\"explanation_parse_mode\"" + ":")
			s.ExplanationParseMode.Encode(e)
		}
	}
	{
		if s.ExplanationEntities != nil {
			e.Comma()
		}
		if s.ExplanationEntities != nil {
			e.RawStr("\"explanation_entities\"" + ":")
			e.ArrStart()
			if len(s.ExplanationEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ExplanationEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.ExplanationEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.OpenPeriod.Set {
			e.Comma()
		}
		if s.OpenPeriod.Set {
			e.RawStr("\"open_period\"" + ":")
			s.OpenPeriod.Encode(e)
		}
	}
	{
		if s.CloseDate.Set {
			e.Comma()
		}
		if s.CloseDate.Set {
			e.RawStr("\"close_date\"" + ":")
			s.CloseDate.Encode(e)
		}
	}
	{
		if s.IsClosed.Set {
			e.Comma()
		}
		if s.IsClosed.Set {
			e.RawStr("\"is_closed\"" + ":")
			s.IsClosed.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendPoll = [18]string{
	0:  "chat_id",
	1:  "question",
	2:  "options",
	3:  "is_anonymous",
	4:  "type",
	5:  "allows_multiple_answers",
	6:  "correct_option_id",
	7:  "explanation",
	8:  "explanation_parse_mode",
	9:  "explanation_entities",
	10: "open_period",
	11: "close_date",
	12: "is_closed",
	13: "disable_notification",
	14: "protect_content",
	15: "reply_to_message_id",
	16: "allow_sending_without_reply",
	17: "reply_markup",
}

// Decode decodes SendPoll from json.
func (s *SendPoll) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendPoll to nil`)
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "question":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Question = string(v)
			if err != nil {
				return err
			}
		case "options":
			requiredBitSet[0] |= 1 << 2
			s.Options = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Options = append(s.Options, elem)
				return nil
			}); err != nil {
				return err
			}
		case "is_anonymous":
			s.IsAnonymous.Reset()
			if err := s.IsAnonymous.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "allows_multiple_answers":
			s.AllowsMultipleAnswers.Reset()
			if err := s.AllowsMultipleAnswers.Decode(d); err != nil {
				return err
			}
		case "correct_option_id":
			s.CorrectOptionID.Reset()
			if err := s.CorrectOptionID.Decode(d); err != nil {
				return err
			}
		case "explanation":
			s.Explanation.Reset()
			if err := s.Explanation.Decode(d); err != nil {
				return err
			}
		case "explanation_parse_mode":
			s.ExplanationParseMode.Reset()
			if err := s.ExplanationParseMode.Decode(d); err != nil {
				return err
			}
		case "explanation_entities":
			s.ExplanationEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ExplanationEntities = append(s.ExplanationEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "open_period":
			s.OpenPeriod.Reset()
			if err := s.OpenPeriod.Decode(d); err != nil {
				return err
			}
		case "close_date":
			s.CloseDate.Reset()
			if err := s.CloseDate.Decode(d); err != nil {
				return err
			}
		case "is_closed":
			s.IsClosed.Reset()
			if err := s.IsClosed.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000111,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendPoll) {
					name = jsonFieldsNameOfSendPoll[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes SendReplyMarkup as json.
func (s SendReplyMarkup) Encode(e *jx.Writer) {
	switch s.Type {
	case InlineKeyboardMarkupSendReplyMarkup:
		s.InlineKeyboardMarkup.Encode(e)
	case ReplyKeyboardMarkupSendReplyMarkup:
		s.ReplyKeyboardMarkup.Encode(e)
	case ReplyKeyboardRemoveSendReplyMarkup:
		s.ReplyKeyboardRemove.Encode(e)
	case ForceReplySendReplyMarkup:
		s.ForceReply.Encode(e)
	}
}

// Decode decodes SendReplyMarkup from json.
func (s *SendReplyMarkup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendReplyMarkup to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "inline_keyboard":
				found = true
				s.Type = InlineKeyboardMarkupSendReplyMarkup
			case "keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendReplyMarkup
			case "resize_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendReplyMarkup
			case "one_time_keyboard":
				found = true
				s.Type = ReplyKeyboardMarkupSendReplyMarkup
			case "remove_keyboard":
				found = true
				s.Type = ReplyKeyboardRemoveSendReplyMarkup
			case "force_reply":
				found = true
				s.Type = ForceReplySendReplyMarkup
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case InlineKeyboardMarkupSendReplyMarkup:
		if err := s.InlineKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardMarkupSendReplyMarkup:
		if err := s.ReplyKeyboardMarkup.Decode(d); err != nil {
			return err
		}
	case ReplyKeyboardRemoveSendReplyMarkup:
		if err := s.ReplyKeyboardRemove.Decode(d); err != nil {
			return err
		}
	case ForceReplySendReplyMarkup:
		if err := s.ForceReply.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s SendSticker) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"sticker\"" + ":")
		e.Str(s.Sticker)
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendSticker = [7]string{
	0: "chat_id",
	1: "sticker",
	2: "disable_notification",
	3: "protect_content",
	4: "reply_to_message_id",
	5: "allow_sending_without_reply",
	6: "reply_markup",
}

// Decode decodes SendSticker from json.
func (s *SendSticker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendSticker to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "sticker":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Sticker = string(v)
			if err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendSticker) {
					name = jsonFieldsNameOfSendSticker[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SendVenue) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"latitude\"" + ":")
		e.Float64(s.Latitude)
	}
	{
		e.Comma()

		e.RawStr("\"longitude\"" + ":")
		e.Float64(s.Longitude)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"address\"" + ":")
		e.Str(s.Address)
	}
	{
		if s.FoursquareID.Set {
			e.Comma()
		}
		if s.FoursquareID.Set {
			e.RawStr("\"foursquare_id\"" + ":")
			s.FoursquareID.Encode(e)
		}
	}
	{
		if s.FoursquareType.Set {
			e.Comma()
		}
		if s.FoursquareType.Set {
			e.RawStr("\"foursquare_type\"" + ":")
			s.FoursquareType.Encode(e)
		}
	}
	{
		if s.GooglePlaceID.Set {
			e.Comma()
		}
		if s.GooglePlaceID.Set {
			e.RawStr("\"google_place_id\"" + ":")
			s.GooglePlaceID.Encode(e)
		}
	}
	{
		if s.GooglePlaceType.Set {
			e.Comma()
		}
		if s.GooglePlaceType.Set {
			e.RawStr("\"google_place_type\"" + ":")
			s.GooglePlaceType.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendVenue = [14]string{
	0:  "chat_id",
	1:  "latitude",
	2:  "longitude",
	3:  "title",
	4:  "address",
	5:  "foursquare_id",
	6:  "foursquare_type",
	7:  "google_place_id",
	8:  "google_place_type",
	9:  "disable_notification",
	10: "protect_content",
	11: "reply_to_message_id",
	12: "allow_sending_without_reply",
	13: "reply_markup",
}

// Decode decodes SendVenue from json.
func (s *SendVenue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendVenue to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Float64()
			s.Latitude = float64(v)
			if err != nil {
				return err
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Float64()
			s.Longitude = float64(v)
			if err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "address":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.Address = string(v)
			if err != nil {
				return err
			}
		case "foursquare_id":
			s.FoursquareID.Reset()
			if err := s.FoursquareID.Decode(d); err != nil {
				return err
			}
		case "foursquare_type":
			s.FoursquareType.Reset()
			if err := s.FoursquareType.Decode(d); err != nil {
				return err
			}
		case "google_place_id":
			s.GooglePlaceID.Reset()
			if err := s.GooglePlaceID.Decode(d); err != nil {
				return err
			}
		case "google_place_type":
			s.GooglePlaceType.Reset()
			if err := s.GooglePlaceType.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendVenue) {
					name = jsonFieldsNameOfSendVenue[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SendVideo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"video\"" + ":")
		e.Str(s.Video)
	}
	{
		if s.Duration.Set {
			e.Comma()
		}
		if s.Duration.Set {
			e.RawStr("\"duration\"" + ":")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Width.Set {
			e.Comma()
		}
		if s.Width.Set {
			e.RawStr("\"width\"" + ":")
			s.Width.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.Comma()
		}
		if s.Height.Set {
			e.RawStr("\"height\"" + ":")
			s.Height.Encode(e)
		}
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.SupportsStreaming.Set {
			e.Comma()
		}
		if s.SupportsStreaming.Set {
			e.RawStr("\"supports_streaming\"" + ":")
			s.SupportsStreaming.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendVideo = [15]string{
	0:  "chat_id",
	1:  "video",
	2:  "duration",
	3:  "width",
	4:  "height",
	5:  "thumb",
	6:  "caption",
	7:  "parse_mode",
	8:  "caption_entities",
	9:  "supports_streaming",
	10: "disable_notification",
	11: "protect_content",
	12: "reply_to_message_id",
	13: "allow_sending_without_reply",
	14: "reply_markup",
}

// Decode decodes SendVideo from json.
func (s *SendVideo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendVideo to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "video":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Video = string(v)
			if err != nil {
				return err
			}
		case "duration":
			s.Duration.Reset()
			if err := s.Duration.Decode(d); err != nil {
				return err
			}
		case "width":
			s.Width.Reset()
			if err := s.Width.Decode(d); err != nil {
				return err
			}
		case "height":
			s.Height.Reset()
			if err := s.Height.Decode(d); err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "supports_streaming":
			s.SupportsStreaming.Reset()
			if err := s.SupportsStreaming.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendVideo) {
					name = jsonFieldsNameOfSendVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SendVideoNote) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"video_note\"" + ":")
		e.Str(s.VideoNote)
	}
	{
		if s.Duration.Set {
			e.Comma()
		}
		if s.Duration.Set {
			e.RawStr("\"duration\"" + ":")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Length.Set {
			e.Comma()
		}
		if s.Length.Set {
			e.RawStr("\"length\"" + ":")
			s.Length.Encode(e)
		}
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendVideoNote = [10]string{
	0: "chat_id",
	1: "video_note",
	2: "duration",
	3: "length",
	4: "thumb",
	5: "disable_notification",
	6: "protect_content",
	7: "reply_to_message_id",
	8: "allow_sending_without_reply",
	9: "reply_markup",
}

// Decode decodes SendVideoNote from json.
func (s *SendVideoNote) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendVideoNote to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "video_note":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.VideoNote = string(v)
			if err != nil {
				return err
			}
		case "duration":
			s.Duration.Reset()
			if err := s.Duration.Decode(d); err != nil {
				return err
			}
		case "length":
			s.Length.Reset()
			if err := s.Length.Decode(d); err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendVideoNote) {
					name = jsonFieldsNameOfSendVideoNote[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SendVoice) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"voice\"" + ":")
		e.Str(s.Voice)
	}
	{
		if s.Caption.Set {
			e.Comma()
		}
		if s.Caption.Set {
			e.RawStr("\"caption\"" + ":")
			s.Caption.Encode(e)
		}
	}
	{
		if s.ParseMode.Set {
			e.Comma()
		}
		if s.ParseMode.Set {
			e.RawStr("\"parse_mode\"" + ":")
			s.ParseMode.Encode(e)
		}
	}
	{
		if s.CaptionEntities != nil {
			e.Comma()
		}
		if s.CaptionEntities != nil {
			e.RawStr("\"caption_entities\"" + ":")
			e.ArrStart()
			if len(s.CaptionEntities) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CaptionEntities[0]
					elem.Encode(e)
				}
				for _, elem := range s.CaptionEntities[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Duration.Set {
			e.Comma()
		}
		if s.Duration.Set {
			e.RawStr("\"duration\"" + ":")
			s.Duration.Encode(e)
		}
	}
	{
		if s.DisableNotification.Set {
			e.Comma()
		}
		if s.DisableNotification.Set {
			e.RawStr("\"disable_notification\"" + ":")
			s.DisableNotification.Encode(e)
		}
	}
	{
		if s.ProtectContent.Set {
			e.Comma()
		}
		if s.ProtectContent.Set {
			e.RawStr("\"protect_content\"" + ":")
			s.ProtectContent.Encode(e)
		}
	}
	{
		if s.ReplyToMessageID.Set {
			e.Comma()
		}
		if s.ReplyToMessageID.Set {
			e.RawStr("\"reply_to_message_id\"" + ":")
			s.ReplyToMessageID.Encode(e)
		}
	}
	{
		if s.AllowSendingWithoutReply.Set {
			e.Comma()
		}
		if s.AllowSendingWithoutReply.Set {
			e.RawStr("\"allow_sending_without_reply\"" + ":")
			s.AllowSendingWithoutReply.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSendVoice = [11]string{
	0:  "chat_id",
	1:  "voice",
	2:  "caption",
	3:  "parse_mode",
	4:  "caption_entities",
	5:  "duration",
	6:  "disable_notification",
	7:  "protect_content",
	8:  "reply_to_message_id",
	9:  "allow_sending_without_reply",
	10: "reply_markup",
}

// Decode decodes SendVoice from json.
func (s *SendVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SendVoice to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "voice":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Voice = string(v)
			if err != nil {
				return err
			}
		case "caption":
			s.Caption.Reset()
			if err := s.Caption.Decode(d); err != nil {
				return err
			}
		case "parse_mode":
			s.ParseMode.Reset()
			if err := s.ParseMode.Decode(d); err != nil {
				return err
			}
		case "caption_entities":
			s.CaptionEntities = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MessageEntity
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CaptionEntities = append(s.CaptionEntities, elem)
				return nil
			}); err != nil {
				return err
			}
		case "duration":
			s.Duration.Reset()
			if err := s.Duration.Decode(d); err != nil {
				return err
			}
		case "disable_notification":
			s.DisableNotification.Reset()
			if err := s.DisableNotification.Decode(d); err != nil {
				return err
			}
		case "protect_content":
			s.ProtectContent.Reset()
			if err := s.ProtectContent.Decode(d); err != nil {
				return err
			}
		case "reply_to_message_id":
			s.ReplyToMessageID.Reset()
			if err := s.ReplyToMessageID.Decode(d); err != nil {
				return err
			}
		case "allow_sending_without_reply":
			s.AllowSendingWithoutReply.Reset()
			if err := s.AllowSendingWithoutReply.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendVoice) {
					name = jsonFieldsNameOfSendVoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SetChatAdministratorCustomTitle) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	{
		e.Comma()

		e.RawStr("\"custom_title\"" + ":")
		e.Str(s.CustomTitle)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSetChatAdministratorCustomTitle = [3]string{
	0: "chat_id",
	1: "user_id",
	2: "custom_title",
}

// Decode decodes SetChatAdministratorCustomTitle from json.
func (s *SetChatAdministratorCustomTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetChatAdministratorCustomTitle to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		case "custom_title":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.CustomTitle = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatAdministratorCustomTitle) {
					name = jsonFieldsNameOfSetChatAdministratorCustomTitle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SetChatDescription) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSetChatDescription = [2]string{
	0: "chat_id",
	1: "description",
}

// Decode decodes SetChatDescription from json.
func (s *SetChatDescription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetChatDescription to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatDescription) {
					name = jsonFieldsNameOfSetChatDescription[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SetChatPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"permissions\"" + ":")
		s.Permissions.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSetChatPermissions = [2]string{
	0: "chat_id",
	1: "permissions",
}

// Decode decodes SetChatPermissions from json.
func (s *SetChatPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetChatPermissions to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 1
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatPermissions) {
					name = jsonFieldsNameOfSetChatPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SetChatPhoto) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"photo\"" + ":")
		e.Str(s.Photo)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSetChatPhoto = [2]string{
	0: "chat_id",
	1: "photo",
}

// Decode decodes SetChatPhoto from json.
func (s *SetChatPhoto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetChatPhoto to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "photo":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Photo = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatPhoto) {
					name = jsonFieldsNameOfSetChatPhoto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SetChatStickerSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"sticker_set_name\"" + ":")
		e.Str(s.StickerSetName)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSetChatStickerSet = [2]string{
	0: "chat_id",
	1: "sticker_set_name",
}

// Decode decodes SetChatStickerSet from json.
func (s *SetChatStickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetChatStickerSet to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "sticker_set_name":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.StickerSetName = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatStickerSet) {
					name = jsonFieldsNameOfSetChatStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SetChatTitle) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSetChatTitle = [2]string{
	0: "chat_id",
	1: "title",
}

// Decode decodes SetChatTitle from json.
func (s *SetChatTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetChatTitle to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetChatTitle) {
					name = jsonFieldsNameOfSetChatTitle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SetGameScore) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	{
		e.Comma()

		e.RawStr("\"score\"" + ":")
		e.Int(s.Score)
	}
	{
		if s.Force.Set {
			e.Comma()
		}
		if s.Force.Set {
			e.RawStr("\"force\"" + ":")
			s.Force.Encode(e)
		}
	}
	{
		if s.DisableEditMessage.Set {
			e.Comma()
		}
		if s.DisableEditMessage.Set {
			e.RawStr("\"disable_edit_message\"" + ":")
			s.DisableEditMessage.Encode(e)
		}
	}
	{
		if s.ChatID.Set {
			e.Comma()
		}
		if s.ChatID.Set {
			e.RawStr("\"chat_id\"" + ":")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			e.Comma()
		}
		if s.MessageID.Set {
			e.RawStr("\"message_id\"" + ":")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			e.Comma()
		}
		if s.InlineMessageID.Set {
			e.RawStr("\"inline_message_id\"" + ":")
			s.InlineMessageID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSetGameScore = [7]string{
	0: "user_id",
	1: "score",
	2: "force",
	3: "disable_edit_message",
	4: "chat_id",
	5: "message_id",
	6: "inline_message_id",
}

// Decode decodes SetGameScore from json.
func (s *SetGameScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetGameScore to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		case "score":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int()
			s.Score = int(v)
			if err != nil {
				return err
			}
		case "force":
			s.Force.Reset()
			if err := s.Force.Decode(d); err != nil {
				return err
			}
		case "disable_edit_message":
			s.DisableEditMessage.Reset()
			if err := s.DisableEditMessage.Decode(d); err != nil {
				return err
			}
		case "chat_id":
			s.ChatID.Reset()
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetGameScore) {
					name = jsonFieldsNameOfSetGameScore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SetMyCommands) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"commands\"" + ":")
		e.ArrStart()
		if len(s.Commands) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Commands[0]
				elem.Encode(e)
			}
			for _, elem := range s.Commands[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Scope.Set {
			e.Comma()
		}
		if s.Scope.Set {
			e.RawStr("\"scope\"" + ":")
			s.Scope.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.Comma()
		}
		if s.LanguageCode.Set {
			e.RawStr("\"language_code\"" + ":")
			s.LanguageCode.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSetMyCommands = [3]string{
	0: "commands",
	1: "scope",
	2: "language_code",
}

// Decode decodes SetMyCommands from json.
func (s *SetMyCommands) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetMyCommands to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commands":
			requiredBitSet[0] |= 1 << 0
			s.Commands = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem BotCommand
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Commands = append(s.Commands, elem)
				return nil
			}); err != nil {
				return err
			}
		case "scope":
			s.Scope.Reset()
			if err := s.Scope.Decode(d); err != nil {
				return err
			}
		case "language_code":
			s.LanguageCode.Reset()
			if err := s.LanguageCode.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetMyCommands) {
					name = jsonFieldsNameOfSetMyCommands[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SetPassportDataErrors) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	{
		e.Comma()

		e.RawStr("\"errors\"" + ":")
		e.ArrStart()
		if len(s.Errors) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Errors[0]
				elem.Encode(e)
			}
			for _, elem := range s.Errors[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSetPassportDataErrors = [2]string{
	0: "user_id",
	1: "errors",
}

// Decode decodes SetPassportDataErrors from json.
func (s *SetPassportDataErrors) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetPassportDataErrors to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		case "errors":
			requiredBitSet[0] |= 1 << 1
			s.Errors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PassportElementError
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Errors = append(s.Errors, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetPassportDataErrors) {
					name = jsonFieldsNameOfSetPassportDataErrors[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SetStickerPositionInSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sticker\"" + ":")
		e.Str(s.Sticker)
	}
	{
		e.Comma()

		e.RawStr("\"position\"" + ":")
		e.Int(s.Position)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSetStickerPositionInSet = [2]string{
	0: "sticker",
	1: "position",
}

// Decode decodes SetStickerPositionInSet from json.
func (s *SetStickerPositionInSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetStickerPositionInSet to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sticker":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Sticker = string(v)
			if err != nil {
				return err
			}
		case "position":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int()
			s.Position = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetStickerPositionInSet) {
					name = jsonFieldsNameOfSetStickerPositionInSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SetStickerSetThumb) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSetStickerSetThumb = [3]string{
	0: "name",
	1: "user_id",
	2: "thumb",
}

// Decode decodes SetStickerSetThumb from json.
func (s *SetStickerSetThumb) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetStickerSetThumb to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetStickerSetThumb) {
					name = jsonFieldsNameOfSetStickerSetThumb[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SetWebhook) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		if s.Certificate.Set {
			e.Comma()
		}
		if s.Certificate.Set {
			e.RawStr("\"certificate\"" + ":")
			s.Certificate.Encode(e)
		}
	}
	{
		if s.IPAddress.Set {
			e.Comma()
		}
		if s.IPAddress.Set {
			e.RawStr("\"ip_address\"" + ":")
			s.IPAddress.Encode(e)
		}
	}
	{
		if s.MaxConnections.Set {
			e.Comma()
		}
		if s.MaxConnections.Set {
			e.RawStr("\"max_connections\"" + ":")
			s.MaxConnections.Encode(e)
		}
	}
	{
		if s.AllowedUpdates != nil {
			e.Comma()
		}
		if s.AllowedUpdates != nil {
			e.RawStr("\"allowed_updates\"" + ":")
			e.ArrStart()
			if len(s.AllowedUpdates) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedUpdates[0]
					e.Str(elem)
				}
				for _, elem := range s.AllowedUpdates[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DropPendingUpdates.Set {
			e.Comma()
		}
		if s.DropPendingUpdates.Set {
			e.RawStr("\"drop_pending_updates\"" + ":")
			s.DropPendingUpdates.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSetWebhook = [6]string{
	0: "url",
	1: "certificate",
	2: "ip_address",
	3: "max_connections",
	4: "allowed_updates",
	5: "drop_pending_updates",
}

// Decode decodes SetWebhook from json.
func (s *SetWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SetWebhook to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "certificate":
			s.Certificate.Reset()
			if err := s.Certificate.Decode(d); err != nil {
				return err
			}
		case "ip_address":
			s.IPAddress.Reset()
			if err := s.IPAddress.Decode(d); err != nil {
				return err
			}
		case "max_connections":
			s.MaxConnections.Reset()
			if err := s.MaxConnections.Decode(d); err != nil {
				return err
			}
		case "allowed_updates":
			s.AllowedUpdates = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AllowedUpdates = append(s.AllowedUpdates, elem)
				return nil
			}); err != nil {
				return err
			}
		case "drop_pending_updates":
			s.DropPendingUpdates.Reset()
			if err := s.DropPendingUpdates.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetWebhook) {
					name = jsonFieldsNameOfSetWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ShippingAddress) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"country_code\"" + ":")
		e.Str(s.CountryCode)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"city\"" + ":")
		e.Str(s.City)
	}
	{
		e.Comma()

		e.RawStr("\"street_line1\"" + ":")
		e.Str(s.StreetLine1)
	}
	{
		e.Comma()

		e.RawStr("\"street_line2\"" + ":")
		e.Str(s.StreetLine2)
	}
	{
		e.Comma()

		e.RawStr("\"post_code\"" + ":")
		e.Str(s.PostCode)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfShippingAddress = [6]string{
	0: "country_code",
	1: "state",
	2: "city",
	3: "street_line1",
	4: "street_line2",
	5: "post_code",
}

// Decode decodes ShippingAddress from json.
func (s *ShippingAddress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ShippingAddress to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "country_code":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.CountryCode = string(v)
			if err != nil {
				return err
			}
		case "state":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "city":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.City = string(v)
			if err != nil {
				return err
			}
		case "street_line1":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Str()
			s.StreetLine1 = string(v)
			if err != nil {
				return err
			}
		case "street_line2":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Str()
			s.StreetLine2 = string(v)
			if err != nil {
				return err
			}
		case "post_code":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.PostCode = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfShippingAddress) {
					name = jsonFieldsNameOfShippingAddress[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ShippingOption) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"prices\"" + ":")
		e.ArrStart()
		if len(s.Prices) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Prices[0]
				elem.Encode(e)
			}
			for _, elem := range s.Prices[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfShippingOption = [3]string{
	0: "id",
	1: "title",
	2: "prices",
}

// Decode decodes ShippingOption from json.
func (s *ShippingOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ShippingOption to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "prices":
			requiredBitSet[0] |= 1 << 2
			s.Prices = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem LabeledPrice
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Prices = append(s.Prices, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfShippingOption) {
					name = jsonFieldsNameOfShippingOption[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ShippingQuery) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"from\"" + ":")
		s.From.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"invoice_payload\"" + ":")
		e.Str(s.InvoicePayload)
	}
	{
		e.Comma()

		e.RawStr("\"shipping_address\"" + ":")
		s.ShippingAddress.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfShippingQuery = [4]string{
	0: "id",
	1: "from",
	2: "invoice_payload",
	3: "shipping_address",
}

// Decode decodes ShippingQuery from json.
func (s *ShippingQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ShippingQuery to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := s.From.Decode(d); err != nil {
				return err
			}
		case "invoice_payload":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.InvoicePayload = string(v)
			if err != nil {
				return err
			}
		case "shipping_address":
			requiredBitSet[0] |= 1 << 3
			if err := s.ShippingAddress.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfShippingQuery) {
					name = jsonFieldsNameOfShippingQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Sticker) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"file_id\"" + ":")
		e.Str(s.FileID)
	}
	{
		e.Comma()

		e.RawStr("\"file_unique_id\"" + ":")
		e.Str(s.FileUniqueID)
	}
	{
		e.Comma()

		e.RawStr("\"width\"" + ":")
		e.Int(s.Width)
	}
	{
		e.Comma()

		e.RawStr("\"height\"" + ":")
		e.Int(s.Height)
	}
	{
		e.Comma()

		e.RawStr("\"is_animated\"" + ":")
		e.Bool(s.IsAnimated)
	}
	{
		e.Comma()

		e.RawStr("\"is_video\"" + ":")
		e.Bool(s.IsVideo)
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.Emoji.Set {
			e.Comma()
		}
		if s.Emoji.Set {
			e.RawStr("\"emoji\"" + ":")
			s.Emoji.Encode(e)
		}
	}
	{
		if s.SetName.Set {
			e.Comma()
		}
		if s.SetName.Set {
			e.RawStr("\"set_name\"" + ":")
			s.SetName.Encode(e)
		}
	}
	{
		if s.MaskPosition.Set {
			e.Comma()
		}
		if s.MaskPosition.Set {
			e.RawStr("\"mask_position\"" + ":")
			s.MaskPosition.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.Comma()
		}
		if s.FileSize.Set {
			e.RawStr("\"file_size\"" + ":")
			s.FileSize.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSticker = [11]string{
	0:  "file_id",
	1:  "file_unique_id",
	2:  "width",
	3:  "height",
	4:  "is_animated",
	5:  "is_video",
	6:  "thumb",
	7:  "emoji",
	8:  "set_name",
	9:  "mask_position",
	10: "file_size",
}

// Decode decodes Sticker from json.
func (s *Sticker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Sticker to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "width":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.Width = int(v)
			if err != nil {
				return err
			}
		case "height":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Int()
			s.Height = int(v)
			if err != nil {
				return err
			}
		case "is_animated":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Bool()
			s.IsAnimated = bool(v)
			if err != nil {
				return err
			}
		case "is_video":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Bool()
			s.IsVideo = bool(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "emoji":
			s.Emoji.Reset()
			if err := s.Emoji.Decode(d); err != nil {
				return err
			}
		case "set_name":
			s.SetName.Reset()
			if err := s.SetName.Decode(d); err != nil {
				return err
			}
		case "mask_position":
			s.MaskPosition.Reset()
			if err := s.MaskPosition.Decode(d); err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSticker) {
					name = jsonFieldsNameOfSticker[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s StickerSet) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"is_animated\"" + ":")
		e.Bool(s.IsAnimated)
	}
	{
		e.Comma()

		e.RawStr("\"is_video\"" + ":")
		e.Bool(s.IsVideo)
	}
	{
		e.Comma()

		e.RawStr("\"contains_masks\"" + ":")
		e.Bool(s.ContainsMasks)
	}
	{
		e.Comma()

		e.RawStr("\"stickers\"" + ":")
		e.ArrStart()
		if len(s.Stickers) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Stickers[0]
				elem.Encode(e)
			}
			for _, elem := range s.Stickers[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfStickerSet = [7]string{
	0: "name",
	1: "title",
	2: "is_animated",
	3: "is_video",
	4: "contains_masks",
	5: "stickers",
	6: "thumb",
}

// Decode decodes StickerSet from json.
func (s *StickerSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode StickerSet to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "is_animated":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Bool()
			s.IsAnimated = bool(v)
			if err != nil {
				return err
			}
		case "is_video":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Bool()
			s.IsVideo = bool(v)
			if err != nil {
				return err
			}
		case "contains_masks":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Bool()
			s.ContainsMasks = bool(v)
			if err != nil {
				return err
			}
		case "stickers":
			requiredBitSet[0] |= 1 << 5
			s.Stickers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Sticker
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Stickers = append(s.Stickers, elem)
				return nil
			}); err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStickerSet) {
					name = jsonFieldsNameOfStickerSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s StopMessageLiveLocation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ChatID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ChatID.Set {
			e.RawStr("\"chat_id\"" + ":")
			s.ChatID.Encode(e)
		}
	}
	{
		if s.MessageID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MessageID.Set {
			e.RawStr("\"message_id\"" + ":")
			s.MessageID.Encode(e)
		}
	}
	{
		if s.InlineMessageID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InlineMessageID.Set {
			e.RawStr("\"inline_message_id\"" + ":")
			s.InlineMessageID.Encode(e)
		}
	}
	{
		if s.ReplyMarkup.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfStopMessageLiveLocation = [4]string{
	0: "chat_id",
	1: "message_id",
	2: "inline_message_id",
	3: "reply_markup",
}

// Decode decodes StopMessageLiveLocation from json.
func (s *StopMessageLiveLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode StopMessageLiveLocation to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			s.ChatID.Reset()
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		case "inline_message_id":
			s.InlineMessageID.Reset()
			if err := s.InlineMessageID.Decode(d); err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s StopPoll) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"message_id\"" + ":")
		e.Int(s.MessageID)
	}
	{
		if s.ReplyMarkup.Set {
			e.Comma()
		}
		if s.ReplyMarkup.Set {
			e.RawStr("\"reply_markup\"" + ":")
			s.ReplyMarkup.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfStopPoll = [3]string{
	0: "chat_id",
	1: "message_id",
	2: "reply_markup",
}

// Decode decodes StopPoll from json.
func (s *StopPoll) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode StopPoll to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int()
			s.MessageID = int(v)
			if err != nil {
				return err
			}
		case "reply_markup":
			s.ReplyMarkup.Reset()
			if err := s.ReplyMarkup.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStopPoll) {
					name = jsonFieldsNameOfStopPoll[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SuccessfulPayment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currency\"" + ":")
		e.Str(s.Currency)
	}
	{
		e.Comma()

		e.RawStr("\"total_amount\"" + ":")
		e.Int(s.TotalAmount)
	}
	{
		e.Comma()

		e.RawStr("\"invoice_payload\"" + ":")
		e.Str(s.InvoicePayload)
	}
	{
		if s.ShippingOptionID.Set {
			e.Comma()
		}
		if s.ShippingOptionID.Set {
			e.RawStr("\"shipping_option_id\"" + ":")
			s.ShippingOptionID.Encode(e)
		}
	}
	{
		if s.OrderInfo.Set {
			e.Comma()
		}
		if s.OrderInfo.Set {
			e.RawStr("\"order_info\"" + ":")
			s.OrderInfo.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"telegram_payment_charge_id\"" + ":")
		e.Str(s.TelegramPaymentChargeID)
	}
	{
		e.Comma()

		e.RawStr("\"provider_payment_charge_id\"" + ":")
		e.Str(s.ProviderPaymentChargeID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSuccessfulPayment = [7]string{
	0: "currency",
	1: "total_amount",
	2: "invoice_payload",
	3: "shipping_option_id",
	4: "order_info",
	5: "telegram_payment_charge_id",
	6: "provider_payment_charge_id",
}

// Decode decodes SuccessfulPayment from json.
func (s *SuccessfulPayment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SuccessfulPayment to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.Currency = string(v)
			if err != nil {
				return err
			}
		case "total_amount":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int()
			s.TotalAmount = int(v)
			if err != nil {
				return err
			}
		case "invoice_payload":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.InvoicePayload = string(v)
			if err != nil {
				return err
			}
		case "shipping_option_id":
			s.ShippingOptionID.Reset()
			if err := s.ShippingOptionID.Decode(d); err != nil {
				return err
			}
		case "order_info":
			s.OrderInfo.Reset()
			if err := s.OrderInfo.Decode(d); err != nil {
				return err
			}
		case "telegram_payment_charge_id":
			requiredBitSet[0] |= 1 << 5
			v, err := d.Str()
			s.TelegramPaymentChargeID = string(v)
			if err != nil {
				return err
			}
		case "provider_payment_charge_id":
			requiredBitSet[0] |= 1 << 6
			v, err := d.Str()
			s.ProviderPaymentChargeID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessfulPayment) {
					name = jsonFieldsNameOfSuccessfulPayment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UnbanChatMember) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	{
		if s.OnlyIfBanned.Set {
			e.Comma()
		}
		if s.OnlyIfBanned.Set {
			e.RawStr("\"only_if_banned\"" + ":")
			s.OnlyIfBanned.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUnbanChatMember = [3]string{
	0: "chat_id",
	1: "user_id",
	2: "only_if_banned",
}

// Decode decodes UnbanChatMember from json.
func (s *UnbanChatMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UnbanChatMember to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		case "only_if_banned":
			s.OnlyIfBanned.Reset()
			if err := s.OnlyIfBanned.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnbanChatMember) {
					name = jsonFieldsNameOfUnbanChatMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UnbanChatSenderChat) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"sender_chat_id\"" + ":")
		e.Int64(s.SenderChatID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUnbanChatSenderChat = [2]string{
	0: "chat_id",
	1: "sender_chat_id",
}

// Decode decodes UnbanChatSenderChat from json.
func (s *UnbanChatSenderChat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UnbanChatSenderChat to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "sender_chat_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Int64()
			s.SenderChatID = int64(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnbanChatSenderChat) {
					name = jsonFieldsNameOfUnbanChatSenderChat[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UnpinAllChatMessages) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUnpinAllChatMessages = [1]string{
	0: "chat_id",
}

// Decode decodes UnpinAllChatMessages from json.
func (s *UnpinAllChatMessages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UnpinAllChatMessages to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnpinAllChatMessages) {
					name = jsonFieldsNameOfUnpinAllChatMessages[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UnpinChatMessage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"chat_id\"" + ":")
		s.ChatID.Encode(e)
	}
	{
		if s.MessageID.Set {
			e.Comma()
		}
		if s.MessageID.Set {
			e.RawStr("\"message_id\"" + ":")
			s.MessageID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUnpinChatMessage = [2]string{
	0: "chat_id",
	1: "message_id",
}

// Decode decodes UnpinChatMessage from json.
func (s *UnpinChatMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UnpinChatMessage to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_id":
			requiredBitSet[0] |= 1 << 0
			if err := s.ChatID.Decode(d); err != nil {
				return err
			}
		case "message_id":
			s.MessageID.Reset()
			if err := s.MessageID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnpinChatMessage) {
					name = jsonFieldsNameOfUnpinChatMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Update) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"update_id\"" + ":")
		e.Int(s.UpdateID)
	}
	{
		if s.Message.Set {
			e.Comma()
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.EditedMessage.Set {
			e.Comma()
		}
		if s.EditedMessage.Set {
			e.RawStr("\"edited_message\"" + ":")
			s.EditedMessage.Encode(e)
		}
	}
	{
		if s.ChannelPost.Set {
			e.Comma()
		}
		if s.ChannelPost.Set {
			e.RawStr("\"channel_post\"" + ":")
			s.ChannelPost.Encode(e)
		}
	}
	{
		if s.EditedChannelPost.Set {
			e.Comma()
		}
		if s.EditedChannelPost.Set {
			e.RawStr("\"edited_channel_post\"" + ":")
			s.EditedChannelPost.Encode(e)
		}
	}
	{
		if s.InlineQuery.Set {
			e.Comma()
		}
		if s.InlineQuery.Set {
			e.RawStr("\"inline_query\"" + ":")
			s.InlineQuery.Encode(e)
		}
	}
	{
		if s.ChosenInlineResult.Set {
			e.Comma()
		}
		if s.ChosenInlineResult.Set {
			e.RawStr("\"chosen_inline_result\"" + ":")
			s.ChosenInlineResult.Encode(e)
		}
	}
	{
		if s.CallbackQuery.Set {
			e.Comma()
		}
		if s.CallbackQuery.Set {
			e.RawStr("\"callback_query\"" + ":")
			s.CallbackQuery.Encode(e)
		}
	}
	{
		if s.ShippingQuery.Set {
			e.Comma()
		}
		if s.ShippingQuery.Set {
			e.RawStr("\"shipping_query\"" + ":")
			s.ShippingQuery.Encode(e)
		}
	}
	{
		if s.PreCheckoutQuery.Set {
			e.Comma()
		}
		if s.PreCheckoutQuery.Set {
			e.RawStr("\"pre_checkout_query\"" + ":")
			s.PreCheckoutQuery.Encode(e)
		}
	}
	{
		if s.Poll.Set {
			e.Comma()
		}
		if s.Poll.Set {
			e.RawStr("\"poll\"" + ":")
			s.Poll.Encode(e)
		}
	}
	{
		if s.PollAnswer.Set {
			e.Comma()
		}
		if s.PollAnswer.Set {
			e.RawStr("\"poll_answer\"" + ":")
			s.PollAnswer.Encode(e)
		}
	}
	{
		if s.MyChatMember.Set {
			e.Comma()
		}
		if s.MyChatMember.Set {
			e.RawStr("\"my_chat_member\"" + ":")
			s.MyChatMember.Encode(e)
		}
	}
	{
		if s.ChatMember.Set {
			e.Comma()
		}
		if s.ChatMember.Set {
			e.RawStr("\"chat_member\"" + ":")
			s.ChatMember.Encode(e)
		}
	}
	{
		if s.ChatJoinRequest.Set {
			e.Comma()
		}
		if s.ChatJoinRequest.Set {
			e.RawStr("\"chat_join_request\"" + ":")
			s.ChatJoinRequest.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUpdate = [15]string{
	0:  "update_id",
	1:  "message",
	2:  "edited_message",
	3:  "channel_post",
	4:  "edited_channel_post",
	5:  "inline_query",
	6:  "chosen_inline_result",
	7:  "callback_query",
	8:  "shipping_query",
	9:  "pre_checkout_query",
	10: "poll",
	11: "poll_answer",
	12: "my_chat_member",
	13: "chat_member",
	14: "chat_join_request",
}

// Decode decodes Update from json.
func (s *Update) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Update to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "update_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.UpdateID = int(v)
			if err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "edited_message":
			s.EditedMessage.Reset()
			if err := s.EditedMessage.Decode(d); err != nil {
				return err
			}
		case "channel_post":
			s.ChannelPost.Reset()
			if err := s.ChannelPost.Decode(d); err != nil {
				return err
			}
		case "edited_channel_post":
			s.EditedChannelPost.Reset()
			if err := s.EditedChannelPost.Decode(d); err != nil {
				return err
			}
		case "inline_query":
			s.InlineQuery.Reset()
			if err := s.InlineQuery.Decode(d); err != nil {
				return err
			}
		case "chosen_inline_result":
			s.ChosenInlineResult.Reset()
			if err := s.ChosenInlineResult.Decode(d); err != nil {
				return err
			}
		case "callback_query":
			s.CallbackQuery.Reset()
			if err := s.CallbackQuery.Decode(d); err != nil {
				return err
			}
		case "shipping_query":
			s.ShippingQuery.Reset()
			if err := s.ShippingQuery.Decode(d); err != nil {
				return err
			}
		case "pre_checkout_query":
			s.PreCheckoutQuery.Reset()
			if err := s.PreCheckoutQuery.Decode(d); err != nil {
				return err
			}
		case "poll":
			s.Poll.Reset()
			if err := s.Poll.Decode(d); err != nil {
				return err
			}
		case "poll_answer":
			s.PollAnswer.Reset()
			if err := s.PollAnswer.Decode(d); err != nil {
				return err
			}
		case "my_chat_member":
			s.MyChatMember.Reset()
			if err := s.MyChatMember.Decode(d); err != nil {
				return err
			}
		case "chat_member":
			s.ChatMember.Reset()
			if err := s.ChatMember.Decode(d); err != nil {
				return err
			}
		case "chat_join_request":
			s.ChatJoinRequest.Reset()
			if err := s.ChatJoinRequest.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdate) {
					name = jsonFieldsNameOfUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UploadStickerFile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"user_id\"" + ":")
		e.Int64(s.UserID)
	}
	{
		e.Comma()

		e.RawStr("\"png_sticker\"" + ":")
		e.Str(s.PNGSticker)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUploadStickerFile = [2]string{
	0: "user_id",
	1: "png_sticker",
}

// Decode decodes UploadStickerFile from json.
func (s *UploadStickerFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UploadStickerFile to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int64()
			s.UserID = int64(v)
			if err != nil {
				return err
			}
		case "png_sticker":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.PNGSticker = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUploadStickerFile) {
					name = jsonFieldsNameOfUploadStickerFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s User) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int64(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"is_bot\"" + ":")
		e.Bool(s.IsBot)
	}
	{
		e.Comma()

		e.RawStr("\"first_name\"" + ":")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.Comma()
		}
		if s.LastName.Set {
			e.RawStr("\"last_name\"" + ":")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.Comma()
		}
		if s.Username.Set {
			e.RawStr("\"username\"" + ":")
			s.Username.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.Comma()
		}
		if s.LanguageCode.Set {
			e.RawStr("\"language_code\"" + ":")
			s.LanguageCode.Encode(e)
		}
	}
	{
		if s.CanJoinGroups.Set {
			e.Comma()
		}
		if s.CanJoinGroups.Set {
			e.RawStr("\"can_join_groups\"" + ":")
			s.CanJoinGroups.Encode(e)
		}
	}
	{
		if s.CanReadAllGroupMessages.Set {
			e.Comma()
		}
		if s.CanReadAllGroupMessages.Set {
			e.RawStr("\"can_read_all_group_messages\"" + ":")
			s.CanReadAllGroupMessages.Encode(e)
		}
	}
	{
		if s.SupportsInlineQueries.Set {
			e.Comma()
		}
		if s.SupportsInlineQueries.Set {
			e.RawStr("\"supports_inline_queries\"" + ":")
			s.SupportsInlineQueries.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUser = [9]string{
	0: "id",
	1: "is_bot",
	2: "first_name",
	3: "last_name",
	4: "username",
	5: "language_code",
	6: "can_join_groups",
	7: "can_read_all_group_messages",
	8: "supports_inline_queries",
}

// Decode decodes User from json.
func (s *User) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode User to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int64()
			s.ID = int64(v)
			if err != nil {
				return err
			}
		case "is_bot":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.IsBot = bool(v)
			if err != nil {
				return err
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.FirstName = string(v)
			if err != nil {
				return err
			}
		case "last_name":
			s.LastName.Reset()
			if err := s.LastName.Decode(d); err != nil {
				return err
			}
		case "username":
			s.Username.Reset()
			if err := s.Username.Decode(d); err != nil {
				return err
			}
		case "language_code":
			s.LanguageCode.Reset()
			if err := s.LanguageCode.Decode(d); err != nil {
				return err
			}
		case "can_join_groups":
			s.CanJoinGroups.Reset()
			if err := s.CanJoinGroups.Decode(d); err != nil {
				return err
			}
		case "can_read_all_group_messages":
			s.CanReadAllGroupMessages.Reset()
			if err := s.CanReadAllGroupMessages.Decode(d); err != nil {
				return err
			}
		case "supports_inline_queries":
			s.SupportsInlineQueries.Reset()
			if err := s.SupportsInlineQueries.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUser) {
					name = jsonFieldsNameOfUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserProfilePhotos) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"photos\"" + ":")
		e.ArrStart()
		if len(s.Photos) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Photos[0]
				e.ArrStart()
				if len(elem) >= 1 {
					// Encode first element without comma.
					{
						elem := elem[0]
						elem.Encode(e)
					}
					for _, elem := range elem[1:] {
						e.Comma()
						elem.Encode(e)
					}
				}
				e.ArrEnd()
			}
			for _, elem := range s.Photos[1:] {
				e.Comma()
				e.ArrStart()
				if len(elem) >= 1 {
					// Encode first element without comma.
					{
						elem := elem[0]
						elem.Encode(e)
					}
					for _, elem := range elem[1:] {
						e.Comma()
						elem.Encode(e)
					}
				}
				e.ArrEnd()
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserProfilePhotos = [2]string{
	0: "total_count",
	1: "photos",
}

// Decode decodes UserProfilePhotos from json.
func (s *UserProfilePhotos) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UserProfilePhotos to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "photos":
			requiredBitSet[0] |= 1 << 1
			s.Photos = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []PhotoSize
				elem = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem PhotoSize
					if err := elemElem.Decode(d); err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				s.Photos = append(s.Photos, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserProfilePhotos) {
					name = jsonFieldsNameOfUserProfilePhotos[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Venue) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"location\"" + ":")
		s.Location.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"address\"" + ":")
		e.Str(s.Address)
	}
	{
		if s.FoursquareID.Set {
			e.Comma()
		}
		if s.FoursquareID.Set {
			e.RawStr("\"foursquare_id\"" + ":")
			s.FoursquareID.Encode(e)
		}
	}
	{
		if s.FoursquareType.Set {
			e.Comma()
		}
		if s.FoursquareType.Set {
			e.RawStr("\"foursquare_type\"" + ":")
			s.FoursquareType.Encode(e)
		}
	}
	{
		if s.GooglePlaceID.Set {
			e.Comma()
		}
		if s.GooglePlaceID.Set {
			e.RawStr("\"google_place_id\"" + ":")
			s.GooglePlaceID.Encode(e)
		}
	}
	{
		if s.GooglePlaceType.Set {
			e.Comma()
		}
		if s.GooglePlaceType.Set {
			e.RawStr("\"google_place_type\"" + ":")
			s.GooglePlaceType.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVenue = [7]string{
	0: "location",
	1: "title",
	2: "address",
	3: "foursquare_id",
	4: "foursquare_type",
	5: "google_place_id",
	6: "google_place_type",
}

// Decode decodes Venue from json.
func (s *Venue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Venue to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "location":
			requiredBitSet[0] |= 1 << 0
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Str()
			s.Address = string(v)
			if err != nil {
				return err
			}
		case "foursquare_id":
			s.FoursquareID.Reset()
			if err := s.FoursquareID.Decode(d); err != nil {
				return err
			}
		case "foursquare_type":
			s.FoursquareType.Reset()
			if err := s.FoursquareType.Decode(d); err != nil {
				return err
			}
		case "google_place_id":
			s.GooglePlaceID.Reset()
			if err := s.GooglePlaceID.Decode(d); err != nil {
				return err
			}
		case "google_place_type":
			s.GooglePlaceType.Reset()
			if err := s.GooglePlaceType.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVenue) {
					name = jsonFieldsNameOfVenue[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Video) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"file_id\"" + ":")
		e.Str(s.FileID)
	}
	{
		e.Comma()

		e.RawStr("\"file_unique_id\"" + ":")
		e.Str(s.FileUniqueID)
	}
	{
		e.Comma()

		e.RawStr("\"width\"" + ":")
		e.Int(s.Width)
	}
	{
		e.Comma()

		e.RawStr("\"height\"" + ":")
		e.Int(s.Height)
	}
	{
		e.Comma()

		e.RawStr("\"duration\"" + ":")
		e.Int(s.Duration)
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.FileName.Set {
			e.Comma()
		}
		if s.FileName.Set {
			e.RawStr("\"file_name\"" + ":")
			s.FileName.Encode(e)
		}
	}
	{
		if s.MimeType.Set {
			e.Comma()
		}
		if s.MimeType.Set {
			e.RawStr("\"mime_type\"" + ":")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.Comma()
		}
		if s.FileSize.Set {
			e.RawStr("\"file_size\"" + ":")
			s.FileSize.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVideo = [9]string{
	0: "file_id",
	1: "file_unique_id",
	2: "width",
	3: "height",
	4: "duration",
	5: "thumb",
	6: "file_name",
	7: "mime_type",
	8: "file_size",
}

// Decode decodes Video from json.
func (s *Video) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Video to nil`)
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "width":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.Width = int(v)
			if err != nil {
				return err
			}
		case "height":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Int()
			s.Height = int(v)
			if err != nil {
				return err
			}
		case "duration":
			requiredBitSet[0] |= 1 << 4
			v, err := d.Int()
			s.Duration = int(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "file_name":
			s.FileName.Reset()
			if err := s.FileName.Decode(d); err != nil {
				return err
			}
		case "mime_type":
			s.MimeType.Reset()
			if err := s.MimeType.Decode(d); err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideo) {
					name = jsonFieldsNameOfVideo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s VideoNote) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"file_id\"" + ":")
		e.Str(s.FileID)
	}
	{
		e.Comma()

		e.RawStr("\"file_unique_id\"" + ":")
		e.Str(s.FileUniqueID)
	}
	{
		e.Comma()

		e.RawStr("\"length\"" + ":")
		e.Int(s.Length)
	}
	{
		e.Comma()

		e.RawStr("\"duration\"" + ":")
		e.Int(s.Duration)
	}
	{
		if s.Thumb.Set {
			e.Comma()
		}
		if s.Thumb.Set {
			e.RawStr("\"thumb\"" + ":")
			s.Thumb.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.Comma()
		}
		if s.FileSize.Set {
			e.RawStr("\"file_size\"" + ":")
			s.FileSize.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVideoNote = [6]string{
	0: "file_id",
	1: "file_unique_id",
	2: "length",
	3: "duration",
	4: "thumb",
	5: "file_size",
}

// Decode decodes VideoNote from json.
func (s *VideoNote) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode VideoNote to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "length":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.Length = int(v)
			if err != nil {
				return err
			}
		case "duration":
			requiredBitSet[0] |= 1 << 3
			v, err := d.Int()
			s.Duration = int(v)
			if err != nil {
				return err
			}
		case "thumb":
			s.Thumb.Reset()
			if err := s.Thumb.Decode(d); err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVideoNote) {
					name = jsonFieldsNameOfVideoNote[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Voice) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"file_id\"" + ":")
		e.Str(s.FileID)
	}
	{
		e.Comma()

		e.RawStr("\"file_unique_id\"" + ":")
		e.Str(s.FileUniqueID)
	}
	{
		e.Comma()

		e.RawStr("\"duration\"" + ":")
		e.Int(s.Duration)
	}
	{
		if s.MimeType.Set {
			e.Comma()
		}
		if s.MimeType.Set {
			e.RawStr("\"mime_type\"" + ":")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.FileSize.Set {
			e.Comma()
		}
		if s.FileSize.Set {
			e.RawStr("\"file_size\"" + ":")
			s.FileSize.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVoice = [5]string{
	0: "file_id",
	1: "file_unique_id",
	2: "duration",
	3: "mime_type",
	4: "file_size",
}

// Decode decodes Voice from json.
func (s *Voice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Voice to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.FileID = string(v)
			if err != nil {
				return err
			}
		case "file_unique_id":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Str()
			s.FileUniqueID = string(v)
			if err != nil {
				return err
			}
		case "duration":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.Duration = int(v)
			if err != nil {
				return err
			}
		case "mime_type":
			s.MimeType.Reset()
			if err := s.MimeType.Decode(d); err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoice) {
					name = jsonFieldsNameOfVoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s VoiceChatEnded) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"duration\"" + ":")
		e.Int(s.Duration)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVoiceChatEnded = [1]string{
	0: "duration",
}

// Decode decodes VoiceChatEnded from json.
func (s *VoiceChatEnded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode VoiceChatEnded to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "duration":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.Duration = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoiceChatEnded) {
					name = jsonFieldsNameOfVoiceChatEnded[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s VoiceChatParticipantsInvited) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Users != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Users != nil {
			e.RawStr("\"users\"" + ":")
			e.ArrStart()
			if len(s.Users) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Users[0]
					elem.Encode(e)
				}
				for _, elem := range s.Users[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVoiceChatParticipantsInvited = [1]string{
	0: "users",
}

// Decode decodes VoiceChatParticipantsInvited from json.
func (s *VoiceChatParticipantsInvited) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode VoiceChatParticipantsInvited to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem User
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s VoiceChatScheduled) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"start_date\"" + ":")
		e.Int(s.StartDate)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVoiceChatScheduled = [1]string{
	0: "start_date",
}

// Decode decodes VoiceChatScheduled from json.
func (s *VoiceChatScheduled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode VoiceChatScheduled to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "start_date":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Int()
			s.StartDate = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoiceChatScheduled) {
					name = jsonFieldsNameOfVoiceChatScheduled[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s VoiceChatStarted) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfVoiceChatStarted = [0]string{}

// Decode decodes VoiceChatStarted from json.
func (s *VoiceChatStarted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode VoiceChatStarted to nil`)
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WebhookInfo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"has_custom_certificate\"" + ":")
		e.Bool(s.HasCustomCertificate)
	}
	{
		e.Comma()

		e.RawStr("\"pending_update_count\"" + ":")
		e.Int(s.PendingUpdateCount)
	}
	{
		if s.IPAddress.Set {
			e.Comma()
		}
		if s.IPAddress.Set {
			e.RawStr("\"ip_address\"" + ":")
			s.IPAddress.Encode(e)
		}
	}
	{
		if s.LastErrorDate.Set {
			e.Comma()
		}
		if s.LastErrorDate.Set {
			e.RawStr("\"last_error_date\"" + ":")
			s.LastErrorDate.Encode(e)
		}
	}
	{
		if s.LastErrorMessage.Set {
			e.Comma()
		}
		if s.LastErrorMessage.Set {
			e.RawStr("\"last_error_message\"" + ":")
			s.LastErrorMessage.Encode(e)
		}
	}
	{
		if s.MaxConnections.Set {
			e.Comma()
		}
		if s.MaxConnections.Set {
			e.RawStr("\"max_connections\"" + ":")
			s.MaxConnections.Encode(e)
		}
	}
	{
		if s.AllowedUpdates != nil {
			e.Comma()
		}
		if s.AllowedUpdates != nil {
			e.RawStr("\"allowed_updates\"" + ":")
			e.ArrStart()
			if len(s.AllowedUpdates) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AllowedUpdates[0]
					e.Str(elem)
				}
				for _, elem := range s.AllowedUpdates[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfWebhookInfo = [8]string{
	0: "url",
	1: "has_custom_certificate",
	2: "pending_update_count",
	3: "ip_address",
	4: "last_error_date",
	5: "last_error_message",
	6: "max_connections",
	7: "allowed_updates",
}

// Decode decodes WebhookInfo from json.
func (s *WebhookInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WebhookInfo to nil`)
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "has_custom_certificate":
			requiredBitSet[0] |= 1 << 1
			v, err := d.Bool()
			s.HasCustomCertificate = bool(v)
			if err != nil {
				return err
			}
		case "pending_update_count":
			requiredBitSet[0] |= 1 << 2
			v, err := d.Int()
			s.PendingUpdateCount = int(v)
			if err != nil {
				return err
			}
		case "ip_address":
			s.IPAddress.Reset()
			if err := s.IPAddress.Decode(d); err != nil {
				return err
			}
		case "last_error_date":
			s.LastErrorDate.Reset()
			if err := s.LastErrorDate.Decode(d); err != nil {
				return err
			}
		case "last_error_message":
			s.LastErrorMessage.Reset()
			if err := s.LastErrorMessage.Decode(d); err != nil {
				return err
			}
		case "max_connections":
			s.MaxConnections.Reset()
			if err := s.MaxConnections.Decode(d); err != nil {
				return err
			}
		case "allowed_updates":
			s.AllowedUpdates = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AllowedUpdates = append(s.AllowedUpdates, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return err
	}
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhookInfo) {
					name = jsonFieldsNameOfWebhookInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}
